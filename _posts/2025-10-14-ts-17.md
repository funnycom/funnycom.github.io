---
title: "[TS] HTTP와 API 다루기 - 2"
date: 2025-10-14 23:00:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, http, api]
pin: true
math: true
mermaid: true
published: false
---

> **학습 목표**
> - HTTP 프로토콜이 무엇인지 이해한다
> - REST API의 개념과 설계 원칙을 안다
> - TypeScript에서 API를 호출하고 응답을 처리할 수 있다
> - async/await를 사용하여 비동기 코드를 작성할 수 있다
> - 타입 안전한 API 통신을 구현할 수 있다
> - 에러 처리와 로딩 상태를 관리할 수 있다

---

## TypeScript에서 API 호출하기

이제 실제로 TypeScript로 API를 호출하는 방법을 배워봅시다.

### fetch API 기초

`fetch`는 JavaScript/TypeScript에서 HTTP 요청을 보내는 내장 함수입니다.

**기본 사용법:**

```typescript
// 가장 간단한 GET 요청
fetch("https://api.example.com/users")
  .then(response => response.json())
  .then(data => {
    console.log(data);
  });
```

**fetch의 구조:**

```
fetch(url, options)
  → Promise<Response>
  → response.json()
  → Promise<데이터>
```

### Promise 이해하기

Promise는 "미래에 완료될 작업"을 나타냅니다. API 호출은 시간이 걸리므로 Promise를 사용합니다.

**Promise의 세 가지 상태:**

```
대기 (Pending)   → 작업 진행 중
이행 (Fulfilled) → 작업 성공 ✅
거부 (Rejected)  → 작업 실패 ❌
```

**Promise 사용 예시:**

```typescript
// Promise 생성
const promise = fetch("https://api.example.com/users");

// then으로 성공 처리
promise
  .then(response => {
    console.log("응답 받음!", response);
    return response.json();
  })
  .then(data => {
    console.log("데이터:", data);
  })
  .catch(error => {
    console.log("에러 발생:", error);
  });
```

### async/await 패턴

`async/await`는 Promise를 더 읽기 쉽게 만들어줍니다.

**then/catch vs async/await:**

```typescript
// then/catch 방식 (구식)
function getUsers() {
  fetch("https://api.example.com/users")
    .then(response => response.json())
    .then(data => {
      console.log(data);
    })
    .catch(error => {
      console.error(error);
    });
}

// async/await 방식 (현대적) ✅
async function getUsers() {
  try {
    const response = await fetch("https://api.example.com/users");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```

**async/await 규칙:**

1. `await`는 `async` 함수 안에서만 사용 가능
2. `await`는 Promise가 완료될 때까지 기다림
3. 에러 처리는 `try/catch` 사용

**실전 예제:**

```typescript
// 사용자 정보 가져오기
async function fetchUser(userId: number) {
  try {
    // 1. API 호출
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    
    // 2. 응답을 JSON으로 변환
    const user = await response.json();
    
    // 3. 데이터 사용
    console.log(\`이름: \${user.name}\`);
    console.log(\`이메일: \${user.email}\`);
    
    return user;
  } catch (error) {
    console.error("사용자 정보를 가져올 수 없습니다:", error);
    return null;
  }
}

// 함수 호출
fetchUser(1);
```

### 타입 안전한 API 호출

TypeScript의 장점을 살려 타입 안전한 API 호출을 만들어봅시다.

**1. 응답 데이터 타입 정의:**

```typescript
// API 응답 타입 정의
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

interface Post {
  id: number;
  title: string;
  content: string;
  userId: number;
  createdAt: string;
}

// API 응답 래퍼 타입
interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}
```

**2. 타입이 지정된 API 함수:**

```typescript
// 사용자 조회 (타입 안전)
async function getUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const user: User = await response.json();
    return user;
  } catch (error) {
    console.error("Error fetching user:", error);
    return null;
  }
}

// 사용
const user = await getUser(1);
if (user) {
  console.log(user.name);    // ✅ 타입 안전!
  console.log(user.email);   // ✅ 자동완성 지원!
  // console.log(user.invalid);  // ❌ 컴파일 에러!
}
```

**3. 제네릭을 활용한 재사용 가능한 함수:**

```typescript
// 제네릭 API 호출 함수
async function fetchData<T>(url: string): Promise<T | null> {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const data: T = await response.json();
    return data;
  } catch (error) {
    console.error(\`Error fetching data from \${url}:\`, error);
    return null;
  }
}

// 사용 - 타입을 명시하면 자동으로 타입 체크
const user = await fetchData<User>("https://api.example.com/users/1");
const post = await fetchData<Post>("https://api.example.com/posts/1");
const users = await fetchData<User[]>("https://api.example.com/users");
```

### HTTP 메서드별 fetch 사용법

각 HTTP 메서드를 어떻게 사용하는지 알아봅시다.

**GET - 데이터 조회:**

```typescript
// GET 요청 (기본값)
async function getUsers(): Promise<User[]> {
  const response = await fetch("https://api.example.com/users");
  const users: User[] = await response.json();
  return users;
}

// 쿼리 파라미터 포함
async function searchUsers(query: string): Promise<User[]> {
  const response = await fetch(\`https://api.example.com/users?search=\${query}\`);
  const users: User[] = await response.json();
  return users;
}
```

**POST - 데이터 생성:**

```typescript
// POST 요청
async function createUser(user: Omit<User, "id">): Promise<User> {
  const response = await fetch("https://api.example.com/users", {
    method: "POST",                          // HTTP 메서드
    headers: {
      "Content-Type": "application/json"    // 데이터 형식
    },
    body: JSON.stringify(user)              // 데이터를 JSON 문자열로 변환
  });
  
  const newUser: User = await response.json();
  return newUser;
}

// 사용
const newUser = await createUser({
  name: "홍길동",
  email: "hong@example.com",
  age: 25
});
console.log(\`생성된 사용자 ID: \${newUser.id}\`);
```

**PUT - 전체 수정:**

```typescript
// PUT 요청
async function updateUser(userId: number, user: Omit<User, "id">): Promise<User> {
  const response = await fetch(\`https://api.example.com/users/\${userId}\`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(user)
  });
  
  const updatedUser: User = await response.json();
  return updatedUser;
}

// 사용
const updated = await updateUser(1, {
  name: "김철수",
  email: "kim@example.com",
  age: 30재시도K끊긴 부분부터 다시 작성해markdown// 사용
const updated = await updateUser(1, {
  name: "김철수",
  email: "kim@example.com",
  age: 30
});
```

**PATCH - 부분 수정:**

```typescript
// PATCH 요청
async function patchUser(userId: number, updates: Partial<User>): Promise<User> {
  const response = await fetch(\`https://api.example.com/users/\${userId}\`, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(updates)
  });
  
  const updatedUser: User = await response.json();
  return updatedUser;
}

// 사용 - 일부 속성만 수정
const patched = await patchUser(1, {
  name: "이영희"  // 이름만 수정
});
```

**DELETE - 삭제:**

```typescript
// DELETE 요청
async function deleteUser(userId: number): Promise<boolean> {
  const response = await fetch(\`https://api.example.com/users/\${userId}\`, {
    method: "DELETE"
  });
  
  // 204 No Content 또는 200 OK면 성공
  return response.ok;
}

// 사용
const success = await deleteUser(1);
if (success) {
  console.log("사용자가 삭제되었습니다.");
} else {
  console.log("삭제 실패");
}
```

---

## 에러 처리

API 호출은 여러 이유로 실패할 수 있습니다. 에러를 제대로 처리하는 것이 중요합니다.

### try-catch 문

`async/await`에서는 `try-catch`로 에러를 처리합니다.

```typescript
async function fetchUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    const user: User = await response.json();
    return user;
  } catch (error) {
    // 에러가 발생하면 여기로 옴
    console.error("에러 발생:", error);
    return null;
  }
}
```

### HTTP 에러 처리

`fetch`는 네트워크 에러만 예외를 던지고, HTTP 에러(404, 500 등)는 예외를 던지지 않습니다. 수동으로 체크해야 합니다.

```typescript
async function fetchUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    
    // HTTP 상태 코드 체크
    if (!response.ok) {
      // response.ok는 200-299 범위일 때만 true
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const user: User = await response.json();
    return user;
  } catch (error) {
    console.error("에러 발생:", error);
    return null;
  }
}
```

**상태 코드별 처리:**

```typescript
async function fetchUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    
    // 상태 코드별 처리
    if (response.status === 404) {
      console.error("사용자를 찾을 수 없습니다.");
      return null;
    }
    
    if (response.status === 401) {
      console.error("인증이 필요합니다.");
      // 로그인 페이지로 이동 등
      return null;
    }
    
    if (response.status === 500) {
      console.error("서버 오류가 발생했습니다.");
      return null;
    }
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const user: User = await response.json();
    return user;
  } catch (error) {
    console.error("예상치 못한 에러:", error);
    return null;
  }
}
```

### 네트워크 에러 처리

네트워크가 끊겼거나 서버에 접속할 수 없는 경우를 처리합니다.

```typescript
async function fetchWithTimeout(
  url: string, 
  timeout: number = 5000
): Promise<Response> {
  // 타임아웃 Promise
  const timeoutPromise = new Promise<Response>((_, reject) => {
    setTimeout(() => reject(new Error("요청 시간 초과")), timeout);
  });
  
  // fetch와 timeout 중 먼저 완료되는 것 사용
  return Promise.race([
    fetch(url),
    timeoutPromise
  ]);
}

async function fetchUser(userId: number): Promise<User | null> {
  try {
    const response = await fetchWithTimeout(
      \`https://api.example.com/users/\${userId}\`,
      5000  // 5초 타임아웃
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const user: User = await response.json();
    return user;
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === "요청 시간 초과") {
        console.error("서버 응답이 너무 느립니다.");
      } else if (error.message.includes("Failed to fetch")) {
        console.error("네트워크 연결을 확인하세요.");
      } else {
        console.error("에러:", error.message);
      }
    }
    return null;
  }
}
```

### 타입 가드를 활용한 에러 처리

TypeScript의 타입 가드를 사용하여 안전하게 에러를 처리합니다.

```typescript
// 에러 응답 타입
interface ApiError {
  error: string;
  message: string;
  statusCode: number;
}

// 타입 가드
function isApiError(data: any): data is ApiError {
  return data && typeof data.error === "string";
}

// 사용
async function fetchUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(\`https://api.example.com/users/\${userId}\`);
    const data = await response.json();
    
    // 에러 응답인지 체크
    if (isApiError(data)) {
      console.error(\`API 에러: \${data.message}\`);
      return null;
    }
    
    // 정상 응답
    const user: User = data;
    return user;
  } catch (error) {
    console.error("네트워크 에러:", error);
    return null;
  }
}
```

### 에러 처리 유틸리티

재사용 가능한 에러 처리 함수를 만들어봅시다.

```typescript
// 에러 처리 결과 타입
type Result<T> = 
  | { success: true; data: T }
  | { success: false; error: string };

// 안전한 API 호출 래퍼
async function safeApiCall<T>(
  apiCall: () => Promise<T>
): Promise<Result<T>> {
  try {
    const data = await apiCall();
    return { success: true, data };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : "알 수 없는 에러";
    return { success: false, error: errorMessage };
  }
}

// 사용 예시
async function getUserSafely(userId: number) {
  const result = await safeApiCall(() => 
    fetchData<User>(\`https://api.example.com/users/\${userId}\`)
  );
  
  if (result.success) {
    console.log("사용자 정보:", result.data);
    return result.data;
  } else {
    console.error("에러:", result.error);
    return null;
  }
}
```


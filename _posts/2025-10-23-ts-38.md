---
title: "[TS] ê³ ê¸‰ íƒ€ì… ê¸°ë²• - 1"
date: 2025-10-23 14:00:00 +0900
categories: [ì›¹ ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸]
tags: [ì›¹ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, TS, ìœ í‹¸ë¦¬í‹°íƒ€ì…]
pin: true
math: true
mermaid: true
---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

* ì¡°ê±´ë¶€ íƒ€ì…ìœ¼ë¡œ íƒ€ì…ì„ ë™ì ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ìˆë‹¤
* infer í‚¤ì›Œë“œë¡œ íƒ€ì…ì„ ì¶”ë¡ í•˜ê³  ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤
* ë§¤í•‘ íƒ€ì…ìœ¼ë¡œ ê¸°ì¡´ íƒ€ì…ì„ ë³€í™˜í•  ìˆ˜ ìˆë‹¤
* í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ìœ¼ë¡œ ë¬¸ìì—´ íƒ€ì…ì„ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤
* ì‚¬ìš©ì ì •ì˜ íƒ€ì… ê°€ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤
* isì™€ asserts í‚¤ì›Œë“œë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤
* íƒ€ì… ë‹¨ì–¸ì„ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
* ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…ìœ¼ë¡œ ì¤‘ì²©ëœ íƒ€ì…ì„ ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤

---

## 14.1 ì¡°ê±´ë¶€ íƒ€ì… (Conditional Types)

ì¡°ê±´ë¶€ íƒ€ì…ì€ TypeScriptì˜ ê°€ì¥ ê°•ë ¥í•œ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. **íƒ€ì… ë ˆë²¨ì—ì„œ if-else ë¬¸**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.

### ê¸°ë³¸ ë¬¸ë²• (T extends U ? X : Y)

**ë¬¸ë²•:**
```typescript
T extends U ? X : Y
```

> ğŸ’¡ **ì½ëŠ” ë°©ë²•**: "Tê°€ Uì— í• ë‹¹ ê°€ëŠ¥í•˜ë©´ X, ì•„ë‹ˆë©´ Y"

**ê¸°ë³¸ ì˜ˆì œ:**
```typescript
// ìˆ«ìë©´ "number", ì•„ë‹ˆë©´ "other"
type TypeName<T> = T extends number ? "number" : "other";

type A = TypeName<number>;      // "number"
type B = TypeName<string>;      // "other"
type C = TypeName<boolean>;     // "other"
type D = TypeName<42>;          // "number" (ë¦¬í„°ëŸ´ íƒ€ì…ë„ numberì— í• ë‹¹ ê°€ëŠ¥)
```

**ì‹¤ì „ ì˜ˆì œ 1: ë°°ì—´ ì—¬ë¶€ í™•ì¸**
```typescript
type IsArray<T> = T extends any[] ? "yes" : "no";

type Test1 = IsArray<string[]>;     // "yes"
type Test2 = IsArray<number[]>;     // "yes"
type Test3 = IsArray<string>;       // "no"
type Test4 = IsArray<[1, 2, 3]>;    // "yes" (íŠœí”Œë„ ë°°ì—´)

// ì‹¤ì „ ì‚¬ìš©: ë°°ì—´ì´ë©´ ìš”ì†Œ íƒ€ì…, ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ
type ArrayElement<T> = T extends any[] ? T[number] : T;

type Element1 = ArrayElement<string[]>;  // string
type Element2 = ArrayElement<number>;    // number
```

**ì‹¤ì „ ì˜ˆì œ 2: null ì²´í¬**
```typescript
type NonNullable<T> = T extends null | undefined ? never : T;

type A = NonNullable<string | null>;           // string
type B = NonNullable<number | undefined>;      // number
type C = NonNullable<string | null | undefined>; // string

// ì‚¬ìš©
function processValue<T>(value: T): NonNullable<T> {
  if (value === null || value === undefined) {
    throw new Error("Value cannot be null or undefined");
  }
  return value as NonNullable<T>;
}

const result1 = processValue("hello");  // string
const result2 = processValue(42);       // number
```

**ì‹¤ì „ ì˜ˆì œ 3: ì½ê¸° ì „ìš© ì—¬ë¶€**
```typescript
type IsReadonly<T, K extends keyof T> = 
  Readonly<Pick<T, K>> extends Pick<T, K> ? true : false;

interface User {
  readonly id: number;
  name: string;
}

type IdReadonly = IsReadonly<User, 'id'>;    // true
type NameReadonly = IsReadonly<User, 'name'>; // false
```

### ì¤‘ì²© ì¡°ê±´ë¶€ íƒ€ì…
```typescript
// íƒ€ì… ë¶„ë¥˜í•˜ê¸°
type TypeCategory<T> = 
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends undefined ? "undefined" :
  T extends Function ? "function" :
  "object";

type T1 = TypeCategory<"hello">;      // "string"
type T2 = TypeCategory<42>;           // "number"
type T3 = TypeCategory<true>;         // "boolean"
type T4 = TypeCategory<() => void>;   // "function"
type T5 = TypeCategory<{ a: 1 }>;     // "object"

// ì‹¤ì „ ì‚¬ìš©: íƒ€ì…ë³„ ì²˜ë¦¬
function processValue<T>(value: T): string {
  type Category = TypeCategory<T>;
  
  if (typeof value === "string") {
    return `String: ${value}`;
  }
  if (typeof value === "number") {
    return `Number: ${value}`;
  }
  if (typeof value === "boolean") {
    return `Boolean: ${value}`;
  }
  return `Other: ${value}`;
}
```

### ë¶„ì‚° ì¡°ê±´ë¶€ íƒ€ì… (Distributive Conditional Types)

ìœ ë‹ˆì˜¨ íƒ€ì…ì— ì¡°ê±´ë¶€ íƒ€ì…ì„ ì ìš©í•˜ë©´ **ê° íƒ€ì…ì— ê°œë³„ì ìœ¼ë¡œ** ì ìš©ë©ë‹ˆë‹¤.
```typescript
type ToArray<T> = T extends any ? T[] : never;

// ìœ ë‹ˆì˜¨ íƒ€ì…ì— ì ìš©í•˜ë©´ ë¶„ì‚°ë¨
type StringOrNumber = string | number;
type Result = ToArray<StringOrNumber>;
// ê²°ê³¼: string[] | number[]
// (ToArray<string> | ToArray<number>)

// ë‹¨ê³„ë³„ ì„¤ëª…:
// 1. ToArray<string | number>
// 2. ToArray<string> | ToArray<number>  (ë¶„ì‚°)
// 3. string[] | number[]

// ì‹¤ì „ ì˜ˆì œ: ë°°ì—´ ë˜í•‘
type Arrayify<T> = T extends any ? T[] : never;

type Test = Arrayify<string | number | boolean>;
// string[] | number[] | boolean[]

const arr1: Test = ["hello"];        // âœ… OK
const arr2: Test = [42];             // âœ… OK
const arr3: Test = [true];           // âœ… OK
const arr4: Test = ["hello", 42];    // âŒ ì—ëŸ¬!
```

**ë¶„ì‚° ë°©ì§€í•˜ê¸°:**
```typescript
// ëŒ€ê´„í˜¸ë¡œ ê°ì‹¸ë©´ ë¶„ì‚°ë˜ì§€ ì•ŠìŒ
type ToArrayNonDistributive<T> = [T] extends [any] ? T[] : never;

type Result2 = ToArrayNonDistributive<string | number>;
// ê²°ê³¼: (string | number)[]  (ë¶„ì‚° ì•ˆ ë¨)

const arr: Result2 = ["hello", 42]; // âœ… OK (í˜¼í•© ê°€ëŠ¥)
```

### íƒ€ì… ì¶”ë¡  (infer)

`infer` í‚¤ì›Œë“œëŠ” ì¡°ê±´ë¶€ íƒ€ì… ë‚´ì—ì„œ **íƒ€ì…ì„ ì¶”ë¡ í•˜ê³  ì¶”ì¶œ**í•©ë‹ˆë‹¤.

**ê¸°ë³¸ ë¬¸ë²•:**
```typescript
T extends infer U ? U : never
```

> ğŸ’¡ **infer U**: "ì—¬ê¸°ì„œ íƒ€ì…ì„ ì¶”ë¡ í•´ì„œ Uì— ì €ì¥í•´ì¤˜"

**ì˜ˆì œ 1: ë°˜í™˜ íƒ€ì… ì¶”ì¶œ**
```typescript
// ReturnType êµ¬í˜„
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: "í™ê¸¸ë™" };
}

type User = MyReturnType<typeof getUser>;
// ê²°ê³¼: { id: number; name: string; }

// ì‚¬ìš©
const user: User = { id: 2, name: "ê¹€ì² ìˆ˜" }; // âœ… OK
```

**ì˜ˆì œ 2: ë§¤ê°œë³€ìˆ˜ íƒ€ì… ì¶”ì¶œ**
```typescript
// Parameters êµ¬í˜„
type MyParameters<T> = T extends (...args: infer P) => any ? P : never;

function createUser(name: string, age: number, email: string) {
  return { name, age, email };
}

type Params = MyParameters<typeof createUser>;
// ê²°ê³¼: [name: string, age: number, email: string]

// ì‚¬ìš©
const params: Params = ["í™ê¸¸ë™", 30, "hong@example.com"];
const user = createUser(...params); // âœ… OK
```

**ì˜ˆì œ 3: ë°°ì—´ ìš”ì†Œ íƒ€ì… ì¶”ì¶œ**
```typescript
type ArrayElementType<T> = T extends (infer E)[] ? E : never;

type StringArray = string[];
type Element1 = ArrayElementType<StringArray>;  // string

type NumberArray = number[];
type Element2 = ArrayElementType<NumberArray>;  // number

type MixedArray = (string | number)[];
type Element3 = ArrayElementType<MixedArray>;   // string | number

// ì‹¤ì „ ì‚¬ìš©
function getFirstElement<T extends any[]>(arr: T): ArrayElementType<T> | undefined {
  return arr[0];
}

const first1 = getFirstElement(["a", "b", "c"]);  // string | undefined
const first2 = getFirstElement([1, 2, 3]);        // number | undefined
```

**ì˜ˆì œ 4: Promise ì–¸ë˜í•‘**
```typescript
type Awaited<T> = T extends Promise<infer U> ? U : T;

type A = Awaited<Promise<string>>;      // string
type B = Awaited<Promise<number>>;      // number
type C = Awaited<string>;               // string (Promise ì•„ë‹˜)

// ì¤‘ì²© Promise ì²˜ë¦¬
type DeepAwaited<T> = 
  T extends Promise<infer U> 
    ? DeepAwaited<U> 
    : T;

type Nested = Promise<Promise<Promise<string>>>;
type Unwrapped = DeepAwaited<Nested>;  // string

// ì‹¤ì „ ì‚¬ìš©
async function fetchData(): Promise<{ id: number; name: string }> {
  return { id: 1, name: "ë°ì´í„°" };
}

type Data = Awaited<ReturnType<typeof fetchData>>;
// { id: number; name: string }
```

**ì˜ˆì œ 5: ê°ì²´ ì†ì„± íƒ€ì… ì¶”ì¶œ**
```typescript
type PropertyType<T, K extends string> = 
  T extends { [key in K]: infer V } ? V : never;

interface User {
  id: number;
  name: string;
  email: string;
}

type NameType = PropertyType<User, 'name'>;    // string
type IdType = PropertyType<User, 'id'>;        // number

// ì‹¤ì „ ì‚¬ìš©: ê¹Šì€ ì†ì„± ì ‘ê·¼
type DeepPropertyType<T, Path extends string> =
  Path extends `${infer K}.${infer Rest}`
    ? K extends keyof T
      ? DeepPropertyType<T[K], Rest>
      : never
    : Path extends keyof T
      ? T[Path]
      : never;

interface Company {
  name: string;
  ceo: {
    name: string;
    age: number;
  };
}

type CeoName = DeepPropertyType<Company, 'ceo.name'>;  // string
type CeoAge = DeepPropertyType<Company, 'ceo.age'>;    // number
```

### ì‹¤ì „ ì˜ˆì œ: íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
```typescript
// ì´ë²¤íŠ¸ ë§µ ì •ì˜
interface EventMap {
  'user:login': { userId: number; timestamp: Date };
  'user:logout': { userId: number };
  'post:created': { postId: number; title: string };
  'post:deleted': { postId: number };
}

// ì´ë²¤íŠ¸ ì´ë¦„ ì¶”ì¶œ
type EventName = keyof EventMap;

// íŠ¹ì • ì´ë²¤íŠ¸ì˜ ë°ì´í„° íƒ€ì… ì¶”ì¶œ
type EventData<T extends EventName> = EventMap[T];

// ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ íƒ€ì…
type EventHandler<T extends EventName> = (data: EventData<T>) => void;

// íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ì´ë¯¸í„°
class TypedEventEmitter {
  private handlers: {
    [K in EventName]?: EventHandler<K>[];
  } = {};

  on<T extends EventName>(event: T, handler: EventHandler<T>) {
    if (!this.handlers[event]) {
      this.handlers[event] = [];
    }
    (this.handlers[event] as EventHandler<T>[]).push(handler);
  }

  emit<T extends EventName>(event: T, data: EventData<T>) {
    const eventHandlers = this.handlers[event];
    if (eventHandlers) {
      eventHandlers.forEach(handler => handler(data));
    }
  }
}

// ì‚¬ìš©
const emitter = new TypedEventEmitter();

// âœ… íƒ€ì… ì•ˆì „!
emitter.on('user:login', (data) => {
  console.log(`User ${data.userId} logged in at ${data.timestamp}`);
  // dataëŠ” { userId: number; timestamp: Date } íƒ€ì…
});

emitter.emit('user:login', {
  userId: 1,
  timestamp: new Date()
}); // âœ… OK

emitter.emit('user:login', {
  userId: 1
  // âŒ ì—ëŸ¬! timestampê°€ ì—†ìŒ
});

emitter.on('post:created', (data) => {
  console.log(`Post ${data.postId}: ${data.title}`);
  // dataëŠ” { postId: number; title: string } íƒ€ì…
});
```

### ì¡°ê±´ë¶€ íƒ€ì… í™œìš© íŒ¨í„´

**íŒ¨í„´ 1: í•¨ìˆ˜ì¸ì§€ í™•ì¸**
```typescript
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

type T1 = IsFunction<() => void>;        // true
type T2 = IsFunction<(x: number) => string>; // true
type T3 = IsFunction<string>;            // false
type T4 = IsFunction<number>;            // false
```

**íŒ¨í„´ 2: ì„ íƒì  ì†ì„±ë§Œ ì¶”ì¶œ**
```typescript
type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

interface User {
  id: number;
  name: string;
  email?: string;
  phone?: string;
}

type UserOptionalKeys = OptionalKeys<User>;
// 'email' | 'phone'
```

**íŒ¨í„´ 3: Flatten (ì¤‘ì²© ë°°ì—´ í‰íƒ„í™”)**
```typescript
type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T;

type NestedArray = string[][][];
type Flattened = Flatten<NestedArray>;  // string

type MixedNested = (number | string[])[];
type MixedFlat = Flatten<MixedNested>;  // number | string
```

---

## 14.2 ë§¤í•‘ íƒ€ì… (Mapped Types)

ë§¤í•‘ íƒ€ì…ì€ **ê¸°ì¡´ íƒ€ì…ì˜ ê° ì†ì„±ì„ ìˆœíšŒí•˜ë©° ìƒˆë¡œìš´ íƒ€ì…ì„ ìƒì„±**í•©ë‹ˆë‹¤.

### ê¸°ë³¸ ë§¤í•‘ íƒ€ì…

**ë¬¸ë²•:**
```typescript
type MappedType = {
  [P in Keys]: Type
}
```

> ğŸ’¡ **ì½ëŠ” ë°©ë²•**: "Keysì˜ ê° Pì— ëŒ€í•´, Typeì„ ê°€ì§„ ì†ì„± ìƒì„±"

**ê¸°ë³¸ ì˜ˆì œ:**
```typescript
type Keys = 'name' | 'age' | 'email';

// ëª¨ë“  í‚¤ë¥¼ string íƒ€ì…ìœ¼ë¡œ
type StringRecord = {
  [K in Keys]: string;
};

/*
ê²°ê³¼:
{
  name: string;
  age: string;
  email: string;
}
*/

const user: StringRecord = {
  name: "í™ê¸¸ë™",
  age: "30",        // ìˆ«ìê°€ ì•„ë‹Œ ë¬¸ìì—´!
  email: "hong@example.com"
};
```

### keyofë¥¼ í™œìš©í•œ ë§¤í•‘

**ì˜ˆì œ 1: ëª¨ë“  ì†ì„±ì„ booleanìœ¼ë¡œ**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

// ëª¨ë“  ì†ì„±ì„ booleanìœ¼ë¡œ ë³€í™˜
type BooleanUser = {
  [K in keyof User]: boolean;
};

/*
ê²°ê³¼:
{
  id: boolean;
  name: boolean;
  email: boolean;
}
*/

// ì‚¬ìš©: í”Œë˜ê·¸ ê°ì²´
const flags: BooleanUser = {
  id: true,
  name: false,
  email: true
};
```

**ì˜ˆì œ 2: ëª¨ë“  ì†ì„±ì„ ë°°ì—´ë¡œ**
```typescript
type Arrayify<T> = {
  [K in keyof T]: T[K][];
};

interface Product {
  id: number;
  name: string;
  price: number;
}

type ProductArrays = Arrayify<Product>;

/*
ê²°ê³¼:
{
  id: number[];
  name: string[];
  price: number[];
}
*/

const products: ProductArrays = {
  id: [1, 2, 3],
  name: ["ìƒí’ˆA", "ìƒí’ˆB"],
  price: [1000, 2000]
};
```

**ì˜ˆì œ 3: ëª¨ë“  ì†ì„±ì„ nullableë¡œ**
```typescript
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

interface User {
  id: number;
  name: string;
  email: string;
}

type NullableUser = Nullable<User>;

/*
ê²°ê³¼:
{
  id: number | null;
  name: string | null;
  email: string | null;
}
*/

const user: NullableUser = {
  id: 1,
  name: "í™ê¸¸ë™",
  email: null  // âœ… OK
};
```

### ë§¤í•‘ íƒ€ì… ìˆ˜ì •ì

**+/- ìˆ˜ì •ì:**
```typescript
// +?: ì„ íƒì  ì†ì„± ì¶”ê°€
type Partial<T> = {
  [K in keyof T]+?: T[K];
};

// -?: ì„ íƒì  ì†ì„± ì œê±° (í•„ìˆ˜ë¡œ ë§Œë“¤ê¸°)
type Required<T> = {
  [K in keyof T]-?: T[K];
};

// +readonly: ì½ê¸° ì „ìš© ì¶”ê°€
type Readonly<T> = {
  +readonly [K in keyof T]: T[K];
};

// -readonly: ì½ê¸° ì „ìš© ì œê±°
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};
```

**ì‹¤ì „ ì˜ˆì œ:**
```typescript
interface User {
  readonly id: number;
  name: string;
  email?: string;
}

// ëª¨ë“  readonly ì œê±°, ëª¨ë“  ? ì œê±°
type MutableRequired<T> = {
  -readonly [K in keyof T]-?: T[K];
};

type EditableUser = MutableRequired<User>;

/*
ê²°ê³¼:
{
  id: number;        // readonly ì œê±°ë¨
  name: string;
  email: string;     // ? ì œê±°ë¨
}
*/

const user: EditableUser = {
  id: 1,
  name: "í™ê¸¸ë™",
  email: "hong@example.com"
};

user.id = 2;  // âœ… OK (ì´ì œ ë³€ê²½ ê°€ëŠ¥)
```

### asë¥¼ ì‚¬ìš©í•œ í‚¤ ì¬ë§¤í•‘

**ë¬¸ë²•:**
```typescript
type MappedType = {
  [K in Keys as NewKey]: Type
}
```

**ì˜ˆì œ 1: ì ‘ë‘ì‚¬ ì¶”ê°€**
```typescript
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

interface User {
  name: string;
  age: number;
}

type UserGetters = Getters<User>;

/*
ê²°ê³¼:
{
  getName: () => string;
  getAge: () => number;
}
*/

const userGetters: UserGetters = {
  getName: () => "í™ê¸¸ë™",
  getAge: () => 30
};

console.log(userGetters.getName());  // "í™ê¸¸ë™"
console.log(userGetters.getAge());   // 30
```

**ì˜ˆì œ 2: íŠ¹ì • íƒ€ì… í•„í„°ë§**
```typescript
// í•¨ìˆ˜ê°€ ì•„ë‹Œ ì†ì„±ë§Œ ì„ íƒ
type NonFunctionProperties<T> = {
  [K in keyof T as T[K] extends Function ? never : K]: T[K];
};

interface User {
  id: number;
  name: string;
  getName: () => string;
  getAge: () => number;
}

type UserData = NonFunctionProperties<User>;

/*
ê²°ê³¼:
{
  id: number;
  name: string;
}
*/
```

**ì˜ˆì œ 3: í‚¤ ë³€í™˜**
```typescript
// snake_caseë¥¼ camelCaseë¡œ
type CamelCase<S extends string> = 
  S extends `${infer P1}_${infer P2}${infer P3}`
    ? `${P1}${Uppercase<P2>}${CamelCase<P3>}`
    : S;

type CamelCaseKeys<T> = {
  [K in keyof T as CamelCase<string & K>]: T[K];
};

interface ApiResponse {
  user_id: number;
  user_name: string;
  created_at: string;
}

type CamelResponse = CamelCaseKeys<ApiResponse>;

/*
ê²°ê³¼:
{
  userId: number;
  userName: string;
  createdAt: string;
}
*/
```

### ì»¤ìŠ¤í…€ ìœ í‹¸ë¦¬í‹° íƒ€ì… ë§Œë“¤ê¸°

**ì˜ˆì œ 1: PartialBy - íŠ¹ì • í‚¤ë§Œ ì„ íƒì ìœ¼ë¡œ**
```typescript
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// emailê³¼ ageë§Œ ì„ íƒì ìœ¼ë¡œ
type UserPartial = PartialBy<User, 'email' | 'age'>;

/*
ê²°ê³¼:
{
  id: number;
  name: string;
  email?: string;
  age?: number;
}
*/
```

**ì˜ˆì œ 2: RequiredBy - íŠ¹ì • í‚¤ë§Œ í•„ìˆ˜ë¡œ**
```typescript
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

interface Config {
  host?: string;
  port?: number;
  username?: string;
  password?: string;
}

// hostì™€ portë§Œ í•„ìˆ˜ë¡œ
type RequiredConfig = RequiredBy<Config, 'host' | 'port'>;

/*
ê²°ê³¼:
{
  host: string;
  port: number;
  username?: string;
  password?: string;
}
*/
```

**ì˜ˆì œ 3: ReadonlyBy - íŠ¹ì • í‚¤ë§Œ ì½ê¸° ì „ìš©ìœ¼ë¡œ**
```typescript
type ReadonlyBy<T, K extends keyof T> = Omit<T, K> & Readonly<Pick<T, K>>;

interface User {
  id: number;
  name: string;
  email: string;
}

// idë§Œ ì½ê¸° ì „ìš©ìœ¼ë¡œ
type UserWithReadonlyId = ReadonlyBy<User, 'id'>;

/*
ê²°ê³¼:
{
  readonly id: number;
  name: string;
  email: string;
}
*/

const user: UserWithReadonlyId = {
  id: 1,
  name: "í™ê¸¸ë™",
  email: "hong@example.com"
};

user.name = "ê¹€ì² ìˆ˜";  // âœ… OK
user.id = 2;  // âŒ ì—ëŸ¬! readonly
```

**ì˜ˆì œ 4: PickByType - íŠ¹ì • íƒ€ì…ì˜ ì†ì„±ë§Œ ì„ íƒ**
```typescript
type PickByType<T, ValueType> = {
  [K in keyof T as T[K] extends ValueType ? K : never]: T[K];
};

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
}

// ë¬¸ìì—´ íƒ€ì…ë§Œ
type StringFields = PickByType<User, string>;

/*
ê²°ê³¼:
{
  name: string;
  email: string;
}
*/

// ìˆ«ì íƒ€ì…ë§Œ
type NumberFields = PickByType<User, number>;

/*
ê²°ê³¼:
{
  id: number;
  age: number;
}
*/
```

**ì˜ˆì œ 5: Transform - ì†ì„± íƒ€ì… ë³€í™˜**
```typescript
type Transform<T, From, To> = {
  [K in keyof T]: T[K] extends From ? To : T[K];
};

interface User {
  id: number;
  name: string;
  age: number;
  email: string;
}

// ëª¨ë“  numberë¥¼ stringìœ¼ë¡œ
type StringifiedUser = Transform<User, number, string>;

/*
ê²°ê³¼:
{
  id: string;
  name: string;
  age: string;
  email: string;
}
*/
```

### ì‹¤ì „ ì˜ˆì œ: API ì‘ë‹µ íƒ€ì… ë³€í™˜
```typescript
// API ì‘ë‹µ (snake_case)
interface ApiUser {
  user_id: number;
  user_name: string;
  email_address: string;
  created_at: string;
  updated_at: string;
}

// 1. snake_caseë¥¼ camelCaseë¡œ
type ToCamelCase<S extends string> = 
  S extends `${infer P1}_${infer P2}${infer P3}`
    ? `${P1}${Uppercase<P2>}${ToCamelCase<P3>}`
    : S;

type CamelCaseKeys<T> = {
  [K in keyof T as ToCamelCase<string & K>]: T[K];
};

// 2. ë‚ ì§œ ë¬¸ìì—´ì„ Dateë¡œ
type ParseDates<T> = {
  [K in keyof T]: K extends `${string}At` 
    ? Date 
    : T[K];
};

// ì¡°í•©
type AppUser = ParseDates<CamelCaseKeys<ApiUser>>;

/*
ê²°ê³¼:
{
  userId: number;
  userName: string;
  emailAddress: string;
  createdAt: Date;
  updatedAt: Date;
}
*/

// ë³€í™˜ í•¨ìˆ˜
function transformApiUser(apiUser: ApiUser): AppUser {
  return {
    userId: apiUser.user_id,
    userName: apiUser.user_name,
    emailAddress: apiUser.email_address,
    createdAt: new Date(apiUser.created_at),
    updatedAt: new Date(apiUser.updated_at)
  };
}
```


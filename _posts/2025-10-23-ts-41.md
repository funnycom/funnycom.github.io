---
title: "[TS] ê³ ê¸‰ íƒ€ì… ê¸°ë²• - 4"
date: 2025-10-23 14:30:00 +0900
categories: [ì›¹ ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸]
tags: [ì›¹ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, TS, ê³ ê¸‰íƒ€ì…]
pin: true
math: true
mermaid: true
published: false
---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

* ì¡°ê±´ë¶€ íƒ€ì…ìœ¼ë¡œ íƒ€ì…ì„ ë™ì ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ìˆë‹¤
* infer í‚¤ì›Œë“œë¡œ íƒ€ì…ì„ ì¶”ë¡ í•˜ê³  ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤
* ë§¤í•‘ íƒ€ì…ìœ¼ë¡œ ê¸°ì¡´ íƒ€ì…ì„ ë³€í™˜í•  ìˆ˜ ìˆë‹¤
* í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ìœ¼ë¡œ ë¬¸ìì—´ íƒ€ì…ì„ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤
* ì‚¬ìš©ì ì •ì˜ íƒ€ì… ê°€ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤
* isì™€ asserts í‚¤ì›Œë“œë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤
* íƒ€ì… ë‹¨ì–¸ì„ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
* ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…ìœ¼ë¡œ ì¤‘ì²©ëœ íƒ€ì…ì„ ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤

---

## ğŸ’¡ ì¢…í•© ì‹¤ì „ ì˜ˆì œ

ë°°ìš´ ëª¨ë“  ê¸°ë²•ì„ í™œìš©í•˜ì—¬ íƒ€ì… ì•ˆì „í•œ ORMì„ ë§Œë“¤ì–´ë´…ì‹œë‹¤.
```typescript
// 1. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì •ì˜
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  createdAt: Date;
}

interface Post {
  id: number;
  title: string;
  content: string;
  authorId: number;
  published: boolean;
  createdAt: Date;
}

interface Schema {
  users: User;
  posts: Post;
}

// 2. ì¡°ê±´ë¶€ íƒ€ì…ìœ¼ë¡œ WHERE ì ˆ íƒ€ì…
type WhereCondition<T> = {
  [K in keyof T]?: T[K] | {
    $eq?: T[K];
    $ne?: T[K];
    $gt?: T[K] extends number ? T[K] : never;
    $lt?: T[K] extends number ? T[K] : never;
    $in?: T[K][];
  };
};

// 3. SELECT ì ˆ íƒ€ì… (Pick í™•ì¥)
type SelectFields<T> = (keyof T)[] | "*";

// 4. ë§¤í•‘ íƒ€ì…ìœ¼ë¡œ ê²°ê³¼ íƒ€ì… ìƒì„±
type QueryResult<T, Fields extends SelectFields<T>> = 
  Fields extends "*" 
    ? T 
    : Fields extends (keyof T)[]
      ? Pick<T, Fields[number]>
      : never;

// 5. ì¿¼ë¦¬ ë¹Œë” í´ë˜ìŠ¤
class QueryBuilder
  TableName extends keyof Schema,
  Fields extends SelectFields<Schema[TableName]> = "*"
> {
  constructor(
    private table: TableName,
    private selectedFields?: Fields
  ) {}

  select<F extends (keyof Schema[TableName])[]>(
    ...fields: F
  ): QueryBuilder<TableName, F> {
    return new QueryBuilder(this.table, fields as any);
  }

  where(
    condition: WhereCondition<Schema[TableName]>
  ): this {
    // WHERE ì¡°ê±´ ì²˜ë¦¬
    console.log("WHERE", condition);
    return this;
  }

  async execute(): Promise<QueryResult<Schema[TableName], Fields>[]> {
    // ì‹¤ì œ ì¿¼ë¦¬ ì‹¤í–‰
    return [] as any;
  }
}

// 6. DB ì¸í„°í˜ì´ìŠ¤
class Database {
  table<T extends keyof Schema>(name: T): QueryBuilder<T> {
    return new QueryBuilder(name);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const db = new Database();

// ì˜ˆì‹œ 1: ì „ì²´ í•„ë“œ ì¡°íšŒ
async function getAllUsers() {
  const users = await db.table("users")
    .where({ age: { $gt: 18 } })
    .execute();
  
  // users íƒ€ì…: User[]
  users.forEach(user => {
    console.log(user.id, user.name, user.email);  // âœ… ëª¨ë“  í•„ë“œ ì ‘ê·¼ ê°€ëŠ¥
  });
}

// ì˜ˆì‹œ 2: íŠ¹ì • í•„ë“œë§Œ ì¡°íšŒ
async function getUserNames() {
  const users = await db.table("users")
    .select("id", "name")
    .where({ age: { $gt: 18 } })
    .execute();
  
  // users íƒ€ì…: Pick<User, "id" | "name">[]
  users.forEach(user => {
    console.log(user.id, user.name);  // âœ… OK
    // console.log(user.email);  // âŒ ì—ëŸ¬! emailì€ ì„ íƒí•˜ì§€ ì•ŠìŒ
  });
}

// ì˜ˆì‹œ 3: ë³µì¡í•œ ì¡°ê±´
async function getPublishedPosts() {
  const posts = await db.table("posts")
    .select("title", "authorId", "createdAt")
    .where({
      published: true,
      authorId: { $in: [1, 2, 3] }
    })
    .execute();
  
  // posts íƒ€ì…: Pick<Post, "title" | "authorId" | "createdAt">[]
  posts.forEach(post => {
    console.log(post.title, post.authorId);
    // console.log(post.content);  // âŒ ì—ëŸ¬!
  });
}
```

---

## ğŸ¯ Chapter 14 ì •ë¦¬

### í•µì‹¬ ê°œë…
```
ì¡°ê±´ë¶€ íƒ€ì…        â†’ T extends U ? X : Y
infer             â†’ íƒ€ì… ì¶”ë¡  ë° ì¶”ì¶œ
ë§¤í•‘ íƒ€ì…          â†’ { [K in Keys]: Type }
í…œí”Œë¦¿ ë¦¬í„°ëŸ´      â†’ `hello ${World}`
íƒ€ì… ê°€ë“œ (is)     â†’ value is Type
ë‹¨ì–¸ (asserts)    â†’ asserts value is Type
íƒ€ì… ë‹¨ì–¸ (as)     â†’ value as Type
ì¸ë±ìŠ¤ ì ‘ê·¼        â†’ Type[Key]
```

### ì–¸ì œ ë¬´ì—‡ì„ ì‚¬ìš©í• ê¹Œ?
```
ë™ì  íƒ€ì… ìƒì„±     â†’ ì¡°ê±´ë¶€ íƒ€ì… + infer
íƒ€ì… ë³€í™˜          â†’ ë§¤í•‘ íƒ€ì…
ë¬¸ìì—´ ì¡°ì‘        â†’ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…
ëŸ°íƒ€ì„ íƒ€ì… ì²´í¬   â†’ íƒ€ì… ê°€ë“œ (is)
íƒ€ì… ë³´ì¥          â†’ ë‹¨ì–¸ (asserts)
ì»´íŒŒì¼ëŸ¬ íŒíŠ¸      â†’ íƒ€ì… ë‹¨ì–¸ (as)
ì¤‘ì²© íƒ€ì… ì¶”ì¶œ     â†’ ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…
```

### ì‹¤ì „ í™œìš© íŒ¨í„´
```typescript
// 1. API ì‘ë‹µ ë³€í™˜
type TransformResponse<T> = {
  [K in keyof T as CamelCase<K>]: T[K] extends string
    ? T[K] extends `${string}At`
      ? Date
      : T[K]
    : T[K];
};

// 2. ìœ ë‹ˆì˜¨ì—ì„œ íŠ¹ì • íƒ€ì… ì¶”ì¶œ
type ExtractByType<T, U> = T extends U ? T : never;

// 3. ê¹Šì€ Readonly
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object
    ? DeepReadonly<T[K]>
    : T[K];
};

// 4. í•¨ìˆ˜ ì˜¤ë²„ë¡œë“œ íƒ€ì…
type Overload<T extends (...args: any[]) => any> = 
  T extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
  }
    ? [A1, R1] | [A2, R2]
    : never;
```

### ì£¼ì˜ì‚¬í•­
```typescript
// âŒ í”¼í•´ì•¼ í•  ê²ƒ
type Bad1 = any;  // any ë‚¨ìš©
type Bad2 = string as number;  // ì˜ëª»ëœ ë‹¨ì–¸
type Bad3 = T extends U ? X : Y extends Z ? A : B;  // ê³¼ë„í•œ ì¤‘ì²©

// âœ… ê¶Œì¥ì‚¬í•­
type Good1 = unknown;  // any ëŒ€ì‹  unknown
function isNumber(x: unknown): x is number;  // íƒ€ì… ê°€ë“œ ì‚¬ìš©
type Good3 = CalculateType<T>;  // ì¤‘ê°„ íƒ€ì… ë¶„ë¦¬
```

## ğŸ“ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: íƒ€ì… ìœ í‹¸ë¦¬í‹° êµ¬í˜„
```typescript
// TODO: ë‹¤ìŒ ìœ í‹¸ë¦¬í‹° íƒ€ì…ë“¤ì„ êµ¬í˜„í•˜ì„¸ìš”

// 1. ì¤‘ì²© ê°ì²´ë¥¼ í‰íƒ„í™”
type Flatten<T> = /* ì—¬ê¸°ì— ì‘ì„± */;

interface Nested {
  user: {
    profile: {
      name: string;
      age: number;
    };
  };
}

type Flat = Flatten<Nested>;
// { "user.profile.name": string; "user.profile.age": number }

// 2. í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ê°ì²´ë¡œ
type ParamsToObject<T extends (...args: any[]) => any> = /* ì—¬ê¸°ì— ì‘ì„± */;

function createUser(name: string, age: number, email: string) {}

type UserParams = ParamsToObject<typeof createUser>;
// { name: string; age: number; email: string }

// 3. Promise ì²´ì¸ íƒ€ì…
type PromiseChain<T> = /* ì—¬ê¸°ì— ì‘ì„± */;

type Chain = PromiseChain<Promise<Promise<string>>>;
// string
```

### ë¬¸ì œ 2: íƒ€ì… ê°€ë“œ êµ¬í˜„
```typescript
// TODO: ë‹¤ìŒ íƒ€ì… ê°€ë“œë“¤ì„ êµ¬í˜„í•˜ì„¸ìš”

interface Circle {
  kind: "circle";
  radius: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

type Shape = Circle | Rectangle;

// 1. Circle íƒ€ì… ê°€ë“œ
function isCircle(shape: Shape): shape is Circle {
  /* ì—¬ê¸°ì— ì‘ì„± */
}

// 2. ë°°ì—´ì˜ ëª¨ë“  ìš”ì†Œê°€ íŠ¹ì • íƒ€ì…ì¸ì§€ í™•ì¸
function isArrayOf<T>(
  arr: unknown[],
  guard: (item: unknown) => item is T
): arr is T[] {
  /* ì—¬ê¸°ì— ì‘ì„± */
}

// 3. ê°ì²´ê°€ íŠ¹ì • ì†ì„±ì„ ê°€ì§€ëŠ”ì§€ í™•ì¸
function hasProperty<K extends string>(
  obj: unknown,
  key: K
): obj is Record<K, unknown> {
  /* ì—¬ê¸°ì— ì‘ì„± */
}
```

### ë¬¸ì œ 3: ì‹¤ì „ íƒ€ì… ì‹œìŠ¤í…œ
```typescript
// TODO: íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ êµ¬í˜„í•˜ì„¸ìš”

interface Events {
  "user:login": { userId: number; timestamp: Date };
  "user:logout": { userId: number };
  "post:create": { postId: number; title: string };
}

class EventBus {
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
  on<E extends keyof Events>(
    event: E,
    handler: (data: Events[E]) => void
  ): void {
    /* ì—¬ê¸°ì— ì‘ì„± */
  }

  // ì´ë²¤íŠ¸ ë°œìƒ
  emit<E extends keyof Events>(
    event: E,
    data: Events[E]
  ): void {
    /* ì—¬ê¸°ì— ì‘ì„± */
  }

  // ë¦¬ìŠ¤ë„ˆ ì œê±°
  off<E extends keyof Events>(
    event: E,
    handler: (data: Events[E]) => void
  ): void {
    /* ì—¬ê¸°ì— ì‘ì„± */
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const bus = new EventBus();

bus.on("user:login", (data) => {
  console.log(data.userId, data.timestamp);  // âœ… íƒ€ì… ì•ˆì „
});

bus.emit("user:login", {
  userId: 1,
  timestamp: new Date()
}); // âœ… OK

bus.emit("user:login", {
  userId: 1
  // âŒ ì—ëŸ¬! timestamp í•„ìš”
});
```

## ë‹¤ìŒ Chapter ì˜ˆê³ 

### ëª¨ë“ˆ ì‹œìŠ¤í…œ

- ES Modulesì™€ CommonJS
- import/export ì™„ë²½ ê°€ì´ë“œ
- ëª¨ë“ˆ í•´ì„ ì „ëµ
- íƒ€ì… ì„ ì–¸ íŒŒì¼ (.d.ts)
- ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ êµ¬ì¡°í™”
  
ê³ ê¸‰ íƒ€ì… ê¸°ë²•ì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´, ì´ì œ ì½”ë“œë¥¼ ì²´ê³„ì ìœ¼ë¡œ êµ¬ì¡°í™”í•˜ëŠ” ë°©ë²•ì„ ë°°ì›Œë´…ì‹œë‹¤!


### 14ì¥ì„ ì™„ì„±í–ˆìŠµë‹ˆë‹¤!

**Chapter 14ì˜ íŠ¹ì§•:**
- ì¡°ê±´ë¶€ íƒ€ì…ê³¼ infer í‚¤ì›Œë“œ ì™„ë²½ ì •ë¦¬
- ë§¤í•‘ íƒ€ì…ê³¼ í‚¤ ì¬ë§¤í•‘ í™œìš©
- í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ìœ¼ë¡œ ë¬¸ìì—´ ì¡°ì‘
- íƒ€ì… ê°€ë“œ (is, asserts) ì‹¬í™”
- íƒ€ì… ë‹¨ì–¸ (as) ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•
- ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…ìœ¼ë¡œ ì¤‘ì²© íƒ€ì… ì¶”ì¶œ
- ì‹¤ì „ ORM ì˜ˆì œ
- ì—°ìŠµ ë¬¸ì œ 3ê°œ

---
title: "[Projects] 날씨 대시보드 앱 - 1"
date: 2025-10-15 16:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS]
pin: true
math: true
mermaid: true
published: false
---

> **프로젝트 목표**
> - 실시간 외부 API를 마스터한다
> - 데이터 캐싱 전략을 학습한다
> - 비동기 처리 패턴을 심화한다
> - 사용자 경험(UX)을 고려한 설계를 한다
> - 완전히 자율적으로 프로젝트를 진행한다

---

## 📋 프로젝트 개요

### 무엇을 만들까요?

실시간 날씨 정보를 제공하는 대시보드 애플리케이션을 만들어봅시다.
여러 도시의 날씨를 동시에 확인하고, 예보를 조회하며, 즐겨찾기로 관리할 수 있습니다.

### 완성된 앱의 모습

```
=== 날씨 대시보드 ===

🌤️ 현재 날씨 (2024-01-15 14:30)

📍 서울
   ☀️ 맑음 (Clear)
   온도: 5°C (체감: 2°C)
   습도: 45% | 풍속: 12 km/h
   최저/최고: 1°C / 8°C

📍 도쿄
   ☁️ 흐림 (Clouds)
   온도: 10°C (체감: 8°C)
   습도: 65% | 풍속: 15 km/h
   최저/최고: 7°C / 12°C

📍 뉴욕
   🌧️ 비 (Rain)
   온도: 3°C (체감: 0°C)
   습도: 80% | 풍속: 20 km/h
   최저/최고: 1°C / 5°C

⭐ 즐겨찾기: 서울, 도쿄, 뉴욕
🔄 마지막 업데이트: 2분 전
💾 캐시 상태: 3개 도시 캐싱됨
```

### 학습 목표

이 프로젝트를 완성하면:

- ✅ 실시간 외부 API 통합 능력
- ✅ 데이터 캐싱 및 최적화 능력
- ✅ 비동기 처리 고급 패턴
- ✅ 에러 복구 전략 수립 능력
- ✅ 사용자 경험 최적화 능력
- ✅ 완전 자율적 문제 해결 능력

### 예상 소요 시간

- **총 소요 시간**: 4-6시간
- **설계 단계**: 1시간
- **기본 구현**: 2-3시간
- **고급 기능**: 1-2시간

### 난이도

⭐⭐⭐⭐☆ (상급)

- 프로젝트 1, 2 완성 필수
- 외부 API 연동 경험 필요
- 비동기 프로그래밍 이해 필수
- 캐싱 개념 이해 권장

### 이전 프로젝트와의 차이점
```
┌──────────────────────────────────────────────────────┐
│         프로젝트 1, 2, 3 비교                        │
├────────────┬─────────┬─────────────┬────────────────┤
│            │ Todo 앱 │ 도서관 시스템│  날씨 대시보드 │
├────────────┼─────────┼─────────────┼────────────────┤
│ 난이도     │  ⭐⭐⭐  │   ⭐⭐⭐⭐    │   ⭐⭐⭐⭐       │
│ API 중심도 │  낮음   │    낮음      │   매우 높음 ✅ │
│ 실시간성   │  없음   │    없음      │   있음 ✅      │
│ 캐싱       │  없음   │    없음      │   필수 ✅      │
│ 에러 복구  │  기본   │    기본      │   고급 ✅      │
│ 자율성     │  30%    │    60%       │   90% ✅       │
│ 여러 API   │  1개    │    선택      │   필수 ✅      │
└────────────┴─────────┴─────────────┴────────────────┘
```

**새로운 도전:**
- 실시간 데이터 처리
- 네트워크 불안정성 대응
- 데이터 신선도 관리
- 다중 API 호출 최적화
- 사용자 설정 관리

---

## Part 1: 프로젝트 계획 세우기 (60분)

이번 프로젝트는 **가장 자율적**으로 진행됩니다.
AI의 도움을 최소화하고, 스스로 설계하고 결정하는 연습을 해봅시다.

### 🎯 Step 1: API 이해하기

먼저 사용할 API를 이해해야 합니다.

#### OpenWeather API 탐색

**[ ] 1. API 키 발급받기**
```
작업 순서:
1. https://openweathermap.org 접속
2. 회원가입 (무료)
3. API Keys 메뉴에서 키 복사
4. 안전한 곳에 보관

⚠️ 주의: API 키는 절대 코드에 직접 하드코딩하지 마세요!

내 API 키 (메모장에 보관):
___________________________________________
```

**[ ] 2. API 문서 읽기**
```
OpenWeather API 문서 탐색:
https://openweathermap.org/api

읽어볼 섹션:
□ Current Weather Data API
  - 엔드포인트: /weather
  - 매개변수: q (도시명), appid (API 키), units (단위)
  
□ 5 Day / 3 Hour Forecast API
  - 엔드포인트: /forecast
  - 5일간 3시간 간격 예보

□ API 호출 제한
  - 무료 플랜: 분당 60회, 일 1,000,000회
  - 충분한가? ___________

중요 정보 메모:
┌─────────────────────────────────────┐
│                                     │
│  기본 URL: _____________________    │
│  현재 날씨 엔드포인트: __________   │
│  예보 엔드포인트: _______________   │
│  필수 매개변수: _________________   │
│  선택 매개변수: _________________   │
│                                     │
└─────────────────────────────────────┘
```

**[ ] 3. 브라우저에서 직접 테스트**
```
테스트 URL 만들기:
https://api.openweathermap.org/data/2.5/weather?q=Seoul&appid=YOUR_API_KEY&units=metric

브라우저 주소창에 입력 후 확인:

1. 어떤 데이터가 반환되나?
   _______________________________________

2. 응답 구조는?
   {
     "weather": [ { "main": ?, "description": ? } ],
     "main": { "temp": ?, "humidity": ? },
     ...
   }

3. 필요한 데이터 필드는?
   □ 온도 (temp)
   □ 체감 온도 (feels_like)
   □ 날씨 상태 (weather[0].main)
   □ 날씨 설명 (weather[0].description)
   □ 습도 (humidity)
   □ 풍속 (wind.speed)
   □ _______________________________
   □ _______________________________
```

#### 응답 데이터 구조 분석

**[ ] 4. TypeScript 인터페이스로 구조화하기**
```
API 응답을 보고 필요한 인터페이스 설계:

실제 응답 예시:
{
  "coord": { "lon": 126.9778, "lat": 37.5683 },
  "weather": [
    {
      "id": 800,
      "main": "Clear",
      "description": "clear sky",
      "icon": "01d"
    }
  ],
  "main": {
    "temp": 5.2,
    "feels_like": 2.1,
    "temp_min": 1.0,
    "temp_max": 8.0,
    "pressure": 1015,
    "humidity": 45
  },
  "wind": {
    "speed": 3.5,
    "deg": 200
  },
  "dt": 1705305600,
  "name": "Seoul"
}

내가 정의할 인터페이스:
┌─────────────────────────────────────┐
│                                     │
│  interface WeatherResponse {       │
│    weather: __________________;     │
│    main: _____________________;     │
│    wind: _____________________;     │
│    name: _____________________;     │
│    dt: _______________________;     │
│  }                                  │
│                                     │
│  interface WeatherInfo {           │
│    ___________________________     │
│  }                                  │
│                                     │
│  interface MainInfo {              │
│    ___________________________     │
│  }                                  │
│                                     │
└─────────────────────────────────────┘
```

---

### 🎨 Step 2: 핵심 기능 설계

#### 기능 요구사항 정리

**[ ] 1. 필수 기능 vs 선택 기능 구분**
```
필수 기능 (MVP):
□ 도시 이름으로 현재 날씨 조회
□ 날씨 정보 표시 (온도, 상태, 습도, 풍속)
□ 여러 도시 동시 조회
□ 에러 처리 (도시 못 찾음, 네트워크 오류)

선택 기능 (우선순위 부여):
□ 5일 예보 조회 (우선순위: ___)
□ 즐겨찾기 기능 (우선순위: ___)
□ 데이터 캐싱 (우선순위: ___)
□ 자동 새로고침 (우선순위: ___)
□ 온도 단위 변환 (섭씨/화씨) (우선순위: ___)
□ 날씨 아이콘/이모지 (우선순위: ___)
□ 위치 기반 자동 조회 (우선순위: ___)
□ 검색 히스토리 (우선순위: ___)

내가 구현할 기능:
1단계 (필수): __________________________
2단계 (추가): __________________________
3단계 (고급): __________________________
```

#### 캐싱 전략 설계

**[ ] 2. 왜 캐싱이 필요한가?**
```
문제 상황:
- 같은 도시를 5초마다 조회하면?
  → API 호출 낭비, 요금 발생 가능
  
- 네트워크가 느릴 때?
  → 사용자가 계속 기다림
  
- API 호출 제한 (분당 60회)?
  → 제한 초과 시 서비스 불가

해결책: 캐싱!

캐싱이란?
한번 가져온 데이터를 메모리에 저장해두고,
일정 시간 동안은 저장된 데이터를 사용하는 것

질문에 답하며 캐싱 전략 세우기:

1. 얼마나 오래 캐싱할까?
   - 너무 짧으면: 캐싱 효과 없음
   - 너무 길면: 오래된 데이터
   
   내 선택: _____분 (권장: 5-10분)
   이유: _________________________________

2. 무엇을 키(key)로 사용할까?
   - 도시 이름? 좌표? 둘 다?
   
   내 선택: __________________________
   이유: _________________________________

3. 캐시를 어디에 저장할까?
   - 메모리 (Map 객체)
   - localStorage
   - 둘 다
   
   내 선택: __________________________
   이유: _________________________________

4. 캐시 만료는 어떻게 확인할까?
   - 저장 시간을 함께 저장
   - 현재 시간과 비교
   
   구현 방법: _________________________
```

**[ ] 3. 캐시 데이터 구조 설계**
```
캐시 항목이 가져야 할 정보:

┌─────────────────────────────────────┐
│  interface CacheEntry<T> {         │
│    data: T;            // 실제 데이터│
│    timestamp: number;  // 저장 시간 │
│    expiresIn: number;  // 유효 시간 │
│  }                                  │
│                                     │
│  class Cache<T> {                  │
│    private cache: Map<string, CacheEntry<T>>;│
│                                     │
│    set(key, data, ttl) { ... }     │
│    get(key): T | null { ... }      │
│    has(key): boolean { ... }       │
│    clear() { ... }                 │
│    isExpired(entry): boolean {...} │
│  }                                  │
└─────────────────────────────────────┘

설계 결정:
- 제네릭을 사용하는 이유: _______________
- Map을 사용하는 이유: __________________
- timestamp vs Date: ____________________
```

---

### 🏗️ Step 3: 클래스 구조 설계

#### 전체 아키텍처 구상

**[ ] 1. 필요한 클래스 파악**
```
생각해보기:
- API 호출은 어디서?
- 캐싱은 어디서?
- 날씨 데이터는 어떤 클래스로?
- 여러 도시 관리는?
- 사용자 설정 (즐겨찾기)은?

내가 설계한 클래스들:

┌─────────────────────────────────────┐
│                                     │
│  1. ___________Service              │
│     역할: _______________________   │
│     주요 메서드: ________________   │
│                                     │
│  2. ___________Cache                │
│     역할: _______________________   │
│     주요 메서드: ________________   │
│                                     │
│  3. ___________Data                 │
│     역할: _______________________   │
│     주요 메서드: ________________   │
│                                     │
│  4. ___________Manager              │
│     역할: _______________________   │
│     주요 메서드: ________________   │
│                                     │
└─────────────────────────────────────┘
```

**💡 힌트:**

<details>
<summary>일반적인 구조 예시</summary>
```
1. WeatherApiService
   - API 호출 전담
   - fetch 래핑
   - 에러 처리

2. CacheManager<T>
   - 제네릭 캐시
   - TTL 관리
   - 만료 확인

3. WeatherData
   - 날씨 정보 표현
   - 데이터 변환
   - 포맷팅

4. WeatherDashboard
   - 전체 조율
   - 여러 도시 관리
   - 사용자 인터페이스
```

</details>

#### WeatherApiService 설계

**[ ] 2. API 서비스 클래스 상세 설계**
```
질문에 답하며 설계:

1. API 키는 어떻게 관리할까?
   □ 생성자에서 받기
   □ 환경 변수에서 읽기
   □ 설정 파일에서 읽기
   
   내 선택: __________________________
   이유: _________________________________

2. 어떤 메서드가 필요할까?
   □ getCurrentWeather(city: string)
   □ getForecast(city: string)
   □ getWeatherByCoords(lat, lon)
   □ _______________________________
   
3. 응답은 어떤 형태로?
   - 원시 API 응답 그대로?
   - 가공된 WeatherData 객체?
   
   내 선택: __________________________
   이유: _________________________________

설계 스케치:
┌─────────────────────────────────────┐
│  class WeatherApiService {         │
│                                     │
│    private baseUrl: string;        │
│    private apiKey: string;         │
│                                     │
│    constructor(_____________) {    │
│      ___________________________   │
│    }                                │
│                                     │
│    async getCurrentWeather(        │
│      city: string               │
│    ): Promise<___________> {       │
│      ___________________________   │
│    }                                │
│                                     │
│    private async fetch<T>(         │
│      endpoint: string,          │
│      params: object             │
│    ): Promise<T> {                 │
│      // 공통 fetch 로직            │
│    }                                │
│                                     │
│    private handleError(error) {    │
│      // 에러 처리                   │
│    }                                │
│  }                                  │
└─────────────────────────────────────┘
```

#### CacheManager 설계

**[ ] 3. 캐시 관리자 설계**
```
제네릭 캐시 클래스:

┌─────────────────────────────────────┐
│  class CacheManager<T> {           │
│                                     │
│    private cache: Map<             │
│      string,                       │
│      CacheEntry<T>                 │
│    >;                               │
│    private defaultTTL: number;     │
│                                     │
│    constructor(defaultTTL = 300000) {│
│      // 5분 기본값                  │
│    }                                │
│                                     │
│    set(                            │
│      key: string,                  │
│      data: T,                      │
│      ttl?: number                  │
│    ): void {                       │
│      ___________________________   │
│    }                                │
│                                     │
│    get(key: string): T | null {    │
│      ___________________________   │
│    }                                │
│                                     │
│    has(key: string): boolean {     │
│      ___________________________   │
│    }                                │
│                                     │
│    private isExpired(              │
│      entry: CacheEntry<T>          │
│    ): boolean {                    │
│      ___________________________   │
│    }                                │
│                                     │
│    clear(): void { }               │
│    size(): number { }              │
│  }                                  │
└─────────────────────────────────────┘

고민할 점:
1. 캐시 크기 제한이 필요한가?
   내 생각: ____________________________

2. LRU (Least Recently Used) 구현?
   내 생각: ____________________________

3. localStorage 동기화?
   내 생각: ____________________________
```

#### WeatherData 클래스 설계

**[ ] 4. 날씨 데이터 클래스**
```
날씨 정보를 표현하는 클래스:

┌─────────────────────────────────────┐
│  class WeatherData {               │
│                                     │
│    constructor(                    │
│      public city: string,          │
│      public temperature: number,   │
│      public feelsLike: number,     │
│      public condition: string,     │
│      public description: string,   │
│      public humidity: number,      │
│      public windSpeed: number,     │
│      public tempMin: number,       │
│      public tempMax: number,       │
│      public timestamp: Date        │
│    ) {}                             │
│                                     │
│    // 정적 팩토리 메서드            │
│    static fromApiResponse(         │
│      response: WeatherResponse     │
│    ): WeatherData {                │
│      // API 응답을 WeatherData로   │
│      ___________________________   │
│    }                                │
│                                     │
│    getTemperatureF(): number {     │
│      // 섭씨를 화씨로               │
│    }                                │
│                                     │
│    getWeatherEmoji(): string {     │
│      // 날씨에 맞는 이모지          │
│    }                                │
│                                     │
│    getFormattedInfo(): string {    │
│      // 보기 좋게 포맷              │
│    }                                │
│                                     │
│    isDataFresh(minutes: number): boolean {│
│      // 데이터가 신선한지           │
│    }                                │
│  }                                  │
└─────────────────────────────────────┘

추가 기능 아이디어:
- _____________________________________
- _____________________________________
```

#### WeatherDashboard 설계

**[ ] 5. 대시보드 통합 클래스**
```
모든 것을 조율하는 메인 클래스:

┌─────────────────────────────────────┐
│  class WeatherDashboard {          │
│                                     │
│    private apiService: WeatherApiService;│
│    private cache: CacheManager<WeatherData>;│
│    private favorites: Set<string>; │
│    private weatherData: Map<       │
│      string,                       │
│      WeatherData                   │
│    >;                               │
│                                     │
│    constructor(apiKey: string) {   │
│      ___________________________   │
│    }                                │
│                                     │
│    async getWeather(               │
│      city: string,                 │
│      useCache = true               │
│    ): Promise<WeatherData> {       │
│      // 1. 캐시 확인                │
│      // 2. 없으면 API 호출          │
│      // 3. 캐시에 저장              │
│    }                                │
│                                     │
│    async getMultipleWeather(       │
│      cities: string[]              │
│    ): Promise<WeatherData[]> {     │
│      // Promise.all 활용?           │
│    }                                │
│                                     │
│    addFavorite(city: string) { }   │
│    removeFavorite(city: string) { }│
│    getFavorites(): string[] { }    │
│                                     │
│    async refreshAll(): Promise<void> {│
│      // 모든 도시 데이터 새로고침   │
│    }                                │
│                                     │
│    printDashboard(): void {        │
│      // 전체 대시보드 출력          │
│    }                                │
│                                     │
│    getStatistics() {               │
│      // 캐시 상태, 조회 횟수 등     │
│    }                                │
│  }                                  │
└─────────────────────────────────────┘
```

---

### 📋 Step 4: 에러 처리 전략

API 중심 프로젝트에서 에러 처리는 매우 중요합니다!

**[ ] 1. 예상되는 에러 시나리오**
```
발생 가능한 에러들:

네트워크 에러:
□ 인터넷 연결 끊김
□ API 서버 다운
□ 타임아웃
→ 대응: _______________________________

API 에러:
□ 잘못된 API 키
□ 도시 이름 오류 (존재하지 않음)
□ API 호출 제한 초과
□ 400, 401, 404, 500 등
→ 대응: _______________________________

데이터 에러:
□ 응답 형식이 예상과 다름
□ 필수 필드 누락
□ 타입 불일치
→ 대응: _______________________________

캐시 에러:
□ 캐시 데이터 손상
□ 만료 시간 계산 오류
→ 대응: _______________________________
```

**[ ] 2. 에러 처리 계층**
```
에러를 어디서 어떻게 처리할까?

계층별 처리:

1. API Service 계층
   - HTTP 에러 감지
   - 재시도 로직
   - 상세 에러 정보 제공
   
   구현 방법: _________________________

2. Dashboard 계층
   - 캐시 폴백 (캐시된 오래된 데이터라도 표시)
   - 사용자 친화적 메시지
   - 로깅
   
   구현 방법: _________________________

3. 사용자 인터페이스 계층
   - 에러 메시지 표시
   - 재시도 버튼 제공
   
   구현 방법: _________________________
```

**[ ] 3. 재시도 전략**
```
API 호출 실패 시 재시도할까?

질문:
1. 재시도가 필요한 경우는?
   □ 네트워크 일시적 오류
   □ 타임아웃
   □ 503 Service Unavailable
   
   내 판단: ____________________________

2. 재시도하지 말아야 할 경우는?
   □ 401 Unauthorized (잘못된 API 키)
   □ 404 Not Found (존재하지 않는 도시)
   □ 400 Bad Request
   
   내 판단: ____________________________

3. 재시도 로직:
   - 최대 재시도 횟수: ___회
   - 재시도 간격: _________초
   - 증가 전략 (exponential backoff): 사용/미사용
   
   내 설계: ____________________________
```

**[ ] 4. 폴백(Fallback) 전략**
```
API 호출이 완전히 실패했을 때:

옵션 1: 캐시된 오래된 데이터 사용
  - 장점: __

____________________________
  - 단점: _______________________________
  
옵션 2: 기본값 표시
  - 장점: _______________________________
  - 단점: _______________________________

옵션 3: 에러 메시지만 표시
  - 장점: _______________________________
  - 단점: _______________________________

내 선택: ________________________________
이유: ___________________________________
```

---

### ✅ Step 5: 구현 우선순위

**[ ] 1. 단계별 구현 계획**
```
1단계: 기본 기능 (MVP)
  목표: 한 도시의 날씨 조회
  
  □ WeatherApiService 기본 구조
  □ API 호출 및 에러 처리
  □ WeatherData 클래스
  □ 간단한 출력
  
  예상 시간: _______시간

2단계: 캐싱 시스템
  목표: 불필요한 API 호출 줄이기
  
  □ CacheManager 클래스
  □ TTL 관리
  □ 캐시 통합
  
  예상 시간: _______시간

3단계: 다중 도시 & 대시보드
  목표: 여러 도시 동시 조회
  
  □ WeatherDashboard 클래스
  □ Promise.all 활용
  □ 즐겨찾기 기능
  □ 대시보드 UI
  
  예상 시간: _______시간

4단계: 고급 기능
  목표: UX 개선
  
  □ 5일 예보
  □ 자동 새로고침
  □ 통계 기능
  □ _______________________________
  
  예상 시간: _______시간
```

**[ ] 2. 완성도 체크리스트**
최소 완성 기준:
□ 도시 이름으로 날씨 조회
□ 온도, 날씨 상태, 습도, 풍속 표시
□ 에러 처리 (도시 없음, 네트워크 오류)
□ 기본 캐싱 (5분)
□ 여러 도시 조회
□ 테스트 완료

추가 목표:
□ 5일 예보
□ 즐겨찾기
□ 자동 새로고침
□ 날씨 아이콘/이모지
□ 통계 (API 호출 횟수, 캐시 히트율)
□ localStorage 영속성
```

---

### 💡 Step 6: 최종 설계 검토

구현을 시작하기 전에 전체 설계를 다시 한 번 검토해봅시다.

**[ ] 1. 설계 검토 체크리스트**
```
아키텍처:
□ 각 클래스의 역할이 명확한가?
□ 클래스 간 의존성이 적절한가?
□ 확장 가능한 구조인가?

데이터 흐름:
□ 사용자 요청 → Dashboard → API/Cache → 응답
□ 흐름이 명확한가?
□ 순환 참조는 없는가?

에러 처리:
□ 모든 에러 시나리오를 고려했는가?
□ 각 계층에서 적절히 처리되는가?
□ 사용자에게 의미 있는 메시지를 주는가?

성능:
□ 불필요한 API 호출을 줄였는가?
□ 캐싱 전략이 합리적인가?
□ 병렬 처리를 활용하는가?

사용자 경험:
□ 로딩 상태를 알려주는가?
□ 에러를 친절하게 안내하는가?
□ 데이터가 얼마나 오래되었는지 알려주는가?
```

**[ ] 2. 설계 문서 작성**
```
내 프로젝트 설계 요약:

1. 목표
   _________________________________________
   _________________________________________

2. 핵심 클래스 (4-5개)
   - __________________: ___________________
   - __________________: ___________________
   - __________________: ___________________
   - __________________: ___________________

3. 데이터 흐름
   _________________________________________
   _________________________________________

4. 캐싱 전략
   - TTL: ________분
   - 저장소: _______________
   - 키: ___________________

5. 에러 처리
   - 재시도: 최대 ___회
   - 폴백: _________________

6. 구현 순서
   1단계: _______________________
   2단계: _______________________
   3단계: _______________________
   4단계: _______________________
```

**[ ] 3. 스스로 질문하기**
```
설계에 대한 자기 질문:

1. 이 설계로 요구사항을 모두 충족할 수 있는가?
   답: _____________________________________

2. 가장 어려울 것 같은 부분은?
   답: _____________________________________
   → 어떻게 해결할까? ______________________

3. 더 나은 설계 방법은 없을까?
   답: _____________________________________

4. 이 설계의 장단점은?
   장점: ___________________________________
   단점: ___________________________________

5. 프로젝트 1, 2에서 배운 것을 적용했는가?
   답: _____________________________________
```

---

### 🎯 Part 1 완료 체크

**[ ] Part 1을 완료하기 전에:**
```
□ OpenWeather API 키를 발급받았다
□ API 문서를 읽고 이해했다
□ 브라우저에서 API를 직접 테스트했다
□ 필요한 인터페이스를 설계했다
□ 각 클래스의 역할을 정의했다
□ 캐싱 전략을 수립했다
□ 에러 처리 방법을 계획했다
□ 구현 순서를 정했다
□ 전체 설계를 문서화했다
```

**모두 체크했다면 Part 2로 진행!**
```
준비 완료 점수:

9-9개 체크: 완벽! 바로 구현 시작 ✅
6-8개 체크: 좋음! 부족한 부분 보완 후 진행
0-5개 체크: 설계를 더 다듬어야 함
```

---

## 💭 설계 팁

### 좋은 설계의 특징

**1. 단순함 (Simplicity)**
```
복잡한 것보다 단순한 것이 낫습니다.
- 클래스를 너무 많이 만들지 마세요
- 각 클래스는 하나의 명확한 책임
- 이해하기 쉬운 구조
```

**2. 확장 가능성 (Extensibility)**
```
나중에 기능을 추가하기 쉬워야 합니다.
- 새로운 API 추가가 쉬운가?
- 새로운 캐싱 전략 적용이 쉬운가?
- 새로운 데이터 소스 추가가 쉬운가?
```

**3. 테스트 가능성 (Testability)**
```
각 부분을 독립적으로 테스트할 수 있어야 합니다.
- API 없이 캐시 테스트 가능?
- Mock 데이터로 Dashboard 테스트 가능?
```

**4. 에러 복원력 (Error Resilience)**
```
에러가 발생해도 앱이 멈추지 않아야 합니다.
- API 실패 시에도 캐시 데이터 제공
- 네트워크 복구 시 자동 재시도
- 의미 있는 에러 메시지
```

---

## 📚 참고 자료

### API 관련

**OpenWeather API 문서:**
```
공식 문서: https://openweathermap.org/api
Current Weather: https://openweathermap.org/current
5 Day Forecast: https://openweathermap.org/forecast5
API 에러 코드: https://openweathermap.org/faq#error401
```

**대안 날씨 API:**
```
- WeatherAPI: https://www.weatherapi.com/
- Tomorrow.io: https://www.tomorrow.io/
- Visual Crossing: https://www.visualcrossing.com/
```

### 캐싱 관련

**학습 자료:**
```
- MDN: Map 객체
  https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map

- 캐싱 전략 패턴
  - Cache-Aside (Lazy Loading)
  - Write-Through
  - Time-To-Live (TTL)
```

### 비동기 처리

**학습 자료:**
```
- Promise.all vs Promise.allSettled
- 병렬 vs 순차 처리
- 에러 핸들링 패턴
```

---

## 🎓 학습 포인트

### Part 1에서 중요한 것

**1. 스스로 설계하기**
```
이번에는 AI에게 "어떻게 설계할까요?"라고 
묻지 않고 스스로 설계했습니다.

- 요구사항을 분석했나요? ✅
- 각 부분의 역할을 정의했나요? ✅
- 전체 구조를 그려보았나요? ✅
```

**2. 트레이드오프 이해하기**
```
모든 결정에는 장단점이 있습니다.

예시:
- 캐싱 시간을 길게? → 오래된 데이터 위험
- 캐싱 시간을 짧게? → API 호출 증가

완벽한 답은 없습니다.
상황에 맞는 최선의 선택을 하세요.
```

**3. 에러를 먼저 생각하기**
```
"행복한 경로"만 생각하지 마세요.

질문:
- 네트워크가 끊기면?
- API 키가 잘못되면?
- 응답이 예상과 다르면?
- 타임아웃이 나면?

이런 상황을 미리 계획하세요.
```

---

## ✨ Part 1 완료!

**축하합니다! 설계 단계를 완료했습니다!**

### 다음 단계

**Part 2: AI와 함께 구현하기**

이제 설계를 바탕으로 실제 코드를 작성할 차례입니다.

하지만 이번에는:
- ❌ AI에게 "전부 만들어줘"라고 하지 않습니다
- ✅ 설계를 보여주고 "이 부분을 구현해줘"라고 합니다
- ✅ AI의 코드를 받으면 이해하고 개선합니다
- ✅ 막힐 때만 도움을 요청합니다

**준비되셨나요?**

Part 2에서는:
1. WeatherApiService 구현
2. CacheManager 구현
3. WeatherData 클래스 구현
4. WeatherDashboard 통합
5. 테스트 및 디버깅

각 단계를 차근차근 진행해봅시다!

---

**Part 1 완료 시간 기록:**

시작: _____________
종료: _____________
소요: _____________

**자기 평가:**
```
설계 완성도: ___/10
이해도: ___/10
자신감: ___/10

소감:
_________________________________________
_________________________________________
_________________________________________
```

**다음 단계 준비:**
```
□ API 키 준비 완료
□ 설계 문서 작성 완료
□ 구현 순서 정리 완료
□ 코드 에디터 준비
□ Part 2로 이동 준비 완료!

Part 1을 완성했습니다! 

**Part 1의 특징:**
- 완전히 자율적인 설계 과정
- AI에게 직접 물어보지 않고 스스로 생각하도록 유도
- 실전 API 사용 준비 (OpenWeather)
- 캐싱 전략 수립
- 에러 처리 계획
- 상세한 체크리스트


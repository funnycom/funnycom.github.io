---
title: "[TS] HTTP와 API 다루기 - 3"
date: 2025-10-14 23:00:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, http, api]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - HTTP 프로토콜이 무엇인지 이해한다
> - REST API의 개념과 설계 원칙을 안다
> - TypeScript에서 API를 호출하고 응답을 처리할 수 있다
> - async/await를 사용하여 비동기 코드를 작성할 수 있다
> - 타입 안전한 API 통신을 구현할 수 있다
> - 에러 처리와 로딩 상태를 관리할 수 있다

--- 

## 실전 공개 API 활용

이제 실제로 사용할 수 있는 공개 API를 활용해봅시다.

### JSONPlaceholder (연습용 API)

JSONPlaceholder는 연습용 가짜 REST API입니다. 무료이고 인증이 필요 없어 학습에 최적입니다.

**기본 정보:**
- URL: https://jsonplaceholder.typicode.com
- 인증: 불필요
- 제한: 없음
- 데이터: 가짜 데이터 (실제로 저장되지 않음)

**제공하는 리소스:**

```typescript
/posts       // 게시글 (100개)
/comments    // 댓글 (500개)
/albums      // 앨범 (100개)
/photos      // 사진 (5000개)
/todos       // 할 일 (200개)
/users       // 사용자 (10명)
```

**실전 예제 1: 게시글 가져오기**

```typescript
// 게시글 타입
interface Post {
  userId: number;
  id: number;
  title: string;
  body: string;
}

// 모든 게시글 가져오기
async function getAllPosts(): Promise<Post[]> {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts");
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const posts: Post[] = await response.json();
    return posts;
  } catch (error) {
    console.error("게시글을 가져올 수 없습니다:", error);
    return [];
  }
}

// 특정 게시글 가져오기
async function getPost(postId: number): Promise<Post | null> {
  try {
    const response = await fetch(
      \`https://jsonplaceholder.typicode.com/posts/\${postId}\`
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const post: Post = await response.json();
    return post;
  } catch (error) {
    console.error("게시글을 가져올 수 없습니다:", error);
    return null;
  }
}

// 사용
const posts = await getAllPosts();
console.log(\`총 \${posts.length}개의 게시글\`);

const post = await getPost(1);
if (post) {
  console.log(\`제목: \${post.title}\`);
  console.log(\`내용: \${post.body}\`);
}
```

**실전 예제 2: 게시글 생성/수정/삭제**

```typescript
// 게시글 생성
async function createPost(post: Omit<Post, "id">): Promise<Post | null> {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(post)
    });
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const newPost: Post = await response.json();
    console.log("게시글이 생성되었습니다:", newPost);
    return newPost;
  } catch (error) {
    console.error("게시글 생성 실패:", error);
    return null;
  }
}

// 게시글 수정
async function updatePost(postId: number, updates: Partial<Post>): Promise<Post | null> {
  try {
    const response = await fetch(
      \`https://jsonplaceholder.typicode.com/posts/\${postId}\`,
      {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updates)
      }
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const updatedPost: Post = await response.json();
    console.log("게시글이 수정되었습니다:", updatedPost);
    return updatedPost;
  } catch (error) {
    console.error("게시글 수정 실패:", error);
    return null;
  }
}

// 게시글 삭제
async function deletePost(postId: number): Promise<boolean> {
  try {
    const response = await fetch(
      \`https://jsonplaceholder.typicode.com/posts/\${postId}\`,
      {
        method: "DELETE"
      }
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    console.log(\`게시글 \${postId}이(가) 삭제되었습니다.\`);
    return true;
  } catch (error) {
    console.error("게시글 삭제 실패:", error);
    return false;
  }
}

// 사용 예시
console.log("=== JSONPlaceholder 테스트 ===\n");

// 생성
const newPost = await createPost({
  userId: 1,
  title: "새로운 게시글",
  body: "이것은 테스트 게시글입니다."
});

if (newPost) {
  // 수정
  await updatePost(newPost.id, {
    title: "수정된 제목"
  });
  
  // 삭제
  await deletePost(newPost.id);
}
```

**실전 예제 3: 사용자와 게시글 (중첩 데이터)**

```typescript
// 사용자 타입
interface User {
  id: number;
  name: string;
  email: string;
  username: string;
}

// 사용자 정보 가져오기
async function getUser(userId: number): Promise<User | null> {
  try {
    const response = await fetch(
      \`https://jsonplaceholder.typicode.com/users/\${userId}\`
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const user: User = await response.json();
    return user;
  } catch (error) {
    console.error("사용자를 가져올 수 없습니다:", error);
    return null;
  }
}

// 특정 사용자의 게시글 가져오기
async function getUserPosts(userId: number): Promise<Post[]> {
  try {
    const response = await fetch(
      \`https://jsonplaceholder.typicode.com/posts?userId=\${userId}\`
    );
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const posts: Post[] = await response.json();
    return posts;
  } catch (error) {
    console.error("게시글을 가져올 수 없습니다:", error);
    return [];
  }
}

// 사용자와 게시글 함께 가져오기
async function getUserWithPosts(userId: number) {
  const user = await getUser(userId);
  
  if (!user) {
    console.log("사용자를 찾을 수 없습니다.");
    return;
  }
  
  const posts = await getUserPosts(userId);
  
  console.log(\`\n사용자: \${user.name} (@\${user.username})\`);
  console.log(\`이메일: \${user.email}\`);
  console.log(\`\n게시글 (\${posts.length}개):\`);
  
  posts.slice(0, 3).forEach((post, index) => {
    console.log(\`\${index + 1}. \${post.title}\`);
  });
}

// 사용
await getUserWithPosts(1);
```

### OpenWeather API (날씨 정보)

OpenWeather API는 실시간 날씨 정보를 제공합니다.

**기본 정보:**
- URL: https://api.openweathermap.org
- 인증: API 키 필요 (무료 플랜 제공)
- 제한: 무료 플랜은 분당 60회

**API 키 발급:**
1. https://openweathermap.org 회원가입
2. API Keys 메뉴에서 키 복사
3. 코드에서 사용

**날씨 데이터 타입:**

```typescript
interface Weather {
  id: number;
  main: string;        // 날씨 (Clear, Rain, Snow 등)
  description: string; // 설명 (clear sky, light rain 등)
  icon: string;       // 아이콘 ID
}

interface MainWeather {
  temp: number;        // 온도 (켈빈)
  feels_like: number;  // 체감 온도
  temp_min: number;    // 최저 온도
  temp_max: number;    // 최고 온도
  pressure: number;    // 기압
  humidity: number;    // 습도
}

interface WeatherResponse {
  coord: {
    lon: number;
    lat: number;
  };
  weather: Weather[];
  main: MainWeather;
  name: string;        // 도시 이름
  dt: number;         // 시간 (Unix timestamp)
}
```

**실전 예제:**

```typescript
class WeatherAPI {
  private apiKey: string;
  private baseUrl: string = "https://api.openweathermap.org/data/2.5";
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  // 켈빈을 섭씨로 변환
  private kelvinToCelsius(kelvin: number): number {
    return Math.round(kelvin - 273.15);
  }
  
  // 도시 이름으로 날씨 가져오기
  async getWeatherByCity(city: string): Promise<WeatherResponse | null> {
    try {
      const url = \`\${this.baseUrl}/weather?q=\${city}&appid=\${this.apiKey}\`;
      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 404) {
          console.error("도시를 찾을 수 없습니다.");
        } else if (response.status === 401) {
          console.error("API 키가 유효하지 않습니다.");
        }
        return null;
      }
      
      const data: WeatherResponse = await response.json();
      return data;
    } catch (error) {
      console.error("날씨 정보를 가져올 수 없습니다:", error);
      return null;
    }
  }
  
  // 날씨 정보 출력
  printWeather(data: WeatherResponse): void {
    console.log(\`\n=== \${data.name} 날씨 ===\`);
    console.log(\`날씨: \${data.weather[0].main} (\${data.weather[0].description})\`);
    console.log(\`현재 온도: \${this.kelvinToCelsius(data.main.temp)}°C\`);
    console.log(\`체감 온도: \${this.kelvinToCelsius(data.main.feels_like)}°C\`);
    console.log(\`최저/최고: \${this.kelvinToCelsius(data.main.temp_min)}°C / \${this.kelvinToCelsius(data.main.temp_max)}°C\`);
    console.log(\`습도: \${data.main.humidity}%\`);
  }
}

// 사용 (API 키는 실제 키로 교체하세요)
const weatherAPI = new WeatherAPI("YOUR_API_KEY");
const weather = await weatherAPI.getWeatherByCity("Seoul");

if (weather) {
  weatherAPI.printWeather(weather);
}
```

---

## API 유틸리티 클래스 만들기

재사용 가능한 API 클라이언트 클래스를 만들어봅시다.

### 기본 API 클라이언트

```typescript
class ApiClient {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = {
      "Content-Type": "application/json"
    };
  }
  
  // 헤더 설정
  setHeader(key: string, value: string): void {
    this.defaultHeaders[key] = value;
  }
  
  // 인증 토큰 설정
  setAuthToken(token: string): void {
    this.setHeader("Authorization", \`Bearer \${token}\`);
  }
  
  // 기본 fetch 래퍼
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = \`\${this.baseUrl}\${endpoint}\`;
    
    const config: RequestInit = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers
      }
    };
    
    const response = await fetch(url, config);
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    return response.json();
  }
  
  // GET 요청
  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "GET" });
  }
  
  // POST 요청
  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: "POST",
      body: JSON.stringify(data)
    });
  }
  
  // PUT 요청
  async put<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: "PUT",
      body: JSON.stringify(data)
    });
  }
  
  // PATCH 요청
  async patch<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: "PATCH",
      body: JSON.stringify(data)
    });
  }
  
  // DELETE 요청
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }
}
```

**사용 예시:**

```typescript
// API 클라이언트 생성
const api = new ApiClient("https://jsonplaceholder.typicode.com");

// GET 요청
const posts = await api.get<Post[]>("/posts");
console.log(\`게시글 \${posts.length}개\`);

// POST 요청
const newPost = await api.post<Post>("/posts", {
  userId: 1,
  title: "새 게시글",
  body: "내용"
});
console.log("생성됨:", newPost);

// PATCH 요청
const updated = await api.patch<Post>(\`/posts/\${newPost.id}\`, {
  title: "수정된 제목"
});
console.log("수정됨:", updated);

// DELETE 요청
await api.delete(\`/posts/\${newPost.id}\`);
console.log("삭제 완료");
```

### 제네릭을 활용한 고급 API 클라이언트

```typescript
// API 응답 래퍼
interface ApiResponse<T> {
  success: boolean;
  data: T;
  error?: string;
}

// 로딩 상태를 포함한 응답
interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

class AdvancedApiClient<T = any> {
  private baseUrl: string;
  private state: ApiState<T>;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.state = {
      data: null,
      loading: false,
      error: null
    };
  }
  
  // 상태 가져오기
  getState(): ApiState<T> {
    return { ...this.state };
  }
  
  // 안전한 API 호출
  async fetchSafe(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T | null> {
    this.state.loading = true;
    this.state.error = null;
    
    try {
      const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, options);
      
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }
      
      const data: T = await response.json();
      this.state.data = data;
      this.state.loading = false;
      return data;
    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : "알 수 없는 에러";
      this.state.error = errorMessage;
      this.state.loading = false;
      return null;
    }
  }
}

// 사용 예시
const postApi = new AdvancedApiClient<Post[]>("https://jsonplaceholder.typicode.com");

console.log("로딩 중...");
const posts = await postApi.fetchSafe("/posts");

const state = postApi.getState();
console.log("로딩:", state.loading);
console.log("에러:", state.error);
console.log("데이터 개수:", state.data?.length);
```

### 인터셉터 패턴

요청 전후에 공통 로직을 실행하는 인터셉터를 구현해봅시다.

```typescript
type RequestInterceptor = (config: RequestInit) => RequestInit;
type ResponseInterceptor<T> = (data: T) => T;

class InterceptorApiClient {
  private baseUrl: string;
  private requestInterceptors: RequestInterceptor[] = [];
  private responseInterceptors: ResponseInterceptor<any>[] = [];
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  // 요청 인터셉터 추가
  addRequestInterceptor(interceptor: RequestInterceptor): void {
    this.requestInterceptors.push(interceptor);
  }
  
  // 응답 인터셉터 추가
  addResponseInterceptor<T>(interceptor: ResponseInterceptor<T>): void {
    this.responseInterceptors.push(interceptor);
  }
  
  // API 호출
  async fetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    // 요청 인터셉터 실행
    let config = options;
    for (const interceptor of this.requestInterceptors) {
      config = interceptor(config);
    }
    
    // API 호출
    const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, config);
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    let data: T = await response.json();
    
    // 응답 인터셉터 실행
    for (const interceptor of this.responseInterceptors) {
      data = interceptor(data);
    }
    
    return data;
  }
}

// 사용 예시
const api = new InterceptorApiClient("https://jsonplaceholder.typicode.com");

// 요청 전에 로그 출력
api.addRequestInterceptor((config) => {
  console.log("요청 전:", config);
  return config;
});

// 응답 후에 로그 출력
api.addResponseInterceptor((data) => {
  console.log("응답 받음:", data);
  return data;
});

// API 호출
const posts = await api.fetch<Post[]>("/posts");
```

### 로딩 상태 관리

API 호출 중 로딩 상태를 관리하는 패턴입니다.

```typescript
class LoadingManager {
  private loadingMap: Map<string, boolean> = new Map();
  
  // 로딩 시작
  startLoading(key: string): void {
    this.loadingMap.set(key, true);
  }
  
  // 로딩 종료
  stopLoading(key: string): void {
    this.loadingMap.set(key, false);
  }
  
  // 로딩 중인지 확인
  isLoading(key: string): boolean {
    return this.loadingMap.get(key) || false;
  }
  
  // 아무거라도 로딩 중인지
  isAnyLoading(): boolean {
    return Array.from(this.loadingMap.values()).some(loading => loading);
  }
}

class ApiClientWithLoading {
  private baseUrl: string;
  private loadingManager: LoadingManager;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.loadingManager = new LoadingManager();
  }
  
  // 로딩 상태 가져오기
  isLoading(key: string): boolean {
    return this.loadingManager.isLoading(key);
  }
  
  // API 호출 (로딩 관리 포함)
  async fetch<T>(
    endpoint: string,
    options: RequestInit = {},
    loadingKey?: string
  ): Promise<T | null> {
    const key = loadingKey || endpoint;
    
    try {
      this.loadingManager.startLoading(key);
      
      const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, options);
      
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }
      
      const data: T = await response.json();
      return data;
    } catch (error) {
      console.error("API 에러:", error);
      return null;
    } finally {
      this.loadingManager.stopLoading(key);
    }
  }
  
  // GET 요청
  async get<T>(endpoint: string, loadingKey?: string): Promise<T | null> {
    return this.fetch<T>(endpoint, { method: "GET" }, loadingKey);
  }
  
  // POST 요청
  async post<T>(
    endpoint: string,
    data: any,
    loadingKey?: string
  ): Promise<T | null> {
    return this.fetch<T>(
      endpoint,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      },
      loadingKey
    );
  }
}

// 사용 예시
const api = new ApiClientWithLoading("https://jsonplaceholder.typicode.com");

console.log("로딩 중:", api.isLoading("/posts")); // false

const posts = api.get<Post[]>("/posts", "posts-list");

console.log("로딩 중:", api.isLoading("posts-list")); // true

await posts;

console.log("로딩 중:", api.isLoading("posts-list")); // false
```

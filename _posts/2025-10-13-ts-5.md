---
title: "[TS] 기본 타입 시스템 - 2"
date: 2025-10-13 15:40:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS]
pin: true
math: true
mermaid: true
published: false
---

> **학습 목표**
> - TypeScript의 기본 타입들을 이해하고 사용할 수 있다
> - 배열과 튜플의 차이를 안다
> - 객체 타입을 정의할 수 있다
> - any, unknown, void, never의 용도를 이해한다
> - 유니온 타입과 리터럴 타입을 활용할 수 있다

---

## any와 unknown

TypeScript에서 타입을 모를 때 사용할 수 있는 두 가지 특별한 타입이 있습니다. 바로 `any`와 `unknown`입니다. 두 타입 모두 "어떤 타입이든 될 수 있다"는 의미지만, 안전성에서 큰 차이가 있습니다.

### any 타입의 위험성

`any`는 "모든 타입을 허용한다"는 의미입니다. TypeScript의 타입 체크를 완전히 끄는 것과 같아서, JavaScript처럼 자유롭게 사용할 수 있지만 그만큼 위험합니다.

```typescript
let data: any;

data = "문자열";        // OK
data = 123;            // OK
data = true;           // OK
data = { name: "홍길동" };  // OK
data = [1, 2, 3];      // OK

// 어떤 타입으로든 사용 가능 (위험!)
console.log(data.toUpperCase());  // 에러가 나지 않지만 런타임에 문제 발생 가능
console.log(data.length);         // 에러가 나지 않지만 런타임에 문제 발생 가능
```

`any`를 사용하면 TypeScript의 타입 체크를 받지 않기 때문에, 실행 전에 에러를 발견할 수 없습니다. 이는 TypeScript를 사용하는 주요 이유를 포기하는 것과 같습니다.

```typescript
function processData(data: any) {
  // any 타입이므로 모든 메서드 호출이 허용됨
  data.toUpperCase();     // 컴파일 에러 없음
  data.push(1);           // 컴파일 에러 없음
  data.nonExistent();     // 컴파일 에러 없음
  
  // 하지만 런타임에 에러 발생 가능!
}

processData(123);  // 실행 시 에러!
```

**any를 사용해야 하는 경우:**

1. JavaScript 코드를 TypeScript로 점진적으로 마이그레이션할 때
2. 외부 라이브러리의 타입 정의가 없을 때
3. 정말로 어떤 타입이든 받아야 하는 특수한 경우

하지만 가능하면 `any` 사용을 최소화하고, 더 구체적인 타입을 사용하는 것이 좋습니다.

### unknown 타입 사용하기

`unknown`은 `any`와 비슷하지만 훨씬 더 안전합니다. `unknown` 타입의 값은 사용하기 전에 반드시 타입을 확인해야 합니다.

```typescript
let data: unknown;

data = "문자열";        // ✅ OK
data = 123;            // ✅ OK
data = true;           // ✅ OK

// 하지만 바로 사용할 수 없음!
console.log(data.toUpperCase());  // ❌ 에러! unknown 타입은 직접 사용 불가
```

`unknown` 타입의 값을 사용하려면 먼저 타입을 확인해야 합니다. 이를 통해 안전하게 코드를 작성할 수 있습니다.

```typescript
let data: unknown = "Hello, TypeScript!";

// 타입 확인 후 사용
if (typeof data === "string") {
  console.log(data.toUpperCase());  // ✅ OK (string으로 확인됨)
}

if (typeof data === "number") {
  console.log(data.toFixed(2));     // 실행되지 않음
}
```

**실전 예제:**

```typescript
// 사용자 입력 처리 (입력값의 타입을 알 수 없음)
function processUserInput(input: unknown): void {
  // input이 문자열인지 확인
  if (typeof input === "string") {
    console.log(\`입력된 문자열: \${input}\`);
    console.log(\`길이: \${input.length}\`);
    return;
  }
  
  // input이 숫자인지 확인
  if (typeof input === "number") {
    console.log(\`입력된 숫자: \${input}\`);
    console.log(\`2배: \${input * 2}\`);
    return;
  }
  
  // input이 배열인지 확인
  if (Array.isArray(input)) {
    console.log(\`입력된 배열: \${input}\`);
    console.log(\`길이: \${input.length}\`);
    return;
  }
  
  console.log("지원하지 않는 타입입니다");
}

// 다양한 입력 처리 가능
processUserInput("Hello");          // 입력된 문자열: Hello
processUserInput(42);               // 입력된 숫자: 42
processUserInput([1, 2, 3]);        // 입력된 배열: 1,2,3
processUserInput(true);             // 지원하지 않는 타입입니다
```

**파일 읽기 예제:**

```typescript
// 파일에서 읽은 데이터 처리 (타입을 미리 알 수 없음)
function processFileData(data: unknown): string {
  // 데이터가 객체인지 확인
  if (typeof data === "object" && data !== null) {
    // name 속성이 있는지 확인
    if ("name" in data && "age" in data) {
      const user = data as { name: string; age: number };
      return \`이름: \${user.name}, 나이: \${user.age}세\`;
    }
  }
  
  // 데이터가 문자열인지 확인
  if (typeof data === "string") {
    return \`텍스트 데이터: \${data}\`;
  }
  
  return "알 수 없는 데이터 형식입니다";
}

// 다양한 형식의 데이터 처리
console.log(processFileData({ name: "홍길동", age: 25 }));
// 출력: 이름: 홍길동, 나이: 25세

console.log(processFileData("설정 파일 내용"));
// 출력: 텍스트 데이터: 설정 파일 내용

console.log(processFileData(12345));
// 출력: 알 수 없는 데이터 형식입니다
```

### 타입 가드 (Type Guard)

타입 가드는 `unknown` 타입의 값을 안전하게 사용하기 위한 방법입니다. 조건문을 통해 타입을 좁혀나가는 것을 말합니다.

```typescript
function processValue(value: unknown) {
  // typeof 타입 가드
  if (typeof value === "string") {
    console.log(value.toUpperCase());  // string으로 좁혀짐
  }
  
  if (typeof value === "number") {
    console.log(value.toFixed(2));     // number로 좁혀짐
  }
  
  if (typeof value === "boolean") {
    console.log(value ? "참" : "거짓");  // boolean으로 좁혀짐
  }
  
  // Array.isArray 타입 가드
  if (Array.isArray(value)) {
    console.log(\`배열 길이: \${value.length}\`);  // 배열로 좁혀짐
  }
}

processValue("hello");      // HELLO
processValue(123);          // 123.00
processValue(true);         // 참
processValue([1, 2, 3]);    // 배열 길이: 3
```

**외부 라이브러리 데이터 처리:**

```typescript
// 외부 라이브러리에서 가져온 데이터 (타입을 정확히 알 수 없음)
function handleExternalData(data: unknown): void {
  // 데이터가 배열인지 확인
  if (Array.isArray(data)) {
    console.log(\`\${data.length}개의 항목이 있습니다\`);
    
    // 각 항목이 문자열인지 확인
    const allStrings = data.every(item => typeof item === "string");
    if (allStrings) {
      console.log("모든 항목이 문자열입니다");
      data.forEach(item => console.log(item.toUpperCase()));
    }
    return;
  }
  
  // 데이터가 객체인지 확인
  if (typeof data === "object" && data !== null) {
    console.log("객체 데이터를 받았습니다");
    console.log(JSON.stringify(data, null, 2));
    return;
  }
  
  console.log("단순 값:", data);
}

// 테스트
handleExternalData(["apple", "banana", "orange"]);
handleExternalData({ title: "제목", content: "내용" });
handleExternalData(42);
```

**any vs unknown 비교:**

| 특징 | any | unknown |
|------|-----|---------|
| **타입 할당** | 모든 타입 허용 | 모든 타입 허용 |
| **사용 전 체크** | 불필요 (위험) | 필수 (안전) |
| **타입 안정성** | 없음 | 있음 |
| **권장 여부** | 피하기 | any 대신 사용 |

**권장사항:**

`any`를 사용하고 싶은 유혹이 들 때는 `unknown`을 사용하세요. 조금 더 코드를 작성해야 하지만, 훨씬 안전한 코드를 만들 수 있습니다.

```typescript
// 나쁜 예
function badExample(data: any) {
  return data.someMethod();  // 런타임 에러 가능성
}

// 좋은 예
function goodExample(data: unknown) {
  if (typeof data === "object" && data !== null && "someMethod" in data) {
    return (data as any).someMethod();  // 확인 후 사용
  }
  throw new Error("Invalid data");
}
```

---

## void, never, undefined

이 세 가지 타입은 "값이 없음"과 관련이 있지만, 각각 다른 의미를 가집니다. 어떤 상황에서 어떤 타입을 사용해야 하는지 이해하는 것이 중요합니다.

### void: 반환값이 없는 함수

`void`는 함수가 아무것도 반환하지 않을 때 사용하는 타입입니다. `console.log()`처럼 어떤 작업만 수행하고 값을 반환하지 않는 함수에 사용합니다.

```typescript
// 반환값이 없는 함수
function sayHello(name: string): void {
  console.log(\`안녕하세요, \${name}님!\`);
  // return이 없거나 return만 있음
}

function printNumbers(numbers: number[]): void {
  for (const num of numbers) {
    console.log(num);
  }
  return;  // return만 있어도 OK
}

sayHello("홍길동");        // 안녕하세요, 홍길동님!
printNumbers([1, 2, 3]);  // 1, 2, 3
```

`void` 함수에서 값을 반환하려고 하면 에러가 발생합니다.

```typescript
function greet(name: string): void {
  return \`안녕하세요, \${name}님!\`;  // 에러! void는 값을 반환할 수 없음
}

// 올바른 코드
function greet2(name: string): string {  // 반환 타입을 string으로 변경
  return \`안녕하세요, \${name}님!\`;     // ✅ OK
}
```

**실전 예제:**

```typescript
// 로그를 기록하는 함수 (반환값 없음)
function logMessage(message: string): void {
  const timestamp = new Date().toISOString();
  console.log(\`[\${timestamp}] \${message}\`);
}

// 배열을 정렬하는 함수 (원본 배열 수정, 반환값 없음)
function sortArray(arr: number[]): void {
  arr.sort((a, b) => a - b);
}

const numbers = [3, 1, 4, 1, 5];
sortArray(numbers);
console.log(numbers);  // [1, 1, 3, 4, 5]
```

### never: 절대 발생하지 않는 타입

`never`는 "절대 발생할 수 없는" 타입입니다. 함수가 절대 정상적으로 끝나지 않을 때 사용합니다.

**함수가 never를 반환하는 경우:**

1. 항상 에러를 던지는 함수

```typescript
function throwError(message: string): never {
  throw new Error(message);
  // 이 함수는 에러를 던지고 끝나므로 절대 반환하지 않음
}

throwError("치명적인 오류 발생!");  // 프로그램이 중단됨
```

2. 무한 루프를 도는 함수

```typescript
function infiniteLoop(): never {
  while (true) {
    console.log("무한 실행 중...");
  }
  // 이 함수는 절대 끝나지 않으므로 반환하지 않음
}
```

**never의 실전 활용:**

```typescript
// 타입 체크에서 모든 경우를 처리했는지 확인
type Shape = "circle" | "square" | "triangle";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 * 10;
    case "square":
      return 10 * 10;
    case "triangle":
      return (10 * 10) / 2;
    default:
      // 모든 경우를 처리했다면 여기는 절대 실행되지 않음
      const exhaustive: never = shape;
      throw new Error(\`처리되지 않은 shape: \${exhaustive}\`);
  }
}
```

만약 `Shape`에 새로운 타입을 추가하고 `getArea` 함수에서 처리하지 않으면, TypeScript가 컴파일 에러를 발생시켜 빠뜨린 경우를 알려줍니다.

### void vs never vs undefined

이 세 가지 타입은 헷갈리기 쉬우므로 명확히 구분해야 합니다.

```typescript
// void: 반환값이 없음 (정상적으로 종료됨)
function logMessage(): void {
  console.log("메시지");
  // 함수가 정상 종료되지만 반환값은 없음
}

// never: 절대 반환하지 않음 (정상적으로 종료되지 않음)
function throwError(): never {
  throw new Error("에러!");
  // 함수가 에러를 던지고 끝남
}

// undefined: undefined 값을 반환함
function returnUndefined(): undefined {
  return undefined;
  // 명시적으로 undefined를 반환
}
```

| 타입 | 의미 | 함수 종료 | 예시 |
|------|------|----------|------|
| **void** | 반환값 없음 | ✅ 정상 종료 | console.log |
| **never** | 절대 반환 안 함 | ❌ 비정상 종료 | throw Error |
| **undefined** | undefined 반환 | ✅ 정상 종료 | return undefined |

**실전 예제:**

```typescript
// void: 로그만 출력하고 끝
function log(message: string): void {
  console.log(message);
}

// never: 에러 처리 함수
function handleFatalError(error: Error): never {
  console.error("치명적 오류:", error);
  process.exit(1);  // 프로그램 종료
}

// undefined: 값을 찾지 못했을 때
function findUser(id: number): string | undefined {
  if (id === 1) {
    return "홍길동";
  }
  return undefined;  // 사용자를 찾지 못함
}
```

---

## 리터럴 타입

리터럴 타입은 특정한 값 자체를 타입으로 사용하는 것입니다. 변수가 가질 수 있는 값을 정확히 제한할 수 있어 매우 유용합니다.

### 문자열 리터럴 타입

특정 문자열만 허용하는 타입을 만들 수 있습니다.

```typescript
// "success"라는 문자열만 허용
let status: "success";

status = "success";  // ✅ OK
status = "error";    // ❌ 에러! "success"만 허용됨
status = "pending";  // ❌ 에러!
```

여러 문자열 중 하나만 허용하도록 유니온 타입과 함께 사용하면 더 유용합니다.

```typescript
// 3가지 상태 중 하나만 허용
let status: "success" | "error" | "pending";

status = "success";  // ✅ OK
status = "error";    // ✅ OK
status = "pending";  // ✅ OK
status = "loading";  // ❌ 에러! 정의되지 않은 값
```

**실전 예제:**

```typescript
// 방향을 나타내는 타입
type Direction = "up" | "down" | "left" | "right";

function move(direction: Direction): void {
  console.log(\`\${direction} 방향으로 이동합니다.\`);
}

move("up");      // ✅ OK
move("down");    // ✅ OK
move("forward"); // ❌ 에러! Direction 타입이 아님

// API 메서드 타입
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

function request(url: string, method: HttpMethod): void {
  console.log(\`\${method} \${url}\`);
}

request("/api/users", "GET");   // ✅ OK
request("/api/users", "PATCH"); // ❌ 에러!
```

### 숫자 리터럴 타입

특정 숫자만 허용하는 타입도 만들 수 있습니다.

```typescript
// 1, 2, 3 중 하나만 허용
let level: 1 | 2 | 3;

level = 1;  // ✅ OK
level = 2;  // ✅ OK
level = 3;  // ✅ OK
level = 4;  // ❌ 에러!
```

**실전 예제:**

```typescript
// HTTP 상태 코드
type HttpStatus = 200 | 400 | 404 | 500;

function handleResponse(status: HttpStatus): void {
  switch (status) {
    case 200:
      console.log("성공");
      break;
    case 400:
      console.log("잘못된 요청");
      break;
    case 404:
      console.log("찾을 수 없음");
      break;
    case 500:
      console.log("서버 오류");
      break;
  }
}

handleResponse(200);  // 성공
handleResponse(403);  // ❌ 에러!

// 주사위 눈
type DiceNumber = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceNumber {
  return (Math.floor(Math.random() * 6) + 1) as DiceNumber;
}

const result: DiceNumber = rollDice();
console.log(\`주사위: \${result}\`);
```

### 불린 리터럴 타입

`true` 또는 `false` 자체를 타입으로 사용할 수 있습니다. 실제로는 잘 사용하지 않지만, 타입 시스템을 이해하는 데 도움이 됩니다.

```typescript
let isTrue: true;

isTrue = true;   // ✅ OK
isTrue = false;  // ❌ 에러! true만 허용됨
```

### 리터럴 타입의 활용

리터럴 타입은 실수를 방지하고 코드의 의도를 명확하게 만듭니다.

```typescript
// 나쁜 예: 아무 문자열이나 허용
function setAlignment(align: string) {
  // 오타가 있어도 에러가 발생하지 않음
}

setAlignment("left");
setAlignment("leftt");  // 오타! 하지만 에러 없음

// 좋은 예: 특정 값만 허용
type Alignment = "left" | "center" | "right";

function setAlignment2(align: Alignment) {
  console.log(\`정렬: \${align}\`);
}

setAlignment2("left");    // ✅ OK
setAlignment2("leftt");   // ❌ 에러! 컴파일 시점에 발견
setAlignment2("center");  // ✅ OK
```

**실전 예제: 게임 캐릭터**

```typescript
type CharacterClass = "warrior" | "mage" | "archer";
type CharacterLevel = 1 | 2 | 3 | 4 | 5;

interface Character {
  name: string;
  class: CharacterClass;
  level: CharacterLevel;
}

const hero: Character = {
  name: "용사",
  class: "warrior",
  level: 3
};

function levelUp(character: Character): void {
  if (character.level < 5) {
    character.level = (character.level + 1) as CharacterLevel;
    console.log(\`\${character.name}이(가) 레벨 \${character.level}(으)로 올랐습니다!\`);
  }
}

levelUp(hero);  // 용사이(가) 레벨 4(으)로 올랐습니다!
```

---

## 유니온과 교차 타입

TypeScript에서는 여러 타입을 조합하여 새로운 타입을 만들 수 있습니다. 유니온 타입은 "또는(OR)"의 의미이고, 교차 타입은 "그리고(AND)"의 의미입니다.

### 유니온 타입 (Union Types)

유니온 타입은 여러 타입 중 하나가 될 수 있는 타입입니다. 파이프(`|`) 기호로 타입을 연결합니다.

```typescript
// string 또는 number
let id: string | number;

id = "user-123";  // ✅ OK
id = 123;         // ✅ OK
id = true;        // ❌ 에러! boolean은 허용되지 않음
```

유니온 타입은 변수가 여러 타입의 값을 가질 수 있을 때 유용합니다.

```typescript
// 함수 매개변수에 유니온 타입 사용
function printId(id: string | number): void {
  console.log(\`ID: \${id}\`);
}

printId("user-123");  // ID: user-123
printId(456);         // ID: 456

// 배열이나 null을 반환하는 함수
function findUser(id: number): string | null {
  if (id === 1) {
    return "홍길동";
  }
  return null;  // 사용자를 찾지 못함
}

const user = findUser(1);
console.log(user);  // "홍길동"

const user2 = findUser(999);
console.log(user2);  // null
```

**유니온 타입 사용 시 주의점:**

유니온 타입의 값을 사용할 때는 모든 타입에 공통으로 존재하는 속성만 바로 사용할 수 있습니다.

```typescript
function processValue(value: string | number): void {
  console.log(value);  // ✅ OK (모든 타입에 공통)
  
  // ❌ 에러! toUpperCase는 string에만 있음
  // console.log(value.toUpperCase());
  
  // ❌ 에러! toFixed는 number에만 있음
  // console.log(value.toFixed(2));
}
```

특정 타입의 메서드를 사용하려면 타입을 확인해야 합니다.

```typescript
function processValue(value: string | number): void {
  if (typeof value === "string") {
    console.log(value.toUpperCase());  // ✅ OK (string으로 확인됨)
  }
  
  if (typeof value === "number") {
    console.log(value.toFixed(2));  // ✅ OK (number로 확인됨)
  }
}

processValue("hello");  // HELLO
processValue(123.456);  // 123.46
```

**실전 예제:**

```typescript
// API 응답 타입
type ApiResponse = 
  | { success: true; data: string[] }
  | { success: false; error: string };

function handleResponse(response: ApiResponse): void {
  if (response.success) {
    console.log("데이터:", response.data);
  } else {
    console.log("에러:", response.error);
  }
}

// 성공 응답
handleResponse({
  success: true,
  data: ["item1", "item2"]
});

// 실패 응답
handleResponse({
  success: false,
  error: "서버 오류"
});
```

### 교차 타입 (Intersection Types)

교차 타입은 여러 타입을 모두 만족하는 타입입니다. 앰퍼샌드(`&`) 기호로 타입을 연결합니다.

```typescript
// 두 타입을 모두 만족해야 함
type Person = {
  name: string;
  age: number;
};

type Employee = {
  company: string;
  position: string;
};

// Person과 Employee의 모든 속성을 가져야 함
type Worker = Person & Employee;

const worker: Worker = {
  name: "홍길동",
  age: 25,
  company: "ABC Corp",
  position: "개발자"
};

console.log(\`\${worker.name}은 \${worker.company}의 \${worker.position}입니다.\`);
```

교차 타입은 기존 타입들을 합쳐서 새로운 타입을 만들 때 유용합니다.

```typescript
// 기본 정보
type BasicInfo = {
  name: string;
  email: string;
};

// 추가 정보
type DetailInfo = {
  age: number;
  address: string;
};

// 기본 + 추가 정보
type UserInfo = BasicInfo & DetailInfo;

const user: UserInfo = {
  name: "홍길동",
  email: "hong@example.com",
  age: 25,
  address: "서울"
};
```

**실전 예제:**

```typescript
// 기본 상품 정보
type Product = {
  id: number;
  name: string;
  price: number;
};

// 재고 정보
type Stock = {
  quantity: number;
  warehouse: string;
};

// 할인 정보
type Discount = {
  discountRate: number;
  validUntil: Date;
};

// 모든 정보를 포함한 상품
type ProductWithAll = Product & Stock & Discount;

const specialProduct: ProductWithAll = {
  id: 1,
  name: "노트북",
  price: 1000000,
  quantity: 10,
  warehouse: "서울 창고",
  discountRate: 0.1,
  validUntil: new Date("2024-12-31")
};
```

### 타입 좁히기 (Type Narrowing)

유니온 타입을 사용할 때는 타입을 좁혀가며 안전하게 사용해야 합니다.

**typeof를 사용한 타입 좁히기:**

```typescript
function format(value: string | number): string {
  if (typeof value === "string") {
    return value.toUpperCase();  // string으로 좁혀짐
  }
  
  if (typeof value === "number") {
    return value.toFixed(2);  // number로 좁혀짐
  }
  
  return "";  // 여기는 실행되지 않지만 TypeScript를 위해 필요
}

console.log(format("hello"));  // HELLO
console.log(format(123.456));  // 123.46
```

**in 연산자를 사용한 타입 좁히기:**

```typescript
type Dog = {
  name: string;
  bark: () => void;
};

type Cat = {
  name: string;
  meow: () => void;
};

function makeSound(animal: Dog | Cat): void {
  if ("bark" in animal) {
    animal.bark();  // Dog로 좁혀짐
  } else {
    animal.meow();  // Cat으로 좁혀짐
  }
}

const dog: Dog = {
  name: "멍멍이",
  bark: () => console.log("멍멍!")
};

const cat: Cat = {
  name: "야옹이",
  meow: () => console.log("야옹~")
};

makeSound(dog);  // 멍멍!
makeSound(cat);  // 야옹~
```

**판별 유니온 (Discriminated Unions):**

공통 속성을 사용하여 타입을 구분하는 패턴입니다. 이 패턴은 실전에서 매우 자주 사용됩니다.

```typescript
// 각 타입에 kind라는 공통 속성이 있음
type Circle = {
  kind: "circle";
  radius: number;
};

type Rectangle = {
  kind: "rectangle";
  width: number;
  height: number;
};

type Triangle = {
  kind: "triangle";
  base: number;
  height: number;
};

type Shape = Circle | Rectangle | Triangle;

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rectangle":
      return shape.width * shape.height;
    case "triangle":
      return (shape.base * shape.height) / 2;
  }
}

const circle: Circle = { kind: "circle", radius: 5 };
const rectangle: Rectangle = { kind: "rectangle", width: 10, height: 20 };
const triangle: Triangle = { kind: "triangle", base: 10, height: 15 };

console.log(\`원의 넓이: \${calculateArea(circle).toFixed(2)}\`);        // 78.54
console.log(\`직사각형의 넓이: \${calculateArea(rectangle)}\`);         // 200
console.log(\`삼각형의 넓이: \${calculateArea(triangle)}\`);            // 75
```

판별 유니온 패턴은 `kind` 같은 공통 속성으로 타입을 구분하므로, TypeScript가 각 case에서 정확한 타입을 추론할 수 있습니다. 이 패턴은 API 응답, 상태 관리, 이벤트 처리 등에서 매우 유용합니다.

---

---
title: "[TS] 함수 타입 시스템 - 1"
date: 2025-10-14 10:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, ts함수]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 함수의 매개변수와 반환 타입을 지정할 수 있다
> - 선택적 매개변수와 기본 매개변수를 사용할 수 있다
> - 함수 오버로딩을 이해하고 활용할 수 있다
> - 콜백 함수와 고차 함수에 타입을 지정할 수 있다

---

## 함수 타입 기초

함수는 프로그래밍에서 가장 중요한 구성 요소 중 하나입니다. 

TypeScript에서는 함수가 어떤 타입의 값을 받고, 어떤 타입의 값을 반환하는지 명확히 정의할 수 있습니다. 이를 통해 함수를 잘못 사용하는 실수를 미리 방지할 수 있습니다.

### 매개변수 타입 지정

함수의 매개변수에 타입을 지정하면, 잘못된 타입의 값이 전달되는 것을 방지할 수 있습니다.

```typescript
// 매개변수에 타입 지정
function greet(name: string): void {
  console.log(\`안녕하세요, \${name}님!\`);
}

greet("홍길동");    // ✅ OK
greet(123);        // ❌ 에러! number는 string에 할당 불가
greet(true);       // ❌ 에러! boolean은 string에 할당 불가
```

매개변수가 여러 개인 경우, 각 매개변수마다 타입을 지정해야 합니다.

```typescript
// 여러 매개변수에 타입 지정
function add(a: number, b: number): void {
  console.log(\`결과: \${a + b}\`);
}

add(10, 20);      // ✅ OK
add(10, "20");    // ❌ 에러! 두 번째 매개변수는 number여야 함
add("10", "20");  // ❌ 에러! 모든 매개변수가 number여야 함
```

**실전 예제:**

```typescript
// 사용자 정보 출력 함수
function printUserInfo(name: string, age: number, city: string): void {
  console.log("=== 사용자 정보 ===");
  console.log(\`이름: \${name}\`);
  console.log(\`나이: \${age}세\`);
  console.log(\`거주지: \${city}\`);
}

printUserInfo("홍길동", 25, "서울");
// 출력:
// === 사용자 정보 ===
// 이름: 홍길동
// 나이: 25세
// 거주지: 서울

// 계산기 함수
function calculate(operation: string, a: number, b: number): void {
  switch (operation) {
    case "add":
      console.log(\`\${a} + \${b} = \${a + b}\`);
      break;
    case "subtract":
      console.log(\`\${a} - \${b} = \${a - b}\`);
      break;
    case "multiply":
      console.log(\`\${a} × \${b} = \${a * b}\`);
      break;
    case "divide":
      console.log(\`\${a} ÷ \${b} = \${a / b}\`);
      break;
  }
}

calculate("add", 10, 5);       // 10 + 5 = 15
calculate("multiply", 10, 5);  // 10 × 5 = 50
```

### 반환 타입 지정

함수가 어떤 타입의 값을 반환하는지 명시할 수 있습니다. 반환 타입은 매개변수 괄호 뒤에 콜론(`:`)과 함께 작성합니다.

```typescript
// 반환 타입 지정
function add(a: number, b: number): number {
  return a + b;
}

const result: number = add(10, 20);
console.log(result);  // 30
```

반환 타입을 지정하면, 함수가 잘못된 타입의 값을 반환하는 것을 방지할 수 있습니다.

```typescript
function getGreeting(name: string): string {
  return \`안녕하세요, \${name}님!\`;  // ✅ OK
  // return 123;  // ❌ 에러! number는 string이 아님
}

function isAdult(age: number): boolean {
  return age >= 18;  // ✅ OK
  // return "yes";  // ❌ 에러! string은 boolean이 아님
}

console.log(getGreeting("홍길동"));  // 안녕하세요, 홍길동님!
console.log(isAdult(25));           // true
console.log(isAdult(15));           // false
```

**실전 예제:**

```typescript
// 할인 가격 계산
function calculateDiscountPrice(price: number, discountRate: number): number {
  return price * (1 - discountRate);
}

const originalPrice = 10000;
const finalPrice = calculateDiscountPrice(originalPrice, 0.2);  // 20% 할인
console.log(\`원가: \${originalPrice}원\`);
console.log(\`할인가: \${finalPrice}원\`);
// 출력:
// 원가: 10000원
// 할인가: 8000원

// 학점 계산
function getGrade(score: number): string {
  if (score >= 90) return "A";
  if (score >= 80) return "B";
  if (score >= 70) return "C";
  if (score >= 60) return "D";
  return "F";
}

console.log(\`85점: \${getGrade(85)}학점\`);  // 85점: B학점
console.log(\`92점: \${getGrade(92)}학점\`);  // 92점: A학점
```

```typescript
// 배열의 합계 계산
function sum(numbers: number[]): number {
  let total = 0;
  for (const num of numbers) {
    total += num;
  }
  return total;
}

const scores = [85, 90, 78, 95];
const total = sum(scores);
const average = total / scores.length;

console.log(\`총점: \${total}\`);
console.log(\`평균: \${average.toFixed(2)}\`);
// 출력:
// 총점: 348
// 평균: 87.00
```

### 함수 표현식의 타입

함수 표현식이나 화살표 함수에도 타입을 지정할 수 있습니다.

```typescript
// 함수 표현식
const multiply = function(a: number, b: number): number {
  return a * b;
};

// 화살표 함수
const divide = (a: number, b: number): number => {
  return a / b;
};

// 화살표 함수 (간단한 형태)
const square = (n: number): number => n * n;

console.log(multiply(10, 5));  // 50
console.log(divide(10, 5));    // 2
console.log(square(5));        // 25
```

함수 자체의 타입을 변수에 지정할 수도 있습니다. 이는 콜백 함수를 받을 때 유용합니다.

```typescript
// 함수 타입 정의
let operation: (a: number, b: number) => number;

// 덧셈 함수 할당
operation = (a: number, b: number): number => {
  return a + b;
};
console.log(operation(10, 5));  // 15

// 곱셈 함수로 변경
operation = (a: number, b: number): number => {
  return a * b;
};
console.log(operation(10, 5));  // 50
```

**실전 예제:**

```typescript
// 배열 필터링 함수
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 짝수만 필터링
const filterEven = (arr: number[]): number[] => {
  return arr.filter(n => n % 2 === 0);
};

// 홀수만 필터링
const filterOdd = (arr: number[]): number[] => {
  return arr.filter(n => n % 2 !== 0);
};

// 특정 값보다 큰 수만 필터링
const filterGreaterThan = (arr: number[], threshold: number): number[] => {
  return arr.filter(n => n > threshold);
};

console.log("짝수:", filterEven(numbers));              // [2, 4, 6, 8, 10]
console.log("홀수:", filterOdd(numbers));               // [1, 3, 5, 7, 9]
console.log("5보다 큰 수:", filterGreaterThan(numbers, 5));  // [6, 7, 8, 9, 10]
```

---

## 선택적 매개변수와 기본 매개변수

때로는 함수의 일부 매개변수가 선택적이거나, 기본값을 가져야 할 때가 있습니다. TypeScript는 이런 상황을 안전하게 처리할 수 있는 방법을 제공합니다.

### 선택적 매개변수 (Optional Parameters)

모든 매개변수가 필수는 아닐 때가 있습니다. 매개변수 이름 뒤에 물음표(`?`)를 붙이면 선택적 매개변수가 됩니다. 선택적 매개변수는 값을 전달하지 않아도 에러가 발생하지 않으며, 전달하지 않으면 `undefined`가 됩니다.

```typescript
// middleName은 선택적 매개변수
function createFullName(firstName: string, lastName: string, middleName?: string): string {
  if (middleName) {
    return \`\${firstName} \${middleName} \${lastName}\`;
  }
  return \`\${firstName} \${lastName}\`;
}

console.log(createFullName("길동", "홍"));           // 길동 홍
console.log(createFullName("철수", "김", "영"));     // 철수 영 김
```

선택적 매개변수는 반드시 필수 매개변수 뒤에 와야 합니다. 순서를 바꾸면 에러가 발생합니다.

```typescript
// ❌ 잘못된 순서
function wrongOrder(optional?: string, required: string): void {
  // 에러! 선택적 매개변수는 필수 매개변수 뒤에 와야 함
}

// ✅ 올바른 순서
function correctOrder(required: string, optional?: string): void {
  console.log(required, optional);
}
```

**실전 예제:**

```typescript
// 사용자 정보 출력 (이메일은 선택적)
function printUser(name: string, age: number, email?: string): void {
  console.log(\`이름: \${name}\`);
  console.log(\`나이: \${age}세\`);
  
  if (email) {
    console.log(\`이메일: \${email}\`);
  } else {
    console.log("이메일: 미등록");
  }
}

printUser("홍길동", 25);                           // 이메일: 미등록
printUser("김철수", 30, "kim@example.com");        // 이메일: kim@example.com

// 상품 정보 생성 (할인율은 선택적)
function createProduct(name: string, price: number, discount?: number): object {
  const finalPrice = discount ? price * (1 - discount) : price;
  
  return {
    name,
    originalPrice: price,
    finalPrice,
    hasDiscount: discount !== undefined
  };
}

console.log(createProduct("노트북", 1000000));
// { name: '노트북', originalPrice: 1000000, finalPrice: 1000000, hasDiscount: false }

console.log(createProduct("마우스", 30000, 0.1));
// { name: '마우스', originalPrice: 30000, finalPrice: 27000, hasDiscount: true }
```

### 기본 매개변수 (Default Parameters)

선택적 매개변수와 비슷하지만, 값을 전달하지 않았을 때 `undefined` 대신 미리 정해둔 기본값을 사용하도록 할 수 있습니다.

```typescript
// count의 기본값은 1
function greet(name: string, count: number = 1): void {
  for (let i = 0; i < count; i++) {
    console.log(\`안녕하세요, \${name}님!\`);
  }
}

greet("홍길동");      // 1번 인사
greet("김철수", 3);   // 3번 인사
```

기본 매개변수를 사용하면 타입을 명시하지 않아도 TypeScript가 자동으로 추론합니다.

```typescript
// TypeScript가 count를 number로 추론
function multiply(a: number, b: number, times = 1) {
  let result = a * b;
  for (let i = 1; i < times; i++) {
    result *= (a * b);
  }
  return result;
}

console.log(multiply(2, 3));     // 6 (2 * 3)
console.log(multiply(2, 3, 2));  // 36 (2 * 3 * 2 * 3)
```

**실전 예제:**

```typescript
// 할인 가격 계산 (할인율 기본값 0)
function calculatePrice(price: number, quantity: number = 1, discount: number = 0): number {
  const subtotal = price * quantity;
  return subtotal * (1 - discount);
}

console.log(\`가격: \${calculatePrice(10000)}원\`);
// 가격: 10000원 (수량 1, 할인 없음)

console.log(\`가격: \${calculatePrice(10000, 3)}원\`);
// 가격: 30000원 (수량 3, 할인 없음)

console.log(\`가격: \${calculatePrice(10000, 3, 0.1)}원\`);
// 가격: 27000원 (수량 3, 10% 할인)

// 배열 생성 (기본값으로 빈 배열)
function createArray(size: number, initialValue: number = 0): number[] {
  const arr: number[] = [];
  for (let i = 0; i < size; i++) {
    arr.push(initialValue);
  }
  return arr;
}

console.log(createArray(5));        // [0, 0, 0, 0, 0]
console.log(createArray(3, 1));     // [1, 1, 1]
console.log(createArray(4, 100));   // [100, 100, 100, 100]

// 로그 출력 (로그 레벨 기본값 "INFO")
function log(message: string, level: string = "INFO"): void {
  const timestamp = new Date().toLocaleTimeString();
  console.log(\`[\${timestamp}] [\${level}] \${message}\`);
}

log("프로그램이 시작되었습니다");
log("데이터 로딩 중...");
log("에러가 발생했습니다", "ERROR");
log("경고: 메모리 부족", "WARN");
```

### 나머지 매개변수 (Rest Parameters)

개수가 정해지지 않은 매개변수를 받아야 할 때가 있습니다. 나머지 매개변수를 사용하면 여러 개의 인자를 배열로 받을 수 있습니다.

```typescript
// 모든 숫자의 합 계산
function sum(...numbers: number[]): number {
  let total = 0;
  for (const num of numbers) {
    total += num;
  }
  return total;
}

console.log(sum(1, 2, 3));           // 6
console.log(sum(10, 20, 30, 40));    // 100
console.log(sum(5));                 // 5
console.log(sum());                  // 0 (인자 없음)
```

나머지 매개변수는 반드시 마지막 매개변수여야 하며, 하나만 사용할 수 있습니다.

```typescript
// 첫 번째 인자는 메시지, 나머지는 숫자들
function logWithSum(message: string, ...numbers: number[]): void {
  const total = numbers.reduce((sum, num) => sum + num, 0);
  console.log(\`\${message}: \${total}\`);
}

logWithSum("합계", 1, 2, 3, 4, 5);        // 합계: 15
logWithSum("결과", 10, 20, 30);           // 결과: 60
```

**실전 예제:**

```typescript
// 여러 학생의 평균 점수 계산
function calculateAverage(...scores: number[]): number {
  if (scores.length === 0) return 0;
  const total = scores.reduce((sum, score) => sum + score, 0);
  return total / scores.length;
}

console.log(\`평균: \${calculateAverage(85, 90, 78, 95).toFixed(2)}\`);
// 평균: 87.00

// 여러 문자열을 하나로 합치기
function joinStrings(separator: string, ...strings: string[]): string {
  return strings.join(separator);
}

console.log(joinStrings(" ", "안녕하세요", "TypeScript", "입니다"));
// 안녕하세요 TypeScript 입니다

console.log(joinStrings(", ", "사과", "바나나", "오렌지", "포도"));
// 사과, 바나나, 오렌지, 포도

// 최댓값 찾기
function findMax(...numbers: number[]): number {
  if (numbers.length === 0) {
    throw new Error("최소 하나의 숫자가 필요합니다");
  }
  return Math.max(...numbers);
}

console.log(\`최댓값: \${findMax(10, 5, 8, 20, 15)}\`);  // 최댓값: 20
console.log(\`최댓값: \${findMax(100, 50, 75)}\`);       // 최댓값: 100
```

---

## 함수 오버로딩

같은 이름의 함수가 다른 타입의 매개변수를 받거나 다른 개수의 매개변수를 받을 수 있다면 편리할 것입니다. 함수 오버로딩을 사용하면 이런 것이 가능합니다. 하나의 함수가 여러 가지 형태로 호출될 수 있도록 만드는 것입니다.

### 오버로딩이란?

함수 오버로딩은 같은 함수를 다양한 방식으로 호출할 수 있게 해주는 기능입니다. 예를 들어, 숫자 두 개를 더하는 함수가 문자열 두 개를 연결하는 기능도 할 수 있다면 유용할 것입니다.

```typescript
// 오버로드 시그니처 (함수의 다양한 호출 방법 정의)
function combine(a: string, b: string): string;
function combine(a: number, b: number): number;

// 실제 구현 (모든 경우를 처리)
function combine(a: string | number, b: string | number): string | number {
  if (typeof a === "string" && typeof b === "string") {
    return a + b;  // 문자열 연결
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b;  // 숫자 더하기
  }
  throw new Error("같은 타입의 값을 전달해야 합니다");
}

console.log(combine("Hello, ", "TypeScript"));  // Hello, TypeScript
console.log(combine(10, 20));                   // 30
// console.log(combine("Hello", 20));  // ❌ 에러! 타입이 맞지 않음
```

오버로드 시그니처는 함수를 호출할 수 있는 방법들을 정의하고, 실제 구현부에서는 모든 경우를 처리합니다.

### 오버로드 시그니처 작성

오버로드 시그니처를 작성할 때는 구체적인 경우부터 일반적인 경우 순서로 작성하는 것이 좋습니다.

```typescript
// 배열 또는 단일 값을 받아 배열로 만들기
function makeArray(value: number): number[];
function makeArray(value: string): string[];
function makeArray(value: number[]): number[];
function makeArray(value: string[]): string[];

function makeArray(value: number | string | number[] | string[]): (number | string)[] {
  if (Array.isArray(value)) {
    return value;  // 이미 배열이면 그대로 반환
  }
  return [value];  // 단일 값이면 배열로 만들어 반환
}

console.log(makeArray(5));                    // [5]
console.log(makeArray("hello"));              // ["hello"]
console.log(makeArray([1, 2, 3]));           // [1, 2, 3]
console.log(makeArray(["a", "b", "c"]));     // ["a", "b", "c"]
```

**실전 예제:**

```typescript
// 날짜 형식 변환
function formatDate(date: Date): string;
function formatDate(year: number, month: number, day: number): string;

function formatDate(
  dateOrYear: Date | number,
  month?: number,
  day?: number
): string {
  if (dateOrYear instanceof Date) {
    // Date 객체가 전달된 경우
    const year = dateOrYear.getFullYear();
    const m = dateOrYear.getMonth() + 1;
    const d = dateOrYear.getDate();
    return \`\${year}-\${String(m).padStart(2, "0")}-\${String(d).padStart(2, "0")}\`;
  } else {
    // 년, 월, 일이 따로 전달된 경우
    return \`\${dateOrYear}-\${String(month).padStart(2, "0")}-\${String(day).padStart(2, "0")}\`;
  }
}

console.log(formatDate(new Date()));        // 2024-12-25 (현재 날짜)
console.log(formatDate(2024, 12, 25));      // 2024-12-25
```

### 실전 예제

오버로딩은 다양한 입력 형태를 받는 유틸리티 함수를 만들 때 매우 유용합니다.

```typescript
// 문자열 반복 함수
function repeat(str: string): string;
function repeat(str: string, count: number): string;
function repeat(str: string, count: number, separator: string): string;

function repeat(str: string, count: number = 1, separator: string = ""): string {
  const arr: string[] = [];
  for (let i = 0; i < count; i++) {
    arr.push(str);
  }
  return arr.join(separator);
}

console.log(repeat("안녕"));                    // 안녕
console.log(repeat("안녕", 3));                // 안녕안녕안녕
console.log(repeat("안녕", 3, " "));           // 안녕 안녕 안녕

// 검색 함수
function search(arr: number[], target: number): number;
function search(arr: string[], target: string): number;
function search(arr: any[], target: any, startIndex: number): number;

function search(arr: any[], target: any, startIndex: number = 0): number {
  for (let i = startIndex; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;  // 찾지 못함
}

const numbers = [10, 20, 30, 40, 50];
const words = ["apple", "banana", "orange"];

console.log(search(numbers, 30));           // 2
console.log(search(words, "banana"));       // 1
console.log(search(numbers, 40, 2));        // 3 (인덱스 2부터 검색)
```

---


---
title: "[TS] 모듈 시스템 - 3"
date: 2025-10-23 15:00:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, 모듈]
pin: true
math: true
mermaid: true
---

## 🎯 학습 목표

* 모듈의 개념과 필요성을 이해한다
* ES Modules의 import/export 문법을 사용할 수 있다
* default export와 named export의 차이를 안다
* CommonJS와 ES Modules의 차이를 이해한다
* 모듈 해석 전략(상대/절대 경로)을 이해한다
* 타입 선언 파일(.d.ts)을 작성하고 사용할 수 있다
* DefinitelyTyped를 활용하여 타입을 설치할 수 있다
* 네임스페이스와 모듈의 차이를 이해한다

---

## 🎯 Chapter 15 정리

### 핵심 개념
```
모듈              → 코드를 파일 단위로 분리
export           → 내보내기 (named, default)
import           → 가져오기
re-export        → 다른 모듈의 export를 다시 내보내기
CommonJS         → require/module.exports (레거시)
ES Modules       → import/export (표준)
모듈 해석         → 상대/절대 경로, node_modules
타입 선언 파일    → .d.ts (JavaScript 코드의 타입 정보)
@types           → DefinitelyTyped (커뮤니티 타입 선언)
```

### ES Modules vs CommonJS

| 특징 | ES Modules | CommonJS |
|------|-----------|----------|
| 문법 | `import/export` | `require/module.exports` |
| 로딩 | 정적 (컴파일 타임) | 동적 (런타임) |
| Tree Shaking | 지원 ✅ | 미지원 ❌ |
| 비동기 | 지원 | 미지원 |
| 권장 | ✅ 사용 | ⚠️ 레거시만 |

### export 종류
```typescript
// named export (여러 개 가능)
export function add() {}
export const PI = 3.14;

// default export (파일당 1개)
export default class User {}

// 혼합
export default User;
export { createUser, validateUser };
```

### import 패턴
```typescript
// named import
import { add, subtract } from './math';

// default import
import User from './user';

// 혼합
import User, { createUser } from './user';

// 전체 import
import * as Math from './math';

// 이름 변경
import { validate as validateEmail } from './user';

// 타입만 import
import type { User } from './types';

// 동적 import
const module = await import('./module');
```

### 모듈 해석
```typescript
// 상대 경로
import { User } from './models/user';
import { User } from '../models/user';

// 절대 경로 (node_modules)
import express from 'express';
import { Request } from 'express';

// 경로 별칭 (tsconfig.json 설정 필요)
import { User } from '@models/user';
import { formatDate } from '@utils/date';
```

### 타입 선언 파일
```typescript
// 📁 library.d.ts
// JavaScript 라이브러리의 타입 선언
export function calculate(a: number, b: number): number;

export interface Config {
  apiUrl: string;
  timeout: number;
}

// 전역 타입 선언
declare global {
  const API_KEY: string;
  
  interface Window {
    myProperty: string;
  }
}
```

### 모듈 시스템 Best Practices
```typescript
// ✅ 권장사항

// 1. named export 선호 (명시적)
export function createUser() {}
export function deleteUser() {}

// 2. index.ts로 진입점 만들기
// 📁 models/index.ts
export { User } from './user';
export { Product } from './product';

// 3. 경로 별칭 사용
import { User } from '@models/user';  // ✅
import { User } from '../../../models/user';  // ❌

// 4. 순환 의존성 피하기
// user.ts ↔ post.ts (❌)
// → types.ts로 분리 (✅)

// 5. 타입만 import (성능)
import type { User } from './user';

// ❌ 피해야 할 것

// 1. export * 남용
export * from './user';  // 이름 충돌 가능

// 2. default export 혼용
export default class User {}
export const USER_ROLE = {};  // 혼란스러움

// 3. 깊은 상대 경로
import { User } from '../../../../../models/user';
```

---

## 📝 연습 문제

### 문제 1: 모듈 구조 설계

다음 요구사항에 맞는 모듈 구조를 설계하세요.

**요구사항:**
- User, Product, Order 모델
- 각 모델의 CRUD 서비스
- 공통 유틸리티 함수 (날짜, 문자열)
- API 타입 정의
```typescript
// TODO: 파일 구조를 설계하고 각 파일의 export/import를 작성하세요

// 예상 구조:
// src/
// ├── models/
// │   ├── user.ts
// │   ├── product.ts
// │   ├── order.ts
// │   └── index.ts
// ├── services/
// │   ├── user-service.ts
// │   ├── product-service.ts
// │   ├── order-service.ts
// │   └── index.ts
// ├── utils/
// │   ├── date.ts
// │   ├── string.ts
// │   └── index.ts
// ├── types/
// │   ├── api.ts
// │   └── index.ts
// └── app.ts

// 각 파일의 내용을 작성하세요
```

### 문제 2: 타입 선언 파일 작성

다음 JavaScript 라이브러리에 대한 타입 선언 파일을 작성하세요.
```javascript
// 📁 my-library.js (JavaScript)
function formatCurrency(amount, currency) {
  return `${currency} ${amount.toFixed(2)}`;
}

function validateEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

const CONFIG = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

module.exports = {
  formatCurrency,
  validateEmail,
  CONFIG
};
```
```typescript
// 📁 my-library.d.ts
// TODO: 타입 선언을 작성하세요
```

### 문제 3: 모듈 리팩토링

다음 코드를 적절한 모듈로 분리하세요.
```typescript
// 📁 app.ts (현재 모든 코드가 한 파일에)
interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

interface Product {
  id: number;
  title: string;
  price: number;
  stock: number;
}

function createUser(name: string, email: string): User {
  return {
    id: Date.now(),
    name,
    email,
    role: 'user'
  };
}

function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function createProduct(title: string, price: number, stock: number): Product {
  return {
    id: Date.now(),
    title,
    price,
    stock
  };
}

function validatePrice(price: number): boolean {
  return price > 0;
}

function formatCurrency(amount: number): string {
  return `$${amount.toFixed(2)}`;
}

// TODO: 위 코드를 다음과 같이 모듈로 분리하세요
// - models/user.ts
// - models/product.ts
// - services/user-service.ts
// - services/product-service.ts
// - utils/validator.ts
// - utils/formatter.ts
// - app.ts
```

---

## 다음 Chapter 예고

**Chapter 16: 데코레이터 (Decorators)**

- 데코레이터란 무엇인가?
- 클래스 데코레이터
- 메서드 데코레이터
- 프로퍼티 데코레이터
- 매개변수 데코레이터
- 데코레이터 팩토리
- 실전 활용 (유효성 검사, 로깅, 의존성 주입)

모듈 시스템으로 코드를 체계적으로 구조화했다면, 이제 데코레이터로 메타프로그래밍을 경험해봅시다!

## 15장을 완성했습니다!

### Chapter 15의 특징:

- 모듈의 필요성과 JavaScript 모듈 역사
- ES Modules 완벽 가이드 (import/export)
- CommonJS와의 비교
- 모듈 해석 전략
- 타입 선언 파일 (.d.ts) 작성법
- DefinitelyTyped (@types) 활용
- 네임스페이스 (레거시)
- Best Practices
- 연습 문제 3개

---

**END OF CHAPTER 15**

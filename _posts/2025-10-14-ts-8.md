---
title: "[TS] 함수 타입 시스템 - 2"
date: 2025-10-14 10:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, ts함수]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 함수의 매개변수와 반환 타입을 지정할 수 있다
> - 선택적 매개변수와 기본 매개변수를 사용할 수 있다
> - 함수 오버로딩을 이해하고 활용할 수 있다
> - 콜백 함수와 고차 함수에 타입을 지정할 수 있다

---

## 함수의 this 타입

JavaScript에서 `this`는 "지금 이 함수를 실행하고 있는 객체"를 가리키는 특별한 키워드입니다. 하지만 `this`는 상황에 따라 다른 것을 가리킬 수 있어서 혼란스러울 때가 있습니다. 

TypeScript에서는 `this`의 타입을 명시하여 이런 혼란을 줄일 수 있습니다.

### this가 뭔가요?

먼저 간단한 예제로 `this`를 이해해봅시다.

```typescript
const person = {
  name: "홍길동",
  sayHello() {
    console.log(\`안녕하세요, \${this.name}입니다.\`);
    // 여기서 this는 person 객체를 가리킴
  }
};

person.sayHello();  // 안녕하세요, 홍길동입니다.
```

위 코드에서 `this.name`은 `person.name`과 같습니다. `sayHello` 함수가 `person` 객체 안에 있고, `person`이 이 함수를 호출했기 때문에 `this`는 `person`을 가리킵니다.

**쉽게 말하면:** `this`는 "나를 호출한 주인"을 가리킵니다.

### this의 문제점

하지만 함수를 다른 곳에서 호출하면 `this`가 달라질 수 있습니다.

```typescript
const person = {
  name: "홍길동",
  sayHello() {
    console.log(\`안녕하세요, \${this.name}입니다.\`);
  }
};

const greet = person.sayHello;  // 함수를 변수에 저장
greet();  // 에러 또는 이상한 결과!
// this가 person이 아니게 됨
```

함수를 변수에 저장하고 호출하면, `this`가 `person`이 아니라 다른 것(또는 undefined)을 가리키게 됩니다. 이런 문제를 방지하기 위해 TypeScript에서 `this`의 타입을 지정할 수 있습니다.


### 함수 내 this 타입 지정

일반 함수에서 `this`의 타입을 지정하려면, 첫 번째 매개변수로 `this`의 타입을 명시합니다. 이는 실제 매개변수가 아니며, TypeScript에게 `this`의 타입을 알려주는 역할만 합니다.

```typescript
// 사용자 객체
interface User {
  name: string;
  age: number;
  greet(this: User): void;  // this의 타입 지정 - "이 함수는 User 객체에서만 호출되어야 해!"
}

const user: User = {
  name: "홍길동",
  age: 25,
  greet(this: User) {
    console.log(\`안녕하세요, 저는 \${this.name}입니다.\`);
    console.log(\`나이는 \${this.age}세입니다.\`);
  }
};

user.greet();  // 안녕하세요, 저는 홍길동입니다.- user가 greet을 호출
```

**`greet(this: User)`의 의미:**
- "이 함수 안에서 `this`는 `User` 타입이어야 한다"
- "이 함수는 `User` 객체에서만 제대로 동작한다"

**중요한 점:** `this: User`는 실제 매개변수가 아닙니다! TypeScript에게 "`this`의 타입이 뭔지" 알려주는 것일 뿐입니다. 함수를 호출할 때 `this`를 전달하지 않습니다.

```typescript
// ❌ 이렇게 하는 게 아님
user.greet(user);

// ✅ 이렇게 호출
user.greet();
```

### 왜 this 타입을 지정하나요?

`this` 타입을 지정하면 함수가 잘못된 방식으로 사용되는 것을 방지할 수 있습니다.

```typescript
interface Counter {
  count: number;
  increment(this: Counter): void;
}

const counter: Counter = {
  count: 0,
  increment(this: Counter) {
    this.count++;
    console.log(\`카운트: \${this.count}\`);
  }
};

counter.increment();  // 카운트: 1
counter.increment();  // 카운트: 2

// ❌ 잘못된 사용 (this가 Counter가 아님)
const incrementFn = counter.increment;
// incrementFn();  // 에러 또는 undefined
```

### 실전 예제: 은행 계좌

```typescript
interface BankAccount {
  owner: string;
  balance: number;
  deposit(this: BankAccount, amount: number): void;
  withdraw(this: BankAccount, amount: number): void;
}

const account: BankAccount = {
  owner: "홍길동",
  balance: 10000,
  
  deposit(this: BankAccount, amount: number) {
    // this는 반드시 BankAccount여야 함
    this.balance += amount;
    console.log(\`\${this.owner}님, \${amount}원 입금되었습니다.\`);
    console.log(\`잔액: \${this.balance}원\`);
  },
  
  withdraw(this: BankAccount, amount: number) {
    if (this.balance >= amount) {
      this.balance -= amount;
      console.log(\`\${this.owner}님, \${amount}원 출금되었습니다.\`);
      console.log(\`잔액: \${this.balance}원\`);
    } else {
      console.log("잔액이 부족합니다.");
    }
  }
};

// ✅ 올바른 사용
account.deposit(5000);   // 홍길동님, 5000원 입금되었습니다.
account.withdraw(3000);  // 홍길동님, 3000원 출금되었습니다.

// ❌ 이렇게 하면 안 됨
const depositFunc = account.deposit;
// depositFunc(1000);  // TypeScript가 에러 표시!
```

### 핵심 정리

1. **`this`는 "나를 호출한 객체"를 가리킵니다**
   ```typescript
   user.greet();  // user가 호출 → this는 user
   ```

2. **`this: User`는 실제 매개변수가 아닙니다**
   - TypeScript에게 this의 타입을 알려주는 것
   - 함수 호출 시 전달하지 않음

3. **`this` 타입을 지정하는 이유:**
   - 함수가 올바른 객체에서만 호출되도록 보장
   - 실수로 잘못 사용하는 것을 방지

### 초보자를 위한 조언

사실 초보자라면 `this` 타입 지정을 당장 사용할 필요는 없습니다! 다음 경우에만 사용하면 됩니다:

- ✅ 객체의 메서드가 항상 그 객체에서만 호출되어야 할 때
- ✅ 함수를 다른 곳에 전달하지 않을 때

일반적인 경우에는 그냥 평범하게 함수를 작성하면 됩니다:

```typescript
const user = {
  name: "홍길동",
  greet() {
    console.log(\`안녕, \${this.name}\`);
  }
};

user.greet();  // 이것만으로 충분합니다!
```

`this` 타입 지정은 더 안전한 코드를 원할 때 사용하는 고급 기능이니, 지금은 "이런 것도 있구나" 정도만 알고 넘어가도 괜찮습니다! 


### 화살표 함수와 this

화살표 함수는 자신만의 `this`를 가지지 않고, 상위 스코프의 `this`를 사용합니다. 따라서 `this`와 관련된 문제를 피하고 싶다면 화살표 함수를 사용하는 것이 좋습니다.

```typescript
interface Timer {
  seconds: number;
  start(): void;
}

const timer: Timer = {
  seconds: 0,
  start() {
    // 일반 함수를 사용하면 this가 예상과 다를 수 있음
    // setInterval(function() {
    //   this.seconds++;  // ❌ this가 Timer가 아닐 수 있음
    // }, 1000);
    
    // 화살표 함수를 사용하면 this가 timer를 가리킴
    setInterval(() => {
      this.seconds++;
      console.log(\`\${this.seconds}초 경과\`);
    }, 1000);
  }
};

// timer.start();  // 1초, 2초, 3초... 출력
```

**실전 예제:**

```typescript
// 게임 캐릭터 객체
interface Character {
  name: string;
  hp: number;
  attack(this: Character, target: Character): void;
  heal(this: Character, amount: number): void;
}

const warrior: Character = {
  name: "전사",
  hp: 100,
  
  attack(this: Character, target: Character) {
    const damage = 20;
    target.hp -= damage;
    console.log(\`\${this.name}이(가) \${target.name}을(를) 공격했습니다!\`);
    console.log(\`\${target.name}의 HP: \${target.hp}\`);
  },
  
  heal(this: Character, amount: number) {
    this.hp += amount;
    console.log(\`\${this.name}이(가) \${amount}만큼 회복했습니다.\`);
    console.log(\`현재 HP: \${this.hp}\`);
  }
};

const mage: Character = {
  name: "마법사",
  hp: 80,
  
  attack(this: Character, target: Character) {
    const damage = 30;
    target.hp -= damage;
    console.log(\`\${this.name}이(가) 마법으로 \${target.name}을(를) 공격했습니다!\`);
    console.log(\`\${target.name}의 HP: \${target.hp}\`);
  },
  
  heal(this: Character, amount: number) {
    this.hp += amount;
    console.log(\`\${this.name}이(가) \${amount}만큼 회복했습니다.\`);
    console.log(\`현재 HP: \${this.hp}\`);
  }
};

warrior.attack(mage);   // 전사가 마법사를 공격
mage.heal(15);          // 마법사가 회복
mage.attack(warrior);   // 마법사가 전사를 공격
```

---

## 콜백 함수와 고차 함수

콜백 함수는 다른 함수에 인자로 전달되는 함수입니다. 고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수를 말합니다. TypeScript에서는 이런 함수들에도 정확한 타입을 지정할 수 있습니다.

### 콜백 함수 타입 지정

콜백 함수를 매개변수로 받는 함수를 만들 때, 콜백 함수의 타입을 명확히 지정해야 합니다.

```typescript
// 배열의 각 요소에 함수를 적용
function forEach(arr: number[], callback: (item: number) => void): void {
  for (const item of arr) {
    callback(item);
  }
}

// 콜백 함수 정의
function printNumber(n: number): void {
  console.log(\`숫자: \${n}\`);
}

// 사용
const numbers = [1, 2, 3, 4, 5];
forEach(numbers, printNumber);
// 출력:
// 숫자: 1
// 숫자: 2
// 숫자: 3
// 숫자: 4
// 숫자: 5

// 화살표 함수로 직접 전달
forEach(numbers, (n) => {
  console.log(\`\${n}의 제곱: \${n * n}\`);
});
```

콜백 함수는 인덱스나 배열 자체도 받을 수 있습니다. 이런 경우 타입도 함께 지정해야 합니다.

```typescript
// 인덱스도 함께 전달하는 forEach
function forEachWithIndex(
  arr: string[], 
  callback: (item: string, index: number) => void
): void {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

const fruits = ["사과", "바나나", "오렌지"];
forEachWithIndex(fruits, (fruit, index) => {
  console.log(\`\${index + 1}. \${fruit}\`);
});
// 출력:
// 1. 사과
// 2. 바나나
// 3. 오렌지
```

**실전 예제:**

```typescript
// 배열 필터 함수
function filter(
  arr: number[], 
  predicate: (item: number) => boolean
): number[] {
  const result: number[] = [];
  for (const item of arr) {
    if (predicate(item)) {
      result.push(item);
    }
  }
  return result;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 짝수만 필터링
const evenNumbers = filter(numbers, (n) => n % 2 === 0);
console.log("짝수:", evenNumbers);  // [2, 4, 6, 8, 10]

// 5보다 큰 수만 필터링
const largeNumbers = filter(numbers, (n) => n > 5);
console.log("5보다 큰 수:", largeNumbers);  // [6, 7, 8, 9, 10]

// 배열 변환 함수 (map)
function map<T, U>(arr: T[], transform: (item: T) => U): U[] {
  const result: U[] = [];
  for (const item of arr) {
    result.push(transform(item));
  }
  return result;
}

// 숫자를 문자열로 변환
const numberStrings = map(numbers, (n) => \`숫자 \${n}\`);
console.log(numberStrings);
// ["숫자 1", "숫자 2", "숫자 3", ...]

// 숫자를 제곱으로 변환
const squares = map(numbers, (n) => n * n);
console.log("제곱:", squares);
// [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

### 함수를 반환하는 함수

함수가 다른 함수를 반환할 수도 있습니다. 이런 경우도 타입을 정확히 지정할 수 있습니다.

```typescript
// 특정 수를 더하는 함수를 생성하는 함수
function createAdder(x: number): (y: number) => number {
  return (y: number): number => {
    return x + y;
  };
}

const add5 = createAdder(5);
console.log(add5(10));  // 15
console.log(add5(20));  // 25

const add100 = createAdder(100);
console.log(add100(10));  // 110
console.log(add100(50));  // 150
```

**실전 예제:**

```typescript
// 특정 배수를 확인하는 함수 생성기
function createMultipleChecker(divisor: number): (n: number) => boolean {
  return (n: number): boolean => {
    return n % divisor === 0;
  };
}

const isMultipleOf3 = createMultipleChecker(3);
const isMultipleOf5 = createMultipleChecker(5);

console.log(isMultipleOf3(9));   // true
console.log(isMultipleOf3(10));  // false
console.log(isMultipleOf5(10));  // true
console.log(isMultipleOf5(11));  // false

// 로거 생성기
function createLogger(prefix: string): (message: string) => void {
  return (message: string): void => {
    console.log(\`[\${prefix}] \${message}\`);
  };
}

const errorLogger = createLogger("ERROR");
const infoLogger = createLogger("INFO");

errorLogger("파일을 찾을 수 없습니다");
// [ERROR] 파일을 찾을 수 없습니다

infoLogger("프로그램이 시작되었습니다");
// [INFO] 프로그램이 시작되었습니다

// 카운터 생성기
function createCounter(start: number = 0): () => number {
  let count = start;
  return (): number => {
    return ++count;
  };
}

const counter1 = createCounter(0);
console.log(counter1());  // 1
console.log(counter1());  // 2
console.log(counter1());  // 3

const counter2 = createCounter(100);
console.log(counter2());  // 101
console.log(counter2());  // 102
```

### 고차 함수 실전 활용

고차 함수는 코드의 재사용성을 높이고 더 추상화된 로직을 작성할 수 있게 해줍니다.

```typescript
// 함수 실행 시간 측정 함수
function measureTime<T>(
  fn: () => T,
  label: string = "실행 시간"
): T {
  const start = Date.now();
  const result = fn();
  const end = Date.now();
  console.log(\`\${label}: \${end - start}ms\`);
  return result;
}

// 사용 예시
measureTime(() => {
  let sum = 0;
  for (let i = 0; i < 1000000; i++) {
    sum += i;
  }
  return sum;
}, "합계 계산");

// 함수 재시도 로직
function retry<T>(
  fn: () => T,
  maxAttempts: number = 3
): T | null {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      console.log(\`시도 \${attempt}/\${maxAttempts}\`);
      return fn();
    } catch (error) {
      console.log(\`실패: \${error}\`);
      if (attempt === maxAttempts) {
        console.log("모든 시도가 실패했습니다");
        return null;
      }
    }
  }
  return null;
}

// 함수 조합
function compose<T>(
  ...functions: ((arg: T) => T)[]
): (arg: T) => T {
  return (arg: T): T => {
    return functions.reduceRight((result, fn) => fn(result), arg);
  };
}

// 숫자 처리 함수들
const double = (n: number): number => n * 2;
const addTen = (n: number): number => n + 10;
const square = (n: number): number => n * n;

// 함수 조합
const process = compose(square, addTen, double);
console.log(process(5));  // (5 * 2 + 10) ^ 2 = 400
```

---

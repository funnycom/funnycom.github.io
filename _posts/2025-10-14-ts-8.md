---
title: "[TS] 함수 타입 시스템 - 2"
date: 2025-10-14 10:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, ts함수]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 함수의 매개변수와 반환 타입을 지정할 수 있다
> - 선택적 매개변수와 기본 매개변수를 사용할 수 있다
> - 함수 오버로딩을 이해하고 활용할 수 있다
> - 콜백 함수와 고차 함수에 타입을 지정할 수 있다

---

## 8.4 함수의 this 타입

JavaScript에서 `this`는 때때로 혼란스러울 수 있습니다. TypeScript에서는 함수 내부의 `this` 타입을 명시할 수 있어, `this`가 잘못 사용되는 것을 방지할 수 있습니다.

### 함수 내 this 타입 지정

일반 함수에서 `this`의 타입을 지정하려면, 첫 번째 매개변수로 `this`의 타입을 명시합니다. 이는 실제 매개변수가 아니며, TypeScript에게 `this`의 타입을 알려주는 역할만 합니다.

\`\`\`typescript
// 사용자 객체
interface User {
  name: string;
  age: number;
  greet(this: User): void;  // this의 타입 지정
}

const user: User = {
  name: "홍길동",
  age: 25,
  greet(this: User) {
    console.log(\`안녕하세요, 저는 \${this.name}입니다.\`);
    console.log(\`나이는 \${this.age}세입니다.\`);
  }
};

user.greet();  // 안녕하세요, 저는 홍길동입니다.
\`\`\`

`this` 타입을 지정하면, 함수가 잘못된 컨텍스트에서 호출되는 것을 방지할 수 있습니다.

\`\`\`typescript
interface Counter {
  count: number;
  increment(this: Counter): void;
}

const counter: Counter = {
  count: 0,
  increment(this: Counter) {
    this.count++;
    console.log(\`카운트: \${this.count}\`);
  }
};

counter.increment();  // 카운트: 1
counter.increment();  // 카운트: 2

// ❌ 잘못된 사용 (this가 Counter가 아님)
const incrementFn = counter.increment;
// incrementFn();  // 에러 또는 undefined
\`\`\`

### 화살표 함수와 this

화살표 함수는 자신만의 `this`를 가지지 않고, 상위 스코프의 `this`를 사용합니다. 따라서 `this`와 관련된 문제를 피하고 싶다면 화살표 함수를 사용하는 것이 좋습니다.

\`\`\`typescript
interface Timer {
  seconds: number;
  start(): void;
}

const timer: Timer = {
  seconds: 0,
  start() {
    // 일반 함수를 사용하면 this가 예상과 다를 수 있음
    // setInterval(function() {
    //   this.seconds++;  // ❌ this가 Timer가 아닐 수 있음
    // }, 1000);
    
    // 화살표 함수를 사용하면 this가 timer를 가리킴
    setInterval(() => {
      this.seconds++;
      console.log(\`\${this.seconds}초 경과\`);
    }, 1000);
  }
};

// timer.start();  // 1초, 2초, 3초... 출력
\`\`\`

**실전 예제:**

\`\`\`typescript
// 게임 캐릭터 객체
interface Character {
  name: string;
  hp: number;
  attack(this: Character, target: Character): void;
  heal(this: Character, amount: number): void;
}

const warrior: Character = {
  name: "전사",
  hp: 100,
  
  attack(this: Character, target: Character) {
    const damage = 20;
    target.hp -= damage;
    console.log(\`\${this.name}이(가) \${target.name}을(를) 공격했습니다!\`);
    console.log(\`\${target.name}의 HP: \${target.hp}\`);
  },
  
  heal(this: Character, amount: number) {
    this.hp += amount;
    console.log(\`\${this.name}이(가) \${amount}만큼 회복했습니다.\`);
    console.log(\`현재 HP: \${this.hp}\`);
  }
};

const mage: Character = {
  name: "마법사",
  hp: 80,
  
  attack(this: Character, target: Character) {
    const damage = 30;
    target.hp -= damage;
    console.log(\`\${this.name}이(가) 마법으로 \${target.name}을(를) 공격했습니다!\`);
    console.log(\`\${target.name}의 HP: \${target.hp}\`);
  },
  
  heal(this: Character, amount: number) {
    this.hp += amount;
    console.log(\`\${this.name}이(가) \${amount}만큼 회복했습니다.\`);
    console.log(\`현재 HP: \${this.hp}\`);
  }
};

warrior.attack(mage);   // 전사가 마법사를 공격
mage.heal(15);          // 마법사가 회복
mage.attack(warrior);   // 마법사가 전사를 공격
\`\`\`

---

## 8.5 콜백 함수와 고차 함수

콜백 함수는 다른 함수에 인자로 전달되는 함수입니다. 고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수를 말합니다. TypeScript에서는 이런 함수들에도 정확한 타입을 지정할 수 있습니다.

### 콜백 함수 타입 지정

콜백 함수를 매개변수로 받는 함수를 만들 때, 콜백 함수의 타입을 명확히 지정해야 합니다.

\`\`\`typescript
// 배열의 각 요소에 함수를 적용
function forEach(arr: number[], callback: (item: number) => void): void {
  for (const item of arr) {
    callback(item);
  }
}

// 콜백 함수 정의
function printNumber(n: number): void {
  console.log(\`숫자: \${n}\`);
}

// 사용
const numbers = [1, 2, 3, 4, 5];
forEach(numbers, printNumber);
// 출력:
// 숫자: 1
// 숫자: 2
// 숫자: 3
// 숫자: 4
// 숫자: 5

// 화살표 함수로 직접 전달
forEach(numbers, (n) => {
  console.log(\`\${n}의 제곱: \${n * n}\`);
});
\`\`\`

콜백 함수는 인덱스나 배열 자체도 받을 수 있습니다. 이런 경우 타입도 함께 지정해야 합니다.

\`\`\`typescript
// 인덱스도 함께 전달하는 forEach
function forEachWithIndex(
  arr: string[], 
  callback: (item: string, index: number) => void
): void {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

const fruits = ["사과", "바나나", "오렌지"];
forEachWithIndex(fruits, (fruit, index) => {
  console.log(\`\${index + 1}. \${fruit}\`);
});
// 출력:
// 1. 사과
// 2. 바나나
// 3. 오렌지
\`\`\`

**실전 예제:**

\`\`\`typescript
// 배열 필터 함수
function filter(
  arr: number[], 
  predicate: (item: number) => boolean
): number[] {
  const result: number[] = [];
  for (const item of arr) {
    if (predicate(item)) {
      result.push(item);
    }
  }
  return result;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 짝수만 필터링
const evenNumbers = filter(numbers, (n) => n % 2 === 0);
console.log("짝수:", evenNumbers);  // [2, 4, 6, 8, 10]

// 5보다 큰 수만 필터링
const largeNumbers = filter(numbers, (n) => n > 5);
console.log("5보다 큰 수:", largeNumbers);  // [6, 7, 8, 9, 10]

// 배열 변환 함수 (map)
function map<T, U>(arr: T[], transform: (item: T) => U): U[] {
  const result: U[] = [];
  for (const item of arr) {
    result.push(transform(item));
  }
  return result;
}

// 숫자를 문자열로 변환
const numberStrings = map(numbers, (n) => \`숫자 \${n}\`);
console.log(numberStrings);
// ["숫자 1", "숫자 2", "숫자 3", ...]

// 숫자를 제곱으로 변환
const squares = map(numbers, (n) => n * n);
console.log("제곱:", squares);
// [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\`\`\`

### 함수를 반환하는 함수

함수가 다른 함수를 반환할 수도 있습니다. 이런 경우도 타입을 정확히 지정할 수 있습니다.

\`\`\`typescript
// 특정 수를 더하는 함수를 생성하는 함수
function createAdder(x: number): (y: number) => number {
  return (y: number): number => {
    return x + y;
  };
}

const add5 = createAdder(5);
console.log(add5(10));  // 15
console.log(add5(20));  // 25

const add100 = createAdder(100);
console.log(add100(10));  // 110
console.log(add100(50));  // 150
\`\`\`

**실전 예제:**

\`\`\`typescript
// 특정 배수를 확인하는 함수 생성기
function createMultipleChecker(divisor: number): (n: number) => boolean {
  return (n: number): boolean => {
    return n % divisor === 0;
  };
}

const isMultipleOf3 = createMultipleChecker(3);
const isMultipleOf5 = createMultipleChecker(5);

console.log(isMultipleOf3(9));   // true
console.log(isMultipleOf3(10));  // false
console.log(isMultipleOf5(10));  // true
console.log(isMultipleOf5(11));  // false

// 로거 생성기
function createLogger(prefix: string): (message: string) => void {
  return (message: string): void => {
    console.log(\`[\${prefix}] \${message}\`);
  };
}

const errorLogger = createLogger("ERROR");
const infoLogger = createLogger("INFO");

errorLogger("파일을 찾을 수 없습니다");
// [ERROR] 파일을 찾을 수 없습니다

infoLogger("프로그램이 시작되었습니다");
// [INFO] 프로그램이 시작되었습니다

// 카운터 생성기
function createCounter(start: number = 0): () => number {
  let count = start;
  return (): number => {
    return ++count;
  };
}

const counter1 = createCounter(0);
console.log(counter1());  // 1
console.log(counter1());  // 2
console.log(counter1());  // 3

const counter2 = createCounter(100);
console.log(counter2());  // 101
console.log(counter2());  // 102
\`\`\`

### 고차 함수 실전 활용

고차 함수는 코드의 재사용성을 높이고 더 추상화된 로직을 작성할 수 있게 해줍니다.

\`\`\`typescript
// 함수 실행 시간 측정 함수
function measureTime<T>(
  fn: () => T,
  label: string = "실행 시간"
): T {
  const start = Date.now();
  const result = fn();
  const end = Date.now();
  console.log(\`\${label}: \${end - start}ms\`);
  return result;
}

// 사용 예시
measureTime(() => {
  let sum = 0;
  for (let i = 0; i < 1000000; i++) {
    sum += i;
  }
  return sum;
}, "합계 계산");

// 함수 재시도 로직
function retry<T>(
  fn: () => T,
  maxAttempts: number = 3
): T | null {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      console.log(\`시도 \${attempt}/\${maxAttempts}\`);
      return fn();
    } catch (error) {
      console.log(\`실패: \${error}\`);
      if (attempt === maxAttempts) {
        console.log("모든 시도가 실패했습니다");
        return null;
      }
    }
  }
  return null;
}

// 함수 조합
function compose<T>(
  ...functions: ((arg: T) => T)[]
): (arg: T) => T {
  return (arg: T): T => {
    return functions.reduceRight((result, fn) => fn(result), arg);
  };
}

// 숫자 처리 함수들
const double = (n: number): number => n * 2;
const addTen = (n: number): number => n + 10;
const square = (n: number): number => n * n;

// 함수 조합
const process = compose(square, addTen, double);
console.log(process(5));  // (5 * 2 + 10) ^ 2 = 400
\`\`\`

---

---
title: "[TS] ì‹¤ì „ í”„ë¡œì íŠ¸ - 1 "
date: 2025-10-23 16:35:00 +0900
categories: [ì›¹ ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸]
tags: [ì›¹ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, TS]
pin: true
math: true
mermaid: true
published: false
---


# Part 3 ì‹¤ì „ í”„ë¡œì íŠ¸: TypeScript ì‘ì—… ê´€ë¦¬ ì‹œìŠ¤í…œ

## ğŸ¯ í”„ë¡œì íŠ¸ ê°œìš”

Part 3ì—ì„œ ë°°ìš´ ê³ ê¸‰ TypeScript ê¸°ëŠ¥ë“¤ì„ ëª¨ë‘ í™œìš©í•˜ì—¬ **ì‘ì—… ê´€ë¦¬ ì‹œìŠ¤í…œ(Task Management System)**ì„ ë§Œë“¤ì–´ë´…ì‹œë‹¤.

**í”„ë¡œì íŠ¸ ëª©í‘œ:**
- ìœ í‹¸ë¦¬í‹° íƒ€ì… í™œìš©
- ê³ ê¸‰ íƒ€ì… ê¸°ë²• ì ìš©
- ëª¨ë“ˆ ì‹œìŠ¤í…œ êµ¬ì¡°í™”
- ë°ì½”ë ˆì´í„° íŒ¨í„´ ì‚¬ìš©
- TypeScript ì„¤ì • ìµœì í™”

**ê¸°ìˆ  ìŠ¤íƒ:**
- TypeScript
- Node.js
- íŒŒì¼ ê¸°ë°˜ ë°ì´í„° ì €ì¥ (JSON)
- ë°ì½”ë ˆì´í„°ë¥¼ í™œìš©í•œ ìœ íš¨ì„± ê²€ì‚¬, ë¡œê¹…

---

## ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡°
```
task-management-system/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ models/           # ë°ì´í„° ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ task.ts
â”‚   â”‚   â”œâ”€â”€ user.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ repositories/     # ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ
â”‚   â”‚   â”œâ”€â”€ base-repository.ts
â”‚   â”‚   â”œâ”€â”€ task-repository.ts
â”‚   â”‚   â”œâ”€â”€ user-repository.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ services/         # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ task-service.ts
â”‚   â”‚   â”œâ”€â”€ user-service.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ decorators/       # ì»¤ìŠ¤í…€ ë°ì½”ë ˆì´í„°
â”‚   â”‚   â”œâ”€â”€ validation.ts
â”‚   â”‚   â”œâ”€â”€ logging.ts
â”‚   â”‚   â”œâ”€â”€ cache.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ utils/            # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ types/            # ê³µí†µ íƒ€ì… ì •ì˜
â”‚   â”‚   â”œâ”€â”€ common.ts
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ index.ts          # ì§„ì…ì 
â”œâ”€â”€ data/                 # JSON íŒŒì¼ ì €ì¥ì†Œ
â”‚   â”œâ”€â”€ tasks.json
â”‚   â””â”€â”€ users.json
â”œâ”€â”€ tests/                # í…ŒìŠ¤íŠ¸ íŒŒì¼
â”œâ”€â”€ .eslintrc.json
â”œâ”€â”€ .prettierrc.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.prod.json
â””â”€â”€ package.json
```

---

## ğŸš€ Step 1: í”„ë¡œì íŠ¸ ì´ˆê¸° ì„¤ì •

### 1-1. í”„ë¡œì íŠ¸ ìƒì„±
```bash
mkdir task-management-system
cd task-management-system
npm init -y
```

### 1-2. ì˜ì¡´ì„± ì„¤ì¹˜
```bash
# TypeScript ë° íƒ€ì… ì •ì˜
npm install --save-dev typescript @types/node

# ë°ì½”ë ˆì´í„° ë©”íƒ€ë°ì´í„°
npm install reflect-metadata

# ê°œë°œ ë„êµ¬
npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install --save-dev prettier eslint-config-prettier
npm install --save-dev ts-node nodemon

# ìœ í‹¸ë¦¬í‹°
npm install uuid
npm install --save-dev @types/uuid
```

### 1-3. tsconfig.json ì„¤ì •
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    
    "moduleResolution": "node",
    "resolveJsonModule": true,
    
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    
    "declaration": true,
    "sourceMap": true,
    
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    
    "baseUrl": "./src",
    "paths": {
      "@models/*": ["models/*"],
      "@repositories/*": ["repositories/*"],
      "@services/*": ["services/*"],
      "@decorators/*": ["decorators/*"],
      "@utils/*": ["utils/*"],
      "@types/*": ["types/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

### 1-4. package.json ìŠ¤í¬ë¦½íŠ¸
```json
{
  "name": "task-management-system",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "build:prod": "tsc -p tsconfig.prod.json",
    "start": "node dist/index.js",
    "dev": "nodemon --watch src --exec ts-node src/index.ts",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "clean": "rm -rf dist"
  }
}
```

### 1-5. .eslintrc.json
```json
{
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint"],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "error"
  }
}
```

### 1-6. .prettierrc.json
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

---

## ğŸ“ Step 2: íƒ€ì… ì •ì˜ (ìœ í‹¸ë¦¬í‹° íƒ€ì… í™œìš©)

### 2-1. src/types/common.ts
```typescript
// ê³µí†µ íƒ€ì… ì •ì˜
export type ID = string | number;

export type Timestamp = {
  createdAt: Date;
  updatedAt: Date;
};

export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type RequiredFields<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// Deep Partial
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// íŠ¹ì • íƒ€ì…ì˜ í‚¤ë§Œ ì¶”ì¶œ
export type PickByType<T, ValueType> = {
  [K in keyof T as T[K] extends ValueType ? K : never]: T[K];
};

// Readonlyë¥¼ ì œê±°
export type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};
```

### 2-2. src/types/api.ts
```typescript
// API ì‘ë‹µ íƒ€ì…
export type ApiResponse<T> = 
  | { success: true; data: T; message?: string }
  | { success: false; error: string; code?: string };

// í˜ì´ì§€ë„¤ì´ì…˜
export interface Pagination {
  page: number;
  limit: number;
  total: number;
}

export interface PaginatedResponse<T> {
  items: T[];
  pagination: Pagination;
}

// í•„í„°ë§
export type FilterOperator = 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'contains';

export type Filter<T> = {
  [K in keyof T]?: {
    operator: FilterOperator;
    value: T[K] | T[K][];
  };
};

// ì •ë ¬
export type SortOrder = 'asc' | 'desc';

export type Sort<T> = {
  field: keyof T;
  order: SortOrder;
};
```

### 2-3. src/types/index.ts
```typescript
export * from './common';
export * from './api';
```

---

## ğŸ“¦ Step 3: ëª¨ë¸ ì •ì˜

### 3-1. src/models/user.ts
```typescript
import { ID, Timestamp } from '@types/common';

export type UserRole = 'admin' | 'user' | 'guest';

export interface User extends Timestamp {
  id: ID;
  username: string;
  email: string;
  password: string;
  role: UserRole;
  isActive: boolean;
}

// ìƒì„± ì‹œ ì‚¬ìš©í•  DTO (id, timestamp ì œì™¸)
export type CreateUserDto = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// ì—…ë°ì´íŠ¸ ì‹œ ì‚¬ìš©í•  DTO (ì¼ë¶€ë§Œ ìˆ˜ì • ê°€ëŠ¥)
export type UpdateUserDto = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;

// ê³µê°œ í”„ë¡œí•„ (password ì œì™¸)
export type UserProfile = Omit<User, 'password'>;

// ë¡œê·¸ì¸ ì‘ë‹µ
export type LoginResponse = {
  user: UserProfile;
  token: string;
};
```

### 3-2. src/models/task.ts
```typescript
import { ID, Timestamp } from '@types/common';

export type TaskStatus = 'todo' | 'in-progress' | 'done' | 'cancelled';
export type TaskPriority = 'low' | 'medium' | 'high' | 'urgent';

export interface Task extends Timestamp {
  id: ID;
  title: string;
  description?: string;
  status: TaskStatus;
  priority: TaskPriority;
  assigneeId?: ID;
  dueDate?: Date;
  tags: string[];
  completedAt?: Date;
}

// ìƒì„± DTO
export type CreateTaskDto = Omit<Task, 'id' | 'createdAt' | 'updatedAt' | 'completedAt'>;

// ì—…ë°ì´íŠ¸ DTO
export type UpdateTaskDto = Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>;

// ìƒíƒœë³„ Task ì¶”ì¶œ (ì¡°ê±´ë¶€ íƒ€ì… í™œìš©)
export type TaskByStatus<S extends TaskStatus> = Task & { status: S };

export type TodoTask = TaskByStatus<'todo'>;
export type InProgressTask = TaskByStatus<'in-progress'>;
export type DoneTask = TaskByStatus<'done'>;
```

### 3-3. src/models/index.ts
```typescript
export * from './user';
export * from './task';
```

---

## ğŸ¨ Step 4: ë°ì½”ë ˆì´í„° êµ¬í˜„

### 4-1. src/decorators/logging.ts
```typescript
import 'reflect-metadata';

export function Log(prefix: string = 'LOG') {
  return function (
    target: unknown,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ): PropertyDescriptor {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: unknown[]) {
      console.log(`[${prefix}] ${propertyKey} called with:`, JSON.stringify(args));
      const start = performance.now();

      const result = originalMethod.apply(this, args);

      const end = performance.now();
      console.log(`[${prefix}] ${propertyKey} took ${(end - start).toFixed(2)}ms`);

      return result;
    };

    return descriptor;
  };
}

export function LogAsync(prefix: string = 'LOG') {
  return function (
    target: unknown,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ): PropertyDescriptor {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: unknown[]) {
      console.log(`[${prefix}] ${propertyKey} called with:`, JSON.stringify(args));
      const start = performance.now();

      try {
        const result = await originalMethod.apply(this, args);
        const end = performance.now();
        console.log(`[${prefix}] ${propertyKey} completed in ${(end - start).toFixed(2)}ms`);
        return result;
      } catch (error) {
        const end = performance.now();
        console.error(
          `[${prefix}] ${propertyKey} failed after ${(end - start).toFixed(2)}ms:`,
          error
        );
        throw error;
      }
    };

    return descriptor;
  };
}
```

### 4-2. src/decorators/validation.ts
```typescript
import 'reflect-metadata';

const VALIDATION_KEY = 'validation';

interface ValidationRule {
  type: 'required' | 'minLength' | 'maxLength' | 'email' | 'min' | 'max';
  value?: number | string;
  message?: string;
}

// ë©”íƒ€ë°ì´í„° ì €ì¥
function addValidation(target: unknown, propertyKey: string, rule: ValidationRule): void {
  const existingRules: ValidationRule[] =
    Reflect.getMetadata(VALIDATION_KEY, target, propertyKey) || [];
  existingRules.push(rule);
  Reflect.defineMetadata(VALIDATION_KEY, existingRules, target, propertyKey);
}

// ë°ì½”ë ˆì´í„°ë“¤
export function Required(message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'required', message });
  };
}

export function MinLength(length: number, message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'minLength', value: length, message });
  };
}

export function MaxLength(length: number, message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'maxLength', value: length, message });
  };
}

export function Email(message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'email', message });
  };
}

export function Min(value: number, message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'min', value, message });
  };
}

export function Max(value: number, message?: string) {
  return function (target: unknown, propertyKey: string): void {
    addValidation(target, propertyKey, { type: 'max', value, message });
  };
}

// ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜
export class ValidationError extends Error {
  constructor(public errors: string[]) {
    super('Validation failed');
  }
}

export function validate(obj: object): void {
  const errors: string[] = [];
  const properties = Object.getOwnPropertyNames(obj);

  for (const prop of properties) {
    const rules: ValidationRule[] = Reflect.getMetadata(VALIDATION_KEY, obj, prop) || [];
    const value = (obj as Record<string, unknown>)[prop];

    for (const rule of rules) {
      switch (rule.type) {
        case 'required':
          if (value === null || value === undefined || value === '') {
            errors.push(rule.message || `${prop} is required`);
          }
          break;

        case 'minLength':
          if (typeof value === 'string' && value.length < (rule.value as number)) {
            errors.push(
              rule.message || `${prop} must be at least ${rule.value} characters`
            );
          }
          break;

        case 'maxLength':
          if (typeof value === 'string' && value.length > (rule.value as number)) {
            errors.push(rule.message || `${prop} must be at most ${rule.value} characters`);
          }
          break;

        case 'email':
          if (typeof value === 'string' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
            errors.push(rule.message || `${prop} must be a valid email`);
          }
          break;

        case 'min':
          if (typeof value === 'number' && value < (rule.value as number)) {
            errors.push(rule.message || `${prop} must be at least ${rule.value}`);
          }
          break;

        case 'max':
          if (typeof value === 'number' && value > (rule.value as number)) {
            errors.push(rule.message || `${prop} must be at most ${rule.value}`);
          }
          break;
      }
    }
  }

  if (errors.length > 0) {
    throw new ValidationError(errors);
  }
}

// ë©”ì„œë“œ ë°ì½”ë ˆì´í„°
export function Validate(
  target: unknown,
  propertyKey: string,
  descriptor: PropertyDescriptor
): PropertyDescriptor {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: unknown[]) {
    // ê° ì¸ì ê²€ì¦
    for (const arg of args) {
      if (arg && typeof arg === 'object') {
        validate(arg);
      }
    }

    return originalMethod.apply(this, args);
  };

  return descriptor;
}
```

### 4-3. src/decorators/cache.ts
```typescript
interface CacheConfig {
  ttl: number; // Time to live (ms)
}

export function Cache(config: CacheConfig) {
  const cache = new Map<string, { value: unknown; expiry: number }>();

  return function (
    target: unknown,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ): PropertyDescriptor {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: unknown[]) {
      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`;
      const cached = cache.get(cacheKey);
      const now = Date.now();

      if (cached && cached.expiry > now) {
        console.log(`[CACHE] Hit for ${propertyKey}`);
        return cached.value;
      }

      console.log(`[CACHE] Miss for ${propertyKey}`);
      const result = originalMethod.apply(this, args);

      cache.set(cacheKey, {
        value: result,
        expiry: now + config.ttl,
      });

      return result;
    };

    return descriptor;
  };
}
```

### 4-4. src/decorators/index.ts
```typescript
export * from './logging';
export * from './validation';
export * from './cache';
```

---

## ğŸ’¾ Step 5: Repository ê³„ì¸µ (ë°ì´í„° ì ‘ê·¼)

### 5-1. src/repositories/base-repository.ts
```typescript
import { promises as fs } from 'fs';
import path from 'path';
import { ID } from '@types/common';

export abstract class BaseRepository<T extends { id: ID }> {
  protected data: T[] = [];
  protected filePath: string;

  constructor(fileName: string) {
    this.filePath = path.join(process.cwd(), 'data', fileName);
    this.initializeDataFile();
  }

  private async initializeDataFile(): Promise<void> {
    try {
      const dataDir = path.dirname(this.filePath);
      await fs.mkdir(dataDir, { recursive: true });

      try {
        await fs.access(this.filePath);
      } catch {
        await fs.writeFile(this.filePath, JSON.stringify([]), 'utf-8');
      }

      await this.load();
    } catch (error) {
      console.error('Failed to initialize data file:', error);
    }
  }

  protected async load(): Promise<void> {
    try {
      const content = await fs.readFile(this.filePath, 'utf-8');
      this.data = JSON.parse(content);
    } catch (error) {
      console.error('Failed to load data:', error);
      this.data = [];
    }
  }

  protected async save(): Promise<void> {
    try {
      await fs.writeFile(this.filePath, JSON.stringify(this.data, null, 2), 'utf-8');
    } catch (error) {
      console.error('Failed to save data:', error);
      throw error;
    }
  }

  async findAll(): Promise<T[]> {
    await this.load();
    return [...this.data];
  }

  async findById(id: ID): Promise<T | null> {
    await this.load();
    return this.data.find((item) => item.id === id) || null;
  }

  async create(item: T): Promise<T> {
    await this.load();
    this.data.push(item);
    await this.save();
    return item;
  }

  async update(id: ID, updates: Partial<T>): Promise<T | null> {
    await this.load();
    const index = this.data.findIndex((item) => item.id === id);

    if (index === -1) {
      return null;
    }

    this.data[index] = { ...this.data[index], ...updates };
    await this.save();
    return this.data[index];
  }

  async delete(id: ID): Promise<boolean> {
    await this.load();
    const initialLength = this.data.length;
    this.data = this.data.filter((item) => item.id !== id);

    if (this.data.length === initialLength) {
      return false;
    }

    await this.save();
    return true;
  }
}
```

### 5-2. src/repositories/task-repository.ts
```typescript
import { BaseRepository } from './base-repository';
import { Task, TaskStatus } from '@models/task';
import { ID } from '@types/common';

export class TaskRepository extends BaseRepository<Task> {
  constructor() {
    super('tasks.json');
  }

  async findByStatus(status: TaskStatus): Promise<Task[]> {
    await this.load();
    return this.data.filter((task) => task.status === status);
  }

  async findByAssignee(assigneeId: ID): Promise<Task[]> {
    await this.load();
    return this.data.filter((task) => task.assigneeId === assigneeId);
  }

  async findOverdue(): Promise<Task[]> {
    await this.load();
    const now = new Date();
    return this.data.filter(
      (task) =>
        task.dueDate &&
        new Date(task.dueDate) < now &&
        task.status !== 'done' &&
        task.status !== 'cancelled'
    );
  }

  async findByTags(tags: string[]): Promise<Task[]> {
    await this.load();
    return this.data.filter((task) => tags.some((tag) => task.tags.includes(tag)));
  }
}
```

### 5-3. src/repositories/user-repository.ts
```typescript
import { BaseRepository } from './base-repository';
import { User } from '@models/user';

export class UserRepository extends BaseRepository<User> {
  constructor() {
    super('users.json');
  }

  async findByUsername(username: string): Promise<User | null> {
    await this.load();
    return this.data.find((user) => user.username === username) || null;
  }

  async findByEmail(email: string): Promise<User | null> {
    await this.load();
    return this.data.find((user) => user.email === email) || null;
  }

  async findActiveUsers(): Promise<User[]> {
    await this.load();
    return this.data.filter((user) => user.isActive);
  }
}
```

### 5-4. src/repositories/index.ts
```typescript
export * from './base-repository';
export * from './task-repository';
export * from './user-repository';
```


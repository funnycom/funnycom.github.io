---
title: "[TS] 클래스와 타입 - 2"
date: 2025-10-14 22:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, 클래스]
pin: true
math: true
mermaid: true
published: false
---

> **학습 목표**
> - TypeScript에서 클래스를 정의하고 사용할 수 있다
> - 접근 제어자를 이해하고 활용할 수 있다
> - 클래스 상속과 인터페이스 구현을 할 수 있다
> - 추상 클래스를 만들고 사용할 수 있다
> - getter/setter를 활용할 수 있다
> - 정적 멤버와 readonly를 사용할 수 있다

---

## ✏️ 직접 해보기

### 과제 1: 도서관 시스템

클래스를 사용하여 도서관 관리 시스템을 만들어보세요.

**요구사항:**
- Book 클래스: 책 정보 (제목, 저자, ISBN, 대출 상태)
- Library 클래스: 도서관 (책 목록, 책 추가, 대출, 반납)
- 접근 제어자 적절히 사용
- getter/setter 활용

```typescript
// 여기를 완성하세요
```

#### 정답 1: 도서관 시스템

```typescript
// 책 클래스
class Book {
  private _isAvailable: boolean = true;
  private borrowedBy: string | null = null;
  private borrowDate: Date | null = null;
  
  constructor(
    public readonly isbn: string,
    public title: string,
    public author: string,
    public publishYear: number
  ) {}
  
  // getter: 대출 가능 여부
  get isAvailable(): boolean {
    return this._isAvailable;
  }
  
  // 책 정보 반환
  getInfo(): string {
    return \`"\${this.title}" by \${this.author} (\${this.publishYear})\`;
  }
  
  // 대출
  borrow(memberName: string): boolean {
    if (!this._isAvailable) {
      console.log(\`"\${this.title}"은(는) 이미 대출 중입니다.\`);
      return false;
    }
    
    this._isAvailable = false;
    this.borrowedBy = memberName;
    this.borrowDate = new Date();
    console.log(\`"\${this.title}"을(를) \${memberName}님이 대출했습니다.\`);
    return true;
  }
  
  // 반납
  return(): boolean {
    if (this._isAvailable) {
      console.log(\`"\${this.title}"은(는) 대출 중이 아닙니다.\`);
      return false;
    }
    
    const borrower = this.borrowedBy;
    this._isAvailable = true;
    this.borrowedBy = null;
    this.borrowDate = null;
    console.log(\`"\${this.title}"을(를) \${borrower}님이 반납했습니다.\`);
    return true;
  }
  
  // 대출 정보
  getBorrowInfo(): string {
    if (this._isAvailable) {
      return "대출 가능";
    }
    
    const days = Math.floor(
      (Date.now() - this.borrowDate!.getTime()) / (1000 * 60 * 60 * 24)
    );
    return \`대출 중 - \${this.borrowedBy}님 (\${days}일 경과)\`;
  }
}

// 도서관 클래스
class Library {
  private books: Book[] = [];
  private static totalBorrows: number = 0;
  
  constructor(public name: string) {
    console.log(\`\${name} 도서관이 개관했습니다.\`);
  }
  
  // 책 추가
  addBook(book: Book): void {
    this.books.push(book);
    console.log(\`책이 추가되었습니다: \${book.getInfo()}\`);
  }
  
  // ISBN으로 책 찾기
  findBookByIsbn(isbn: string): Book | undefined {
    return this.books.find(book => book.isbn === isbn);
  }
  
  // 제목으로 책 검색
  searchByTitle(title: string): Book[] {
    return this.books.filter(book =>
      book.title.toLowerCase().includes(title.toLowerCase())
    );
  }
  
  // 저자로 책 검색
  searchByAuthor(author: string): Book[] {
    return this.books.filter(book =>
      book.author.toLowerCase().includes(author.toLowerCase())
    );
  }
  
  // 책 대출
  borrowBook(isbn: string, memberName: string): boolean {
    const book = this.findBookByIsbn(isbn);
    
    if (!book) {
      console.log("책을 찾을 수 없습니다.");
      return false;
    }
    
    if (book.borrow(memberName)) {
      Library.totalBorrows++;
      return true;
    }
    
    return false;
  }
  
  // 책 반납
  returnBook(isbn: string): boolean {
    const book = this.findBookByIsbn(isbn);
    
    if (!book) {
      console.log("책을 찾을 수 없습니다.");
      return false;
    }
    
    return book.return();
  }
  
  // 대출 가능한 책 목록
  getAvailableBooks(): Book[] {
    return this.books.filter(book => book.isAvailable);
  }
  
  // 대출 중인 책 목록
  getBorrowedBooks(): Book[] {
    return this.books.filter(book => !book.isAvailable);
  }
  
  // 전체 책 목록 출력
  printAllBooks(): void {
    console.log(\`\n=== \${this.name} 전체 도서 목록 ===\`);
    
    if (this.books.length === 0) {
      console.log("등록된 책이 없습니다.");
      return;
    }
    
    this.books.forEach((book, index) => {
      console.log(\`\${index + 1}. \${book.getInfo()}\`);
      console.log(\`   ISBN: \${book.isbn}\`);
      console.log(\`   상태: \${book.getBorrowInfo()}\`);
    });
  }
  
  // 통계
  printStatistics(): void {
    console.log(\`\n=== \${this.name} 통계 ===\`);
    console.log(\`전체 도서: \${this.books.length}권\`);
    console.log(\`대출 가능: \${this.getAvailableBooks().length}권\`);
    console.log(\`대출 중: \${this.getBorrowedBooks().length}권\`);
    console.log(\`총 대출 횟수: \${Library.totalBorrows}회\`);
  }
}

// 테스트
const library = new Library("시립 중앙 도서관");

// 책 추가
library.addBook(new Book("978-1", "TypeScript 입문", "홍길동", 2024));
library.addBook(new Book("978-2", "JavaScript 완벽 가이드", "김철수", 2023));
library.addBook(new Book("978-3", "클린 코드", "로버트 마틴", 2008));
library.addBook(new Book("978-4", "리팩토링", "마틴 파울러", 2018));

// 전체 목록
library.printAllBooks();

// 책 대출
console.log("\n=== 대출 ===");
library.borrowBook("978-1", "이영희");
library.borrowBook("978-2", "박민수");
library.borrowBook("978-1", "최민호");  // 이미 대출 중

// 검색
console.log("\n=== 검색 ===");
const searchResults = library.searchByTitle("TypeScript");
console.log(\`"TypeScript" 검색 결과: \${searchResults.length}권\`);
searchResults.forEach(book => console.log(\`  - \${book.getInfo()}\`));

// 통계
library.printStatistics();

// 책 반납
console.log("\n=== 반납 ===");
library.returnBook("978-1");

// 최종 통계
library.printStatistics();
library.printAllBooks();
```

---

### 과제 2: 게임 캐릭터 시스템

추상 클래스와 상속을 사용하여 게임 캐릭터 시스템을 만들어보세요.

**요구사항:**
- Character 추상 클래스: 기본 캐릭터 (이름, HP, 공격력, 방어력)
- Warrior, Mage, Archer 클래스: 각 직업별 특수 능력
- 공격, 방어, 특수 스킬 구현
- 레벨업 시스템

```typescript
// 여기를 완성하세요
```

#### 정답 2: 게임 캐릭터 시스템

```typescript
// 추상 캐릭터 클래스
abstract class Character {
  protected maxHp: number;
  protected hp: number;
  protected level: number = 1;
  protected exp: number = 0;
  
  constructor(
    public name: string,
    protected baseAttack: number,
    protected baseDefense: number,
    maxHp: number
  ) {
    this.maxHp = maxHp;
    this.hp = maxHp;
  }
  
  // 추상 메서드: 자식 클래스에서 구현
  abstract useSkill(target: Character): void;
  abstract getClassName(): string;
  
  // 공격
  attack(target: Character): void {
    const damage = Math.max(1, this.baseAttack - target.baseDefense);
    console.log(\`\${this.name}이(가) \${target.name}을(를) 공격합니다!\`);
    target.takeDamage(damage);
  }
  
  // 피해 받기
  takeDamage(damage: number): void {
    this.hp = Math.max(0, this.hp - damage);
    console.log(\`\${this.name}이(가) \${damage}의 피해를 입었습니다. (HP: \${this.hp}/\${this.maxHp})\`);
    
    if (this.hp === 0) {
      console.log(\`💀 \${this.name}이(가) 쓰러졌습니다!\`);
    }
  }
  
  // 회복
  heal(amount: number): void {
    const oldHp = this.hp;
    this.hp = Math.min(this.maxHp, this.hp + amount);
    const actualHeal = this.hp - oldHp;
    console.log(\`\${this.name}이(가) \${actualHeal}만큼 회복했습니다. (HP: \${this.hp}/\${this.maxHp})\`);
  }
  
  // 경험치 획득
  gainExp(amount: number): void {
    this.exp += amount;
    console.log(\`\${this.name}이(가) 경험치 \${amount}을(를) 획득했습니다.\`);
    
    // 레벨업 체크 (100 경험치마다 레벨업)
    while (this.exp >= 100) {
      this.levelUp();
      this.exp -= 100;
    }
  }
  
  // 레벨업
  private levelUp(): void {
    this.level++;
    this.maxHp += 20;
    this.hp = this.maxHp;
    this.baseAttack += 5;
    this.baseDefense += 3;
    
    console.log(\`\n🎉 레벨업! \${this.name}이(가) 레벨 \${this.level}이(가) 되었습니다!\`);
    console.log(\`  HP: \${this.maxHp}, 공격력: \${this.baseAttack}, 방어력: \${this.baseDefense}\n\`);
  }
  
  // 살아있는지 확인
  isAlive(): boolean {
    return this.hp > 0;
  }
  
  // 상태 출력
  printStatus(): void {
    console.log(\`\n[\${this.getClassName()}] \${this.name}\`);
    console.log(\`  레벨: \${this.level}\`);
    console.log(\`  HP: \${this.hp}/\${this.maxHp}\`);
    console.log(\`  공격력: \${this.baseAttack}\`);
    console.log(\`  방어력: \${this.baseDefense}\`);
    console.log(\`  경험치: \${this.exp}/100\`);
  }
}

// 전사 클래스
class Warrior extends Character {
  private rageStacks: number = 0;
  
  constructor(name: string) {
    super(name, 30, 20, 150);
  }
  
  getClassName(): string {
    return "전사";
  }
  
  // 전사 특수 스킬: 분노의 일격
  useSkill(target: Character): void {
    console.log(\`⚔️ \${this.name}이(가) 분노의 일격을 사용합니다!\`);
    const damage = this.baseAttack * 2;
    target.takeDamage(damage);
    this.rageStacks = Math.min(5, this.rageStacks + 1);
    console.log(\`  분노 중첩: \${this.rageStacks}/5\`);
  }
  
  // 전사 특수 능력: 방어 태세
  defend(): void {
    console.log(\`🛡️ \${this.name}이(가) 방어 태세를 취합니다!\`);
    this.baseDefense += 10;
    setTimeout(() => {
      this.baseDefense -= 10;
    }, 1000);
  }
}

// 마법사 클래스
class Mage extends Character {
  private mana: number = 100;
  
  constructor(name: string) {
    super(name, 40, 10, 100);
  }
  
  getClassName(): string {
    return "마법사";
  }
  
  // 마법사 특수 스킬: 파이어볼
  useSkill(target: Character): void {
    if (this.mana < 30) {
      console.log(\`❌ 마나가 부족합니다! (현재: \${this.mana})\`);
      return;
    }
    
    this.mana -= 30;
    console.log(\`🔥 \${this.name}이(가) 파이어볼을 시전합니다! (마나: \${this.mana}/100)\`);
    const damage = this.baseAttack * 1.5;
    target.takeDamage(Math.floor(damage));
  }
  
  // 마나 회복
  restoreMana(amount: number): void {
    this.mana = Math.min(100, this.mana + amount);
    console.log(\`✨ 마나 회복: \${this.mana}/100\`);
  }
}

// 궁수 클래스
class Archer extends Character {
  private arrows: number = 20;
  
  constructor(name: string) {
    super(name, 35, 15, 120);
  }
  
  getClassName(): string {
    return "궁수";
  }
  
  // 궁수 특수 스킬: 관통 화살
  useSkill(target: Character): void {
    if (this.arrows < 3) {
      console.log(\`❌ 화살이 부족합니다! (현재: \${this.arrows})\`);
      return;
    }
    
    this.arrows -= 3;
    console.log(\`🏹 \${this.name}이(가) 관통 화살을 발사합니다! (화살: \${this.arrows}/20)\`);
    const damage = this.baseAttack * 1.3;
    target.takeDamage(Math.floor(damage));
  }
  
  // 화살 재장전
  reloadArrows(): void {
    this.arrows = 20;
    console.log(\`🎯 화살을 재장전했습니다! (\${this.arrows}/20)\`);
  }
}

// 전투 시뮬레이션
console.log("=== 게임 시작 ===\n");

const warrior = new Warrior("용사");
const mage = new Mage("마법사");
const archer = new Archer("궁수");

// 초기 상태
warrior.printStatus();
mage.printStatus();
archer.printStatus();

console.log("\n=== 전투 시작 ===\n");

// 전사 vs 마법사
console.log("--- 1라운드 ---");
warrior.attack(mage);
mage.useSkill(warrior);

console.log("\n--- 2라운드 ---");
warrior.useSkill(mage);
mage.heal(30);

console.log("\n--- 3라운드 ---");
archer.attack(warrior);
archer.useSkill(mage);

// 경험치 획득
console.log("\n=== 경험치 획득 ===");
warrior.gainExp(150);  // 레벨업!
mage.gainExp(80);
archer.gainExp(120);   // 레벨업!

// 최종 상태
console.log("\n=== 최종 상태 ===");
warrior.printStatus();
mage.printStatus();
archer.printStatus();
```

---

### 과제 3: 은행 계좌 시스템

인터페이스와 클래스를 함께 사용하여 은행 계좌 시스템을 만들어보세요.

**요구사항:**
- Account 인터페이스: 계좌 기본 기능 정의
- SavingsAccount, CheckingAccount 클래스 구현
- 예금, 출금, 이자 계산 기능
- 거래 내역 추적

```typescript
// 여기를 완성하세요
```

#### 정답 3: 은행 계좌 시스템

```typescript
// 거래 내역 타입
type TransactionType = "deposit" | "withdraw" | "interest" | "fee";

interface Transaction {
  type: TransactionType;
  amount: number;
  balance: number;
  date: Date;
  description: string;
}

// 계좌 인터페이스
interface Account {
  accountNumber: string;
  owner: string;
  balance: number;
  
  deposit(amount: number): boolean;
  withdraw(amount: number): boolean;
  getBalance(): number;
  printStatement(): void;
}

// 추상 계좌 클래스
abstract class BaseAccount implements Account {
  protected transactions: Transaction[] = [];
  
  constructor(
    public accountNumber: string,
    public owner: string,
    public balance: number = 0
  ) {
    console.log(\`계좌 개설: \${owner} (\${accountNumber})\`);
  }
  
  // 입금
  deposit(amount: number): boolean {
    if (amount <= 0) {
      console.log("❌ 입금액은 0보다 커야 합니다.");
      return false;
    }
    
    this.balance += amount;
    this.addTransaction("deposit", amount, \`입금: \${amount.toLocaleString()}원\`);
    console.log(\`✅ \${amount.toLocaleString()}원 입금 완료. 잔액: \${this.balance.toLocaleString()}원\`);
    return true;
  }
  
  // 출금
  withdraw(amount: number): boolean {
    if (amount <= 0) {
      console.log("❌ 출금액은 0보다 커야 합니다.");
      return false;
    }
    
    if (amount > this.balance) {
      console.log("❌ 잔액이 부족합니다.");
      return false;
    }
    
    this.balance -= amount;
    this.addTransaction("withdraw", amount, \`출금: \${amount.toLocaleString()}원\`);
    console.log(\`✅ \${amount.toLocaleString()}원 출금 완료. 잔액: \${this.balance.toLocaleString()}원\`);
    return true;
  }
  
  // 잔액 조회
  getBalance(): number {
    return this.balance;
  }
  
  // 거래 내역 추가
  protected addTransaction(type: TransactionType, amount: number, description: string): void {
    this.transactions.push({
      type,
      amount,
      balance: this.balance,
      date: new Date(),
      description
    });
  }
  
  // 거래 내역 출력
  printStatement(): void {
    console.log(\`\n=== 계좌 명세서 ===\`);
    console.log(\`계좌번호: \${this.accountNumber}\`);
    console.log(\`예금주: \${this.owner}\`);
    console.log(\`계좌 종류: \${this.getAccountType()}\`);
    console.log(\`현재 잔액: \${this.balance.toLocaleString()}원\`);
    
    if (this.transactions.length === 0) {
      console.log("\n거래 내역이 없습니다.");
      return;
    }
    
    console.log(\`\n거래 내역 (최근 \${Math.min(10, this.transactions.length)}건):\`);
    const recentTransactions = this.transactions.slice(-10);
    
    recentTransactions.forEach((tx, index) => {
      const sign = tx.type === "deposit" || tx.type === "interest" ? "+" : "-";
      console.log(\`\${index + 1}. [\${tx.date.toLocaleString()}] \${tx.description}\`);
      console.log(\`   \${sign}\${tx.amount.toLocaleString()}원 → 잔액: \${tx.balance.toLocaleString()}원\`);
    });
  }
  
  // 계좌 타입 (자식 클래스에서 구현)
  abstract getAccountType(): string;
}

// 저축 예금 계좌
class SavingsAccount extends BaseAccount {
  private static readonly INTEREST_RATE = 0.03;  // 3% 이자율
  private static readonly MIN_BALANCE = 10000;   // 최소 잔액
  
  constructor(accountNumber: string, owner: string, initialBalance: number = 0) {
    super(accountNumber, owner, initialBalance);
  }
  
  getAccountType(): string {
    return "저축 예금";
  }
  
  // 이자 지급
  applyInterest(): void {
    if (this.balance < SavingsAccount.MIN_BALANCE) {
      console.log(\`❌ 최소 잔액(\${SavingsAccount.MIN_BALANCE.toLocaleString()}원) 미만으로 이자가 지급되지 않습니다.\`);
      return;
    }
    
    const interest = Math.floor(this.balance * SavingsAccount.INTEREST_RATE);
    this.balance += interest;
    this.addTransaction("interest", interest, \`이자 지급 (\${(SavingsAccount.INTEREST_RATE * 100).toFixed(1)}%)\`);
    console.log(\`💰 이자 \${interest.toLocaleString()}원 지급됨. 잔액: \${this.balance.toLocaleString()}원\`);
  }
  
  // 출금 제한 (최소 잔액 유지)
  withdraw(amount: number): boolean {
    if (this.balance - amount < SavingsAccount.MIN_BALANCE) {
      console.log(\`❌ 출금 후 잔액이 최소 잔액(\${SavingsAccount.MIN_BALANCE.toLocaleString()}원) 미만이 될 수 없습니다.\`);
      return false;
    }
    
    return super.withdraw(amount);
  }
}

// 입출금 자유 계좌
class CheckingAccount extends BaseAccount {
  private static readonly MONTHLY_FEE = 1000;    // 월 수수료
  private transactionCount: number = 0;
  private static readonly FREE_TRANSACTIONS = 5;  // 무료 거래 횟수
  private static readonly TRANSACTION_FEE = 500;  // 거래 수수료
  
  constructor(accountNumber: string, owner: string, initialBalance: number = 0) {
    super(accountNumber, owner, initialBalance);
  }
  
  getAccountType(): string {
    return "입출금 자유";
  }
  
  // 입금 (거래 수수료 적용)
  deposit(amount: number): boolean {
    const result = super.deposit(amount);
    if (result) {
      this.applyTransactionFee();
    }
    return result;
  }
  
  // 출금 (거래 수수료 적용)
  withdraw(amount: number): boolean {
    const result = super.withdraw(amount);
    if (result) {
      this.applyTransactionFee();
    }
    return result;
  }
  
  // 거래 수수료 적용
  private applyTransactionFee(): void {
    this.transactionCount++;
    
    if (this.transactionCount > CheckingAccount.FREE_TRANSACTIONS) {
      this.balance -= CheckingAccount.TRANSACTION_FEE;
      this.addTransaction("fee", CheckingAccount.TRANSACTION_FEE, "거래 수수료");
      console.log(\`  💳 거래 수수료 \${CheckingAccount.TRANSACTION_FEE}원 차감\`);
    }
  }
  
  // 월 수수료 부과
  applyMonthlyFee(): void {
    this.balance -= CheckingAccount.MONTHLY_FEE;
    this.addTransaction("fee", CheckingAccount.MONTHLY_FEE, "월 계좌 유지 수수료");
    console.log(\`💳 월 수수료 \${CheckingAccount.MONTHLY_FEE.toLocaleString()}원 차감됨. 잔액: \${this.balance.toLocaleString()}원\`);
    
    // 거래 횟수 초기화
    this.transactionCount = 0;
  }
}

// 테스트
console.log("=== 은행 계좌 시스템 ===\n");

// 저축 예금 계좌
const savings = new SavingsAccount("001-1234-5678", "홍길동", 100000);
console.log();

savings.deposit(50000);
savings.withdraw(20000);
savings.applyInterest();
savings.printStatement();

// 입출금 자유 계좌
console.log("\n");
const checking = new CheckingAccount("002-9876-5432", "김철수", 50000);
console.log();

checking.deposit(10000);
checking.withdraw(5000);
checking.deposit(10000);  // 3번째 거래
checking.deposit(10000);  // 4번째 거래
checking.deposit(10000);  // 5번째 거래
checking.deposit(10000);  // 6번째 거래 (수수료 부과 시작)
checking.deposit(10000);  // 7번째 거래

console.log("\n--- 월말 ---");
checking.applyMonthlyFee();

checking.printStatement();
```

---

## ✅ 체크포인트

이번 챕터를 마치기 전에 다음 항목을 확인해보세요:

- [ ] 클래스를 정의하고 인스턴스를 생성할 수 있다
- [ ] 생성자를 사용하여 초기값을 설정할 수 있다
- [ ] public, private, protected 접근 제어자를 이해한다
- [ ] 생성자 매개변수에 접근 제어자를 사용할 수 있다
- [ ] 클래스 상속을 구현할 수 있다
- [ ] super 키워드를 올바르게 사용할 수 있다
- [ ] 추상 클래스를 만들고 활용할 수 있다
- [ ] 인터페이스를 구현할 수 있다
- [ ] getter/setter를 정의하고 사용할 수 있다
- [ ] 정적 멤버를 이해하고 활용할 수 있다
- [ ] readonly 속성을 사용할 수 있다

### 자가 진단 퀴즈

**1. 다음 중 올바른 클래스 정의는?**

```typescript
A. class Person { name: string; }
B. class Person { constructor(name) { this.name = name; } }
C. class Person { constructor(public name: string) {} }
D. class Person { private name; }
```

**정답: C**

TypeScript에서는 속성의 타입을 명시해야 하며, 생성자 매개변수에 접근 제어자를 사용하면 자동으로 속성이 선언됩니다.

---

**2. private 속성에 대한 설명으로 올바른 것은?**

A. 어디서든 접근 가능  
B. 클래스 내부에서만 접근 가능  
C. 자식 클래스에서도 접근 가능  
D. 같은 파일 내에서만 접근 가능

**정답: B**

`private` 속성은 클래스 내부에서만 접근할 수 있습니다. 자식 클래스에서도 접근할 수 없습니다.

---

**3. 추상 클래스에 대한 설명으로 올바른 것은?**

A. 직접 인스턴스를 생성할 수 있다  
B. 추상 메서드만 가질 수 있다  
C. 상속받은 클래스는 추상 메서드를 반드시 구현해야 한다  
D. 인터페이스와 완전히 같다

**정답: C**

추상 클래스의 추상 메서드는 자식 클래스에서 반드시 구현해야 합니다. 추상 클래스는 직접 인스턴스를 생성할 수 없으며, 일반 메서드도 가질 수 있습니다.

---

**4. super 키워드의 역할은?**

A. 현재 클래스를 참조  
B. 부모 클래스를 참조  
C. 전역 객체를 참조  
D. static 멤버를 참조

**정답: B**

`super`는 부모 클래스를 참조할 때 사용합니다. `super()`로 부모 생성자를 호출하거나, `super.method()`로 부모 메서드를 호출할 수 있습니다.

---

**5. 정적(static) 멤버에 대한 설명으로 올바른 것은?**

A. 인스턴스마다 다른 값을 가진다  
B. 클래스 자체에 속하며 인스턴스 생성 없이 사용 가능  
C. private으로만 선언 가능  
D. 상속되지 않는다

**정답: B**

정적 멤버는 클래스 자체에 속하며, 인스턴스를 생성하지 않고도 `ClassName.member` 형태로 접근할 수 있습니다.

---

## 💡 학습 팁

### 클래스 설계 팁

**1. 단일 책임 원칙**

하나의 클래스는 하나의 책임만 가져야 합니다.

```typescript
// ❌ 너무 많은 책임
class User {
  login() {}
  logout() {}
  sendEmail() {}
  validateData() {}
  saveToDatabase() {}
}

// ✅ 책임 분리
class User {
  login() {}
  logout() {}
}

class EmailService {
  sendEmail() {}
}

class Validator {
  validateData() {}
}

class UserRepository {
  saveToDatabase() {}
}
```

**2. 적절한 접근 제어자 사용**

- 기본은 `private`로 시작
- 필요한 경우에만 `protected`나 `public`으로 변경
- 외부에서 접근해야 하는 것만 `public`

```typescript
class BankAccount {
  private balance: number = 0;      // 외부 접근 차단
  protected accountType: string;    // 자식 클래스에서 사용
  public owner: string;             // 외부에서 접근 필요
}
```

**3. 상속보다 컴포지션 우선**

상속은 강한 결합을 만들므로, 가능하면 컴포지션(조합)을 사용하세요.

```typescript
// 상속 (강한 결합)
class Car extends Engine {
  // Car가 Engine에 강하게 의존
}

// 컴포지션 (느슨한 결합) - 더 권장됨
class Car {
  private engine: Engine;  // Engine을 포함
  
  constructor(engine: Engine) {
constructor(engine: Engine) {
    this.engine = engine;
  }
}
```

**4. 의미있는 이름 사용**

클래스, 메서드, 속성의 이름은 그 역할을 명확히 나타내야 합니다.

```typescript
// ❌ 불명확한 이름
class Data {
  private val: number;
  process() {}
}

// ✅ 명확한 이름
class UserAccount {
  private balance: number;
  calculateInterest() {}
}
```

### 일반적인 실수와 해결법

**실수 1: super() 호출 누락**

```typescript
// ❌ 에러
class Child extends Parent {
  constructor(name: string, age: number) {
    this.age = age;  // 에러! super()를 먼저 호출해야 함
    super(name);
  }
}

// ✅ 올바름
class Child extends Parent {
  constructor(name: string, age: number) {
    super(name);  // 먼저 호출
    this.age = age;
  }
}
```

**실수 2: private 속성에 외부 접근 시도**

```typescript
class Person {
  private age: number = 25;
}

const person = new Person();
// console.log(person.age);  // ❌ 에러!

// ✅ getter를 통해 접근
class Person {
  private _age: number = 25;
  
  get age(): number {
    return this._age;
  }
}
```

**실수 3: 추상 메서드 구현 누락**

```typescript
abstract class Animal {
  abstract makeSound(): void;
}

// ❌ 에러 - makeSound를 구현하지 않음
class Dog extends Animal {
}

// ✅ 올바름
class Dog extends Animal {
  makeSound(): void {
    console.log("멍멍!");
  }
}
```

### AI 활용 팁

**효과적인 질문 방법:**

```
1. "클래스 상속 예제를 보여줘"
   → 구체적인 개념 요청

2. "이 클래스 설계를 개선해줘: [코드]"
   → 코드와 함께 요청

3. "추상 클래스와 인터페이스를 언제 사용해야 하나요?"
   → 사용 시점 질문

4. "private과 protected의 차이를 예제로 설명해줘"
   → 비교 요청
```

---

## 🎯 다음 단계

**축하합니다! TypeScript의 모든 핵심 개념을 완료했습니다! 🎉**

지금까지 배운 내용:
- Chapter 6: TypeScript 소개
- Chapter 7: 기본 타입 시스템
- Chapter 8: 함수 타입
- Chapter 9: 인터페이스와 타입 별칭
- Chapter 10: 제네릭
- Chapter 11: 클래스와 타입

**이제 무엇을 해야 할까요?**

### 1. 실전 프로젝트 만들기

배운 내용을 종합하여 실전 프로젝트를 만들어보세요:

**프로젝트 아이디어:**

- **Todo 앱**: 클래스, 인터페이스, 제네릭 활용
- **쇼핑몰**: 상품, 장바구니, 주문 시스템 구현
- **블로그 시스템**: 게시글, 댓글, 사용자 관리
- **게임**: 캐릭터, 아이템, 전투 시스템
- **도서관 관리**: 책, 회원, 대출 시스템

**프로젝트 시작 템플릿:**

```typescript
// 1. 인터페이스로 구조 정의
interface User {
  id: number;
  name: string;
  email: string;
}

interface Product {
  id: number;
  name: string;
  price: number;
}

// 2. 클래스로 비즈니스 로직 구현
class UserService {
  private users: User[] = [];
  
  createUser(user: User): void {
    this.users.push(user);
  }
  
  findUser(id: number): User | undefined {
    return this.users.find(u => u.id === id);
  }
}

// 3. 제네릭으로 재사용 가능한 유틸리티
class Repository<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  getAll(): T[] {
    return [...this.items];
  }
}

// 4. 실행
const userRepo = new Repository<User>();
const productRepo = new Repository<Product>();
```

### 2. React와 TypeScript

React와 TypeScript를 함께 사용하면 더욱 강력한 웹 애플리케이션을 만들 수 있습니다.

```typescript
// React 컴포넌트에 타입 적용
interface Props {
  name: string;
  age: number;
}

function UserCard({ name, age }: Props) {
  return (
    <div>
      <h2>{name}</h2>
      <p>나이: {age}세</p>
    </div>
  );
}
```

### 3. 고급 TypeScript 학습

더 깊이 있는 TypeScript 학습:

- **유틸리티 타입**: Partial, Pick, Omit, Record 등
- **조건부 타입**: Conditional Types
- **매핑 타입**: Mapped Types
- **타입 가드 고급**: Type Guards
- **모듈 시스템**: ES Modules, CommonJS
- **데코레이터**: Decorators

### 4. 실무 도구 익히기

- **ESLint**: 코드 품질 도구
- **Prettier**: 코드 포맷터
- **Jest**: 테스트 프레임워크
- **Webpack/Vite**: 빌드 도구

---

## 📚 복습 체크리스트

TypeScript를 완전히 마스터하기 위한 복습 체크리스트:

### 기초 (Chapter 6-7)
- [ ] TypeScript가 무엇이고 왜 사용하는지 설명할 수 있다
- [ ] 기본 타입을 모두 사용할 수 있다
- [ ] 변수와 상수에 타입을 지정할 수 있다

### 타입 시스템 (Chapter 7-9)
- [ ] 배열, 튜플, 객체 타입을 정의할 수 있다
- [ ] 유니온과 교차 타입을 활용할 수 있다
- [ ] 인터페이스와 타입 별칭을 적절히 선택할 수 있다
- [ ] 인터페이스를 확장할 수 있다

### 함수 (Chapter 8)
- [ ] 함수의 매개변수와 반환 타입을 지정할 수 있다
- [ ] 선택적 매개변수와 기본 매개변수를 사용할 수 있다
- [ ] 함수 오버로딩을 구현할 수 있다
- [ ] 콜백 함수와 고차 함수에 타입을 지정할 수 있다

### 제네릭 (Chapter 10)
- [ ] 제네릭 함수를 작성할 수 있다
- [ ] 제네릭 인터페이스와 클래스를 만들 수 있다
- [ ] 제네릭 제약조건을 사용할 수 있다
- [ ] keyof를 활용할 수 있다

### 클래스 (Chapter 11)
- [ ] 클래스를 정의하고 인스턴스를 생성할 수 있다
- [ ] 접근 제어자를 적절히 사용할 수 있다
- [ ] 클래스 상속을 구현할 수 있다
- [ ] 추상 클래스를 만들고 활용할 수 있다
- [ ] 인터페이스를 구현할 수 있다
- [ ] getter/setter를 활용할 수 있다

---

## 🎓 최종 프로젝트 아이디어

배운 모든 내용을 활용하여 다음 중 하나의 프로젝트를 만들어보세요:

### 1. 작업 관리 시스템 (Task Management)

```typescript
// 요구사항:
- Task, Project, User 클래스
- 우선순위, 마감일, 상태 관리
- 필터링, 정렬 기능
- 통계 및 리포트
```

### 2. 온라인 쇼핑몰

```typescript
// 요구사항:
- Product, Cart, Order 클래스
- 카테고리, 검색, 필터
- 장바구니 관리
- 주문 및 결제 시스템
```

### 3. 학생 성적 관리 시스템

```typescript
// 요구사항:
- Student, Course, Grade 클래스
- 성적 입력 및 계산
- 통계 및 순위
- 성적표 출력
```

### 4. 도서 대여 시스템

```typescript
// 요구사항:
- Book, Member, Loan 클래스
- 책 검색 및 대여
- 연체 관리
- 대여 통계
```

---

**🎊 TypeScript 마스터 과정을 완료했습니다!**

이제 여러분은:
- ✅ TypeScript의 모든 핵심 개념을 이해했습니다
- ✅ 타입 안전한 코드를 작성할 수 있습니다
- ✅ 객체지향 프로그래밍을 TypeScript로 구현할 수 있습니다
- ✅ 실전 프로젝트를 시작할 준비가 되었습니다

**자신감을 가지고 실전 프로젝트를 만들어보세요! 💪**

궁금한 점이 있거나 막히는 부분이 있다면:
1. 이전 챕터를 복습하세요
2. 공식 문서를 참고하세요 (https://www.typescriptlang.org/)
3. AI에게 질문하세요
4. 작은 예제부터 차근차근 연습하세요

**화이팅! 🚀**

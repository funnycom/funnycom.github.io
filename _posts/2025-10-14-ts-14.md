---
title: "[TS] 클래스와 타입 - 1"
date: 2025-10-14 18:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, 클래스]
pin: true
math: true
mermaid: true
published: false
---

> **학습 목표**
> - TypeScript에서 클래스를 정의하고 사용할 수 있다
> - 접근 제어자를 이해하고 활용할 수 있다
> - 클래스 상속과 인터페이스 구현을 할 수 있다
> - 추상 클래스를 만들고 사용할 수 있다
> - getter/setter를 활용할 수 있다
> - 정적 멤버와 readonly를 사용할 수 있다

---

(클래스 파트와 인터페이스/타입별칭 위치 바뀜)

## 클래스 기초

클래스는 객체를 만들기 위한 "설계도"입니다. 같은 구조를 가진 여러 객체를 만들어야 할 때 클래스를 사용하면 코드를 체계적으로 관리할 수 있습니다.

### 클래스 정의하기

TypeScript의 클래스는 JavaScript 클래스와 비슷하지만, 타입을 지정할 수 있어 더 안전합니다.

```typescript
// 기본 클래스 정의
class Person {
  // 속성 (Properties)
  name: string;
  age: number;
  
  // 생성자 (Constructor)
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  // 메서드 (Methods)
  greet(): void {
    console.log(\`안녕하세요, 저는 \${this.name}입니다.\`);
  }
  
  introduce(): string {
    return \`저는 \${this.age}살 \${this.name}입니다.\`;
  }
}

// 클래스로 객체 생성
const person1 = new Person("홍길동", 25);
const person2 = new Person("김철수", 30);

person1.greet();  // 안녕하세요, 저는 홍길동입니다.
console.log(person2.introduce());  // 저는 30살 김철수입니다.
```

**시각적 이해:**

```
Person 클래스 (설계도)
┌─────────────────────┐
│   Properties        │
│   - name: string    │
│   - age: number     │
├─────────────────────┤
│   Constructor       │
│   - Person(...)     │
├─────────────────────┤
│   Methods           │
│   - greet()         │
│   - introduce()     │
└─────────────────────┘
         ↓
    new Person(...)
         ↓
┌──────────────┐  ┌──────────────┐
│   person1    │  │   person2    │
│ name: "홍길동"│  │ name: "김철수"│
│ age: 25      │  │ age: 30      │
└──────────────┘  └──────────────┘
```

### 생성자 (Constructor)

생성자는 객체가 생성될 때 자동으로 호출되는 특별한 메서드입니다. 주로 초기값을 설정하는 데 사용합니다.

```typescript
class Product {
  id: number;
  name: string;
  price: number;
  inStock: boolean;
  
  constructor(id: number, name: string, price: number) {
    this.id = id;
    this.name = name;
    this.price = price;
    this.inStock = true;  // 기본값 설정
    
    console.log(\`상품이 생성되었습니다: \${name}\`);
  }
  
  getInfo(): string {
    return \`[\${this.id}] \${this.name} - \${this.price}원\`;
  }
}

const laptop = new Product(1, "노트북", 1000000);
console.log(laptop.getInfo());  // [1] 노트북 - 1000000원

const mouse = new Product(2, "마우스", 30000);
console.log(mouse.getInfo());   // [2] 마우스 - 30000원
```

**실전 예제: 은행 계좌**

```typescript
class BankAccount {
  accountNumber: string;
  owner: string;
  balance: number;
  
  constructor(accountNumber: string, owner: string, initialBalance: number = 0) {
    this.accountNumber = accountNumber;
    this.owner = owner;
    this.balance = initialBalance;
    
    console.log(\`계좌가 개설되었습니다: \${owner} (\${accountNumber})\`);
  }
  
  deposit(amount: number): void {
    if (amount <= 0) {
      console.log("입금액은 0보다 커야 합니다.");
      return;
    }
    
    this.balance += amount;
    console.log(\`\${amount}원이 입금되었습니다. 잔액: \${this.balance}원\`);
  }
  
  withdraw(amount: number): boolean {
    if (amount <= 0) {
      console.log("출금액은 0보다 커야 합니다.");
      return false;
    }
    
    if (amount > this.balance) {
      console.log("잔액이 부족합니다.");
      return false;
    }
    
    this.balance -= amount;
    console.log(\`\${amount}원이 출금되었습니다. 잔액: \${this.balance}원\`);
    return true;
  }
  
  getBalance(): number {
    return this.balance;
  }
  
  printStatement(): void {
    console.log("\n=== 계좌 정보 ===");
    console.log(\`계좌번호: \${this.accountNumber}\`);
    console.log(\`예금주: \${this.owner}\`);
    console.log(\`잔액: \${this.balance.toLocaleString()}원\`);
  }
}

// 사용 예시
const myAccount = new BankAccount("123-456-789", "홍길동", 10000);
myAccount.deposit(50000);
myAccount.withdraw(20000);
myAccount.printStatement();
```

---

## 접근 제어자 (Access Modifiers)

접근 제어자는 클래스의 속성과 메서드에 대한 접근 권한을 제어합니다. TypeScript는 세 가지 접근 제어자를 제공합니다.

### public (공개)

`public`은 어디서든 접근 가능합니다. 기본값이므로 생략 가능합니다.

```typescript
class Student {
  public name: string;  // public 명시
  age: number;          // public (기본값)
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  public introduce(): void {
    console.log(\`저는 \${this.name}입니다.\`);
  }
}

const student = new Student("홍길동", 20);
console.log(student.name);  // ✅ OK - public이므로 접근 가능
student.introduce();        // ✅ OK
```

### private (비공개)

`private`는 클래스 내부에서만 접근 가능합니다. 외부에서는 접근할 수 없습니다.

```typescript
class BankAccount {
  private balance: number;  // private 속성
  
  constructor(initialBalance: number) {
    this.balance = initialBalance;
  }
  
  deposit(amount: number): void {
    this.balance += amount;  // ✅ 클래스 내부에서는 접근 가능
  }
  
  getBalance(): number {
    return this.balance;  // ✅ 클래스 내부에서는 접근 가능
  }
}

const account = new BankAccount(10000);
// console.log(account.balance);  // ❌ 에러! private이므로 외부에서 접근 불가
console.log(account.getBalance());  // ✅ OK - 메서드를 통해 접근
```

**왜 private을 사용할까요?**

private을 사용하면 데이터를 보호하고, 잘못된 값이 들어가는 것을 방지할 수 있습니다.

```typescript
class User {
  private password: string;
  
  constructor(password: string) {
    this.password = password;
  }
  
  // 비밀번호 검증 후 변경
  changePassword(oldPassword: string, newPassword: string): boolean {
    if (oldPassword !== this.password) {
      console.log("현재 비밀번호가 일치하지 않습니다.");
      return false;
    }
    
    if (newPassword.length < 8) {
      console.log("새 비밀번호는 8자 이상이어야 합니다.");
      return false;
    }
    
    this.password = newPassword;
    console.log("비밀번호가 변경되었습니다.");
    return true;
  }
  
  // 비밀번호 확인
  checkPassword(password: string): boolean {
    return this.password === password;
  }
}

const user = new User("password123");
// user.password = "123";  // ❌ 에러! private이므로 직접 변경 불가
user.changePassword("password123", "newpass12345");  // ✅ 메서드를 통해 안전하게 변경
```

### protected (보호됨)

`protected`는 클래스 내부와 상속받은 자식 클래스에서만 접근 가능합니다.

```typescript
class Animal {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  protected makeSound(): void {
    console.log("동물 소리!");
  }
}

class Dog extends Animal {
  bark(): void {
    console.log(\`\${this.name}이(가) 짖습니다!\`);  // ✅ protected이므로 접근 가능
    this.makeSound();  // ✅ protected이므로 접근 가능
  }
}

const dog = new Dog("멍멍이");
dog.bark();
// console.log(dog.name);  // ❌ 에러! protected는 외부에서 접근 불가
```

**접근 제어자 비교:**

```
┌─────────────────────────────────────────────┐
│           접근 가능한 위치                   │
├────────────┬──────┬──────┬─────────────────┤
│ 제어자      │ 클래스│ 자식 │ 외부(인스턴스)  │
│            │ 내부  │ 클래스│                │
├────────────┼──────┼──────┼─────────────────┤
│ public     │  ✅  │  ✅  │      ✅         │
│ protected  │  ✅  │  ✅  │      ❌         │
│ private    │  ✅  │  ❌  │      ❌         │
└────────────┴──────┴──────┴─────────────────┘
```

**실전 예제: 직원 관리 시스템**

```typescript
class Employee {
  public name: string;
  private salary: number;
  protected department: string;
  
  constructor(name: string, salary: number, department: string) {
    this.name = name;
    this.salary = salary;
    this.department = department;
  }
  
  // public 메서드 - 누구나 호출 가능
  public introduce(): void {
    console.log(\`안녕하세요, \${this.name}입니다.\`);
  }
  
  // private 메서드 - 클래스 내부에서만 사용
  private calculateTax(): number {
    return this.salary * 0.1;
  }
  
  // public 메서드를 통해 간접적으로 private 데이터 제공
  public getNetSalary(): number {
    return this.salary - this.calculateTax();
  }
  
  // protected 메서드 - 자식 클래스에서도 사용 가능
  protected getBasicInfo(): string {
    return \`\${this.name} - \${this.department}\`;
  }
}

class Manager extends Employee {
  private teamSize: number;
  
  constructor(name: string, salary: number, department: string, teamSize: number) {
    super(name, salary, department);
    this.teamSize = teamSize;
  }
  
  public showInfo(): void {
    // protected 멤버에 접근 가능
    console.log(this.getBasicInfo());
    console.log(\`관리 인원: \${this.teamSize}명\`);
    
    // this.salary  // ❌ 에러! private는 부모 클래스에서만 접근 가능
  }
}

const emp = new Employee("홍길동", 5000000, "개발팀");
emp.introduce();  // ✅ public 메서드
console.log(\`실수령액: \${emp.getNetSalary().toLocaleString()}원\`);
// console.log(emp.salary);  // ❌ 에러! private

const mgr = new Manager("김팀장", 8000000, "개발팀", 5);
mgr.showInfo();
```

### 생성자 매개변수 접근 제어자

TypeScript는 생성자 매개변수에 접근 제어자를 붙이면 자동으로 속성을 선언하고 초기화합니다. 이를 통해 코드를 간결하게 만들 수 있습니다.

```typescript
// 일반적인 방법 (긴 코드)
class Person1 {
  name: string;
  age: number;
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// 간결한 방법 (생성자 매개변수에 접근 제어자 사용)
class Person2 {
  constructor(
    public name: string,
    public age: number
  ) {
    // 자동으로 this.name = name, this.age = age 실행됨
  }
}

// 결과는 동일
const person1 = new Person1("홍길동", 25);
const person2 = new Person2("김철수", 30);

console.log(person1.name);  // "홍길동"
console.log(person2.name);  // "김철수"
```

**실전 예제:**

```typescript
class Product {
  constructor(
    public id: number,
    public name: string,
    public price: number,
    private stock: number = 0
  ) {
    console.log(\`상품 생성: \${name}\`);
  }
  
  getStock(): number {
    return this.stock;
  }
  
  addStock(quantity: number): void {
    this.stock += quantity;
    console.log(\`재고 추가: +\${quantity}개 (현재: \${this.stock}개)\`);
  }
  
  sell(quantity: number): boolean {
    if (quantity > this.stock) {
      console.log("재고가 부족합니다.");
      return false;
    }
    
    this.stock -= quantity;
    console.log(\`판매 완료: \${quantity}개 (남은 재고: \${this.stock}개)\`);
    return true;
  }
}

const laptop = new Product(1, "노트북", 1000000, 10);
console.log(laptop.name);   // ✅ public
console.log(laptop.price);  // ✅ public
// console.log(laptop.stock);  // ❌ private
console.log(laptop.getStock());  // ✅ 메서드를 통해 접근

laptop.sell(3);
laptop.addStock(5);
```

---

## 클래스 상속 (Inheritance)

상속을 사용하면 기존 클래스의 기능을 물려받아 새로운 클래스를 만들 수 있습니다. 코드 재사용성이 높아지고 계층 구조를 표현할 수 있습니다.

### 기본 상속

`extends` 키워드를 사용하여 클래스를 상속받습니다.

```typescript
// 부모 클래스 (Parent/Base/Super Class)
class Animal {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  move(distance: number): void {
    console.log(\`\${this.name}이(가) \${distance}m 이동했습니다.\`);
  }
  
  makeSound(): void {
    console.log("동물 소리!");
  }
}

// 자식 클래스 (Child/Derived/Sub Class)
class Dog extends Animal {
  breed: string;
  
  constructor(name: string, breed: string) {
    super(name);  // 부모 클래스의 생성자 호출
    this.breed = breed;
  }
  
  // 메서드 오버라이딩 (부모의 메서드를 재정의)
  makeSound(): void {
    console.log("멍멍!");
  }
  
  // 자식 클래스만의 새로운 메서드
  fetch(): void {
    console.log(\`\${this.name}이(가) 공을 물어옵니다.\`);
  }
}

class Cat extends Animal {
  constructor(name: string) {
    super(name);
  }
  
  makeSound(): void {
    console.log("야옹~");
  }
  
  scratch(): void {
    console.log(\`\${this.name}이(가) 스크래치합니다.\`);
  }
}

// 사용
const dog = new Dog("멍멍이", "골든 리트리버");
dog.move(10);        // 부모로부터 상속받은 메서드
dog.makeSound();     // 오버라이딩된 메서드
dog.fetch();         // 자식 클래스의 메서드

const cat = new Cat("야옹이");
cat.move(5);
cat.makeSound();
cat.scratch();
```

**시각적 이해:**

```
        Animal (부모)
     ┌────────────────┐
     │ name: string   │
     │ move()         │
     │ makeSound()    │
     └────────────────┘
            ↑ ↑
      상속   │ │  상속
    ┌───────┘ └───────┐
    │                 │
  Dog (자식)      Cat (자식)
┌──────────────┐  ┌──────────────┐
│ breed        │  │ makeSound()  │
│ makeSound()  │  │ scratch()    │
│ fetch()      │  │              │
└──────────────┘  └──────────────┘

Dog와 Cat은 Animal의 모든 기능을 가지며,
추가로 자신만의 기능도 가짐
```

### super 키워드

`super`는 부모 클래스를 참조할 때 사용합니다.

```typescript
class Vehicle {
  constructor(public brand: string, public year: number) {
    console.log(\`차량 생성: \${brand}\`);
  }
  
  start(): void {
    console.log("시동을 겁니다.");
  }
}

class Car extends Vehicle {
  constructor(brand: string, year: number, public model: string) {
    super(brand, year);  // 부모 생성자 호출 (필수!)
    console.log(\`모델: \${model}\`);
  }
  
  start(): void {
    super.start();  // 부모의 start() 호출
    console.log("자동차가 출발합니다.");
  }
  
  showInfo(): void {
    console.log(\`\${this.brand} \${this.model} (\${this.year}년형)\`);
  }
}

const myCar = new Car("현대", 2024, "아반떼");
myCar.start();
myCar.showInfo();
```

**주의사항:**

자식 클래스에서 생성자를 정의하면 반드시 `super()`를 먼저 호출해야 합니다.

```typescript
class Parent {
  constructor(public name: string) {}
}

class Child extends Parent {
  constructor(name: string, public age: number) {
    // super(name);  // ❌ 이것을 먼저 호출하지 않으면 에러!
    // this.age = age;  // ❌ super() 전에 this 사용 불가
    
    super(name);  // ✅ 반드시 먼저 호출
    this.age = age;  // ✅ super() 이후에 this 사용 가능
  }
}
```

**실전 예제: 직원 계층 구조**

```typescript
// 기본 직원 클래스
class Employee {
  constructor(
    public name: string,
    protected baseSalary: number
  ) {}
  
  calculateSalary(): number {
    return this.baseSalary;
  }
  
  getInfo(): string {
    return \`\${this.name} - 급여: \${this.calculateSalary().toLocaleString()}원\`;
  }
}

// 정규직
class FullTimeEmployee extends Employee {
  constructor(
    name: string,
    baseSalary: number,
    private bonus: number
  ) {
    super(name, baseSalary);
  }
  
  calculateSalary(): number {
    return this.baseSalary + this.bonus;
  }
}

// 계약직
class ContractEmployee extends Employee {
  constructor(
    name: string,
    private hourlyRate: number,
    private hoursWorked: number
  ) {
    super(name, 0);  // baseSalary는 0으로 설정
  }
  
  calculateSalary(): number {
    return this.hourlyRate * this.hoursWorked;
  }
  
  getInfo(): string {
    return \`\${this.name} (계약직) - 시급: \${this.hourlyRate}원, 근무시간: \${this.hoursWorked}시간\`;
  }
}

// 관리자
class Manager extends FullTimeEmployee {
  constructor(
    name: string,
    baseSalary: number,
    bonus: number,
    private teamSize: number
  ) {
    super(name, baseSalary, bonus);
  }
  
  calculateSalary(): number {
    const basePay = super.calculateSalary();  // 부모의 급여 계산 사용
    const managementBonus = this.teamSize * 100000;  // 팀원 수당
    return basePay + managementBonus;
  }
  
  getInfo(): string {
    return \`\${super.getInfo()} (팀원 \${this.teamSize}명 관리)\`;
  }
}

// 사용 예시
const fullTime = new FullTimeEmployee("홍길동", 3000000, 500000);
console.log(fullTime.getInfo());

const contract = new ContractEmployee("김철수", 15000, 160);
console.log(contract.getInfo());
console.log(\`급여: \${contract.calculateSalary().toLocaleString()}원\`);

const manager = new Manager("박팀장", 4000000, 1000000, 5);
console.log(manager.getInfo());
```

---

## 추상 클래스 (Abstract Class)

추상 클래스는 직접 인스턴스를 만들 수 없고, 상속받아서만 사용할 수 있는 클래스입니다. 공통 기능을 정의하고, 자식 클래스에서 구체적인 구현을 강제할 때 사용합니다.

### 추상 클래스 정의

`abstract` 키워드를 사용하여 추상 클래스와 추상 메서드를 정의합니다.

```typescript
// 추상 클래스
abstract class Shape {
  constructor(public color: string) {}
  
  // 일반 메서드 (구현 포함)
  displayColor(): void {
    console.log(\`색상: \${this.color}\`);
  }
  
  // 추상 메서드 (구현 없음, 자식 클래스에서 반드시 구현해야 함)
  abstract calculateArea(): number;
  abstract getInfo(): string;
}

// 원 클래스
class Circle extends Shape {
  constructor(color: string, public radius: number) {
    super(color);
  }
  
  // 추상 메서드 구현 (필수)
  calculateArea(): number {
    return Math.PI * this.radius ** 2;
  }
  
  getInfo(): string {
    return \`원 - 반지름: \${this.radius}cm\`;
  }
}

// 직사각형 클래스
class Rectangle extends Shape {
  constructor(
    color: string,
    public width: number,
    public height: number
  ) {
    super(color);
  }
  
  calculateArea(): number {
    return this.width * this.height;
  }
  
  getInfo(): string {
    return \`직사각형 - \${this.width}cm × \${this.height}cm\`;
  }
}

// 사용
// const shape = new Shape("red");  // ❌ 에러! 추상 클래스는 인스턴스 생성 불가

const circle = new Circle("빨강", 5);
circle.displayColor();  // 부모의 일반 메서드
console.log(circle.getInfo());
console.log(\`넓이: \${circle.calculateArea().toFixed(2)}cm²\`);

const rectangle = new Rectangle("파랑", 10, 20);
rectangle.displayColor();
console.log(rectangle.getInfo());
console.log(\`넓이: \${rectangle.calculateArea()}cm²\`);
```

**시각적 이해:**

```
     Shape (추상 클래스)
  ┌──────────────────────┐
  │ color: string        │
  │ displayColor()       │ ← 구현 있음
  │                      │
  │ abstract:            │
  │ - calculateArea()    │ ← 구현 없음 (자식이 구현해야 함)
  │ - getInfo()          │ ← 구현 없음
  └──────────────────────┘
         ↑        ↑
    상속  │        │  상속
    ┌────┘        └────┐
    │                  │
  Circle          Rectangle
┌─────────────┐  ┌─────────────┐
│ radius      │  │ width       │
│ 추상 메서드  │  │ height      │
│ 구현 ✅     │  │ 추상 메서드  │
└─────────────┘  │ 구현 ✅     │
                 └─────────────┘
```

**왜 추상 클래스를 사용할까요?**

1. **공통 기능 제공**: 모든 자식 클래스가 사용할 수 있는 공통 기능
2. **구현 강제**: 자식 클래스가 반드시 구현해야 하는 메서드 지정
3. **일관성 유지**: 모든 자식 클래스가 같은 인터페이스를 가지도록 보장

**실전 예제: 결제 시스템**

```typescript
// 추상 결제 클래스
abstract class Payment {
  constructor(
    protected amount: number,
    protected description: string
  ) {}
  
  // 공통 기능
  printReceipt(): void {
    console.log("\n=== 결제 영수증 ===");
    console.log(\`내역: \${this.description}\`);
    console.log(\`금액: \${this.amount.toLocaleString()}원\`);
    console.log(\`결제 수단: \${this.getPaymentMethod()}\`);
  }
  
  // 자식 클래스에서 구현해야 하는 메서드들
  abstract process(): boolean;
  abstract getPaymentMethod(): string;
  abstract refund(): boolean;
}

// 신용카드 결제
class CreditCardPayment extends Payment {
  constructor(
    amount: number,
    description: string,
    private cardNumber: string
  ) {
    super(amount, description);
  constructor(
    amount: number,
    description: string,
    private cardNumber: string
  ) {
    super(amount, description);
  }
  
  process(): boolean {
    console.log(\`신용카드 결제 처리 중... (카드: ****\${this.cardNumber.slice(-4)})\`);
    // 실제로는 결제 API 호출
    console.log("결제 완료!");
    return true;
  }
  
  getPaymentMethod(): string {
    return "신용카드";
  }
  
  refund(): boolean {
    console.log(\`신용카드 환불 처리 중... (\${this.amount}원)\`);
    console.log("환불 완료!");
    return true;
  }
}

// 계좌이체 결제
class BankTransferPayment extends Payment {
  constructor(
    amount: number,
    description: string,
    private bankName: string,
    private accountNumber: string
  ) {
    super(amount, description);
  }
  
  process(): boolean {
    console.log(\`계좌이체 처리 중... (\${this.bankName} \${this.accountNumber})\`);
    console.log("이체 완료!");
    return true;
  }
  
  getPaymentMethod(): string {
    return \`계좌이체 (\${this.bankName})\`;
  }
  
  refund(): boolean {
    console.log(\`계좌이체 환불 처리 중... (\${this.amount}원)\`);
    console.log("환불 완료!");
    return true;
  }
}

// 포인트 결제
class PointPayment extends Payment {
  constructor(
    amount: number,
    description: string,
    private userId: string
  ) {
    super(amount, description);
  }
  
  process(): boolean {
    console.log(\`포인트 결제 처리 중... (사용자: \${this.userId})\`);
    console.log("포인트 차감 완료!");
    return true;
  }
  
  getPaymentMethod(): string {
    return "포인트";
  }
  
  refund(): boolean {
    console.log(\`포인트 환불 처리 중... (\${this.amount}원)\`);
    console.log("포인트 복구 완료!");
    return true;
  }
}

// 사용 예시
function processPayment(payment: Payment): void {
  if (payment.process()) {
    payment.printReceipt();
  }
}

console.log("=== 결제 테스트 ===");

const card = new CreditCardPayment(50000, "노트북 구매", "1234-5678-9012-3456");
processPayment(card);

const transfer = new BankTransferPayment(30000, "마우스 구매", "국민은행", "123-456-789");
processPayment(transfer);

const point = new PointPayment(10000, "키보드 구매", "USER123");
processPayment(point);

console.log("\n=== 환불 테스트 ===");
card.refund();
```

---

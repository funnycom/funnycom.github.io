---
title: "[TS] 기본 타입 시스템"
date: 2025-10-13 15:40:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - TypeScript의 기본 타입들을 이해하고 사용할 수 있다
> - 배열과 튜플의 차이를 안다
> - 객체 타입을 정의할 수 있다
> - any, unknown, void, never의 용도를 이해한다
> - 유니온 타입과 리터럴 타입을 활용할 수 있다

---

## 원시 타입 (Primitive Types)

앞에서 `string`, `number`, `boolean` 타입을 간단히 사용해봤습니다. 이번 섹션에서는 TypeScript의 모든 원시 타입을 자세히 알아보겠습니다.

원시 타입은 가장 기본이 되는 타입으로, 단 하나의 값만 저장할 수 있습니다. JavaScript에서 배운 원시 타입에 TypeScript에서는 타입을 명시할 수 있게 된 것입니다.

### string (문자열)

문자열을 저장하는 타입입니다. 큰따옴표(`""`), 작은따옴표(`''`), 백틱(` `` `)으로 감싼 모든 텍스트가 문자열입니다.

```typescript
// 기본 문자열
const name: string = "홍길동";
const city: string = '서울';

// 템플릿 리터럴
const message: string = \`안녕하세요, \${name}님!\`;

// 여러 줄 문자열
const poem: string = \`
  동해물과 백두산이
  마르고 닳도록
\`;

console.log(name);     // 홍길동
console.log(message);  // 안녕하세요, 홍길동님!
```

문자열 타입에는 문자열만 할당할 수 있습니다. 숫자나 불린 값을 할당하려고 하면 타입스크립트가 에러를 표시합니다.

```typescript
const name: string = "홍길동";  // ✅ 올바름
const age: string = 25;         // ❌ 에러! number는 string에 할당 불가
const isOk: string = true;      // ❌ 에러! boolean은 string에 할당 불가
```

### number (숫자)

모든 숫자를 저장하는 타입입니다. JavaScript와 마찬가지로 TypeScript도 정수와 실수를 구분하지 않고 모두 `number` 타입으로 처리합니다.

```typescript
// 정수
const age: number = 25;
const year: number = 2024;

// 실수
const height: number = 175.5;
const pi: number = 3.14159;

// 음수
const temperature: number = -10;

// 특수한 숫자 값
const infinity: number = Infinity;
const notANumber: number = NaN;

console.log(age);         // 25
console.log(height);      // 175.5
console.log(temperature); // -10
```

TypeScript의 `number` 타입은 정수, 소수, 음수, 특수 값(`Infinity`, `NaN`)을 모두 포함합니다. 다른 언어처럼 `int`, `float`, `double`을 구분하지 않아 사용하기 간편합니다.

```typescript
// 다양한 표현 방식
const decimal: number = 100;      // 10진수
const binary: number = 0b1010;    // 2진수 (10)
const octal: number = 0o744;      // 8진수 (484)
const hex: number = 0xFF;         // 16진수 (255)

console.log(decimal);  // 100
console.log(binary);   // 10
console.log(hex);      // 255
```

### boolean (불린)

참(`true`) 또는 거짓(`false`) 두 가지 값만 가질 수 있는 타입입니다. 조건문이나 논리 연산에서 주로 사용됩니다.

```typescript
const isStudent: boolean = true;
const isAdult: boolean = false;
const hasLicense: boolean = true;

// 비교 연산의 결과도 boolean
const age: number = 25;
const canVote: boolean = age >= 18;  // true

console.log(isStudent);  // true
console.log(canVote);    // true
```

불린 타입은 오직 `true`와 `false` 두 값만 허용합니다. 다른 언어에서는 `1`이나 `0`을 불린으로 사용할 수 있지만, TypeScript에서는 명확하게 `true`나 `false`만 사용해야 합니다.

```typescript
const isOk: boolean = true;    //  올바름
const isOk2: boolean = false;  //  올바름
const isOk3: boolean = 1;      //  에러! number는 boolean이 아님
const isOk4: boolean = "true"; //  에러! string은 boolean이 아님
```

### null과 undefined

`null`과 `undefined`는 "값이 없음"을 나타내는 특별한 타입입니다. 비슷해 보이지만 사용 목적이 조금 다릅니다.

**undefined: 값이 아직 할당되지 않음**

변수를 선언만 하고 값을 할당하지 않았을 때 자동으로 `undefined`가 됩니다. "아직 정해지지 않았다"는 의미입니다.

```typescript
let name: string;
console.log(name);  // undefined

let age: number | undefined;  // undefined를 허용하는 타입
age = undefined;              // ✅ 올바름
age = 25;                     // ✅ 올바름
```

**null: 의도적으로 값이 없음**

개발자가 명시적으로 "값이 없다"고 표시할 때 사용합니다. "비어있다"는 의미를 명확히 표현할 수 있습니다.

```typescript
let middleName: string | null = null;  // 중간 이름이 없음을 명시
let spouse: string | null = null;      // 배우자가 없음을 명시

// 나중에 값 할당 가능
middleName = "영";
spouse = "김철수";
```

**null과 undefined의 차이**

```typescript
let data1: undefined = undefined;  // 아직 값이 없음 (자동)
let data2: null = null;            // 의도적으로 값을 비움 (명시)

// 실전 예시
function findUser(id: number): string | null {
  // 사용자를 찾지 못하면 null 반환 (명시적으로 "없음")
  if (id === 0) {
    return null;
  }
  return "홍길동";
}

let result = findUser(0);  // null
let result2: string;       // undefined (값 할당 안 함)
```

TypeScript에서는 기본적으로 `null`과 `undefined`를 다른 타입에 할당할 수 없습니다. 이를 허용하려면 유니온 타입(`|`)을 사용해야 합니다.

```typescript
let name: string = "홍길동";
name = null;       // ❌ 에러! (strict 모드)
name = undefined;  // ❌ 에러! (strict 모드)

// 유니온 타입으로 허용
let name2: string | null = "홍길동";
name2 = null;      // ✅ 올바름

let name3: string | undefined = "홍길동";
name3 = undefined; // ✅ 올바름
```

### symbol과 bigint

이 두 타입은 고급 사용 사례에서 필요한 특수한 타입입니다. 초보자는 이런 타입이 있다는 것만 알아두고, 자주 사용하지는 않아도 됩니다.

**symbol: 고유한 식별자**

`symbol`은 절대 중복되지 않는 고유한 값을 만들 때 사용합니다. 주로 객체의 속성 키로 사용되며, 같은 설명으로 만들어도 서로 다른 symbol이 생성됩니다.

```typescript
const id1: symbol = Symbol("id");
const id2: symbol = Symbol("id");

console.log(id1 === id2);  // false (서로 다른 symbol)

// 객체 속성으로 사용
const obj = {
  [id1]: "value1"
};

console.log(obj[id1]);  // "value1"
```

**bigint: 매우 큰 정수**

`bigint`는 `number` 타입으로 표현할 수 없는 매우 큰 정수를 다룰 때 사용합니다. 숫자 뒤에 `n`을 붙여서 만듭니다.

```typescript
// number의 안전한 범위를 넘어서는 큰 수
const bigNumber: bigint = 9007199254740991n;
const anotherBig: bigint = BigInt("9007199254740991");

console.log(bigNumber);  // 9007199254740991n

// bigint 연산
const result: bigint = bigNumber + 100n;  // bigint끼리만 연산 가능
```

`symbol`과 `bigint`는 일반적인 개발에서는 거의 사용하지 않습니다. 특별한 요구사항이 있을 때만 사용하므로, 지금은 이런 타입이 존재한다는 것만 기억하세요.

---

## 7.2 배열과 튜플

여러 개의 값을 순서대로 저장해야 할 때 배열을 사용합니다. TypeScript에서는 배열에 어떤 타입의 값이 들어갈지 명시할 수 있어 더 안전한 코드를 작성할 수 있습니다.

### 배열 타입 선언

배열 타입을 선언하는 방법은 두 가지가 있습니다. 두 방법 모두 똑같이 동작하므로 편한 방법을 선택하면 됩니다.

```typescript
// 방법 1: 타입[] (더 일반적)
const numbers: number[] = [1, 2, 3, 4, 5];
const names: string[] = ["홍길동", "김철수", "이영희"];
const flags: boolean[] = [true, false, true];

// 방법 2: Array<타입>
const numbers2: Array<number> = [1, 2, 3, 4, 5];
const names2: Array<string> = ["홍길동", "김철수", "이영희"];
```

배열은 같은 타입의 값만 담을 수 있습니다. 다른 타입의 값을 섞어서 넣으려고 하면 TypeScript가 에러를 표시합니다.

```typescript
const numbers: number[] = [1, 2, 3];
numbers.push(4);      // ✅ 올바름
numbers.push("5");    // ❌ 에러! string은 number[]에 추가 불가

const mixed = [1, "hello", true];  // 타입 추론: (number | string | boolean)[]
```

**실전 예제:**

```typescript
// 학생 이름 목록
const students: string[] = ["홍길동", "김철수", "이영희"];

// 점수 목록
const scores: number[] = [85, 90, 78, 95];

// 배열 순회
for (let i = 0; i < students.length; i++) {
  console.log(\`\${students[i]}: \${scores[i]}점\`);
}

// 출력:
// 홍길동: 85점
// 김철수: 90점
// 이영희: 78점
```

### 읽기 전용 배열

때로는 배열의 값을 변경하지 못하게 막고 싶을 때가 있습니다. `readonly` 키워드를 사용하면 읽기 전용 배열을 만들 수 있습니다.

```typescript
// 읽기 전용 배열
const numbers: readonly number[] = [1, 2, 3, 4, 5];

console.log(numbers[0]);  // ✅ 읽기는 가능
numbers[0] = 10;          // ❌ 에러! 수정 불가
numbers.push(6);          // ❌ 에러! 추가 불가
numbers.pop();            // ❌ 에러! 제거 불가
```

읽기 전용 배열은 실수로 배열의 내용을 변경하는 것을 방지할 수 있습니다. 특히 함수의 매개변수로 배열을 전달할 때, 원본 배열이 변경되지 않도록 보호하고 싶을 때 유용합니다.

```typescript
// 원본 배열을 변경하지 않는 함수
function printNumbers(numbers: readonly number[]): void {
  for (const num of numbers) {
    console.log(num);
  }
  // numbers.push(99);  // ❌ 에러! readonly 배열은 변경 불가
}

const myNumbers: number[] = [1, 2, 3];
printNumbers(myNumbers);  // 원본 배열이 안전하게 보호됨
```

### 튜플 (Tuple)

튜플은 고정된 길이와 각 위치마다 정해진 타입을 가지는 배열입니다. 일반 배열과 달리 각 요소의 타입이 다를 수 있고, 길이도 정확히 정해져 있습니다.

```typescript
// 튜플: [타입1, 타입2, 타입3, ...]
let person: [string, number, boolean];

person = ["홍길동", 25, true];   // ✅ 올바름
person = [25, "홍길동", true];   // ❌ 에러! 순서가 틀림
person = ["홍길동", 25];         // ❌ 에러! 길이가 부족함
person = ["홍길동", 25, true, "extra"];  // ❌ 에러! 길이가 초과함
```

튜플은 서로 관련된 여러 값을 하나로 묶어서 반환하거나 전달할 때 유용합니다. 예를 들어 좌표, 사용자 정보, 함수의 여러 반환값 등을 표현할 때 사용합니다.

```typescript
// 좌표 (x, y)
const point: [number, number] = [10, 20];
console.log(\`x: \${point[0]}, y: \${point[1]}\`);

// RGB 색상
const color: [number, number, number] = [255, 128, 0];
console.log(\`R: \${color[0]}, G: \${color[1]}, B: \${color[2]}\`);

// 사용자 정보 (이름, 나이, 회원 여부)
const user: [string, number, boolean] = ["홍길동", 25, true];
const [name, age, isMember] = user;  // 구조 분해 할당

console.log(\`이름: \${name}, 나이: \${age}세, 회원: \${isMember}\`);
```

**튜플에 레이블 추가하기 (TypeScript 4.0+)**

튜플의 각 요소에 이름을 붙여서 더 명확하게 만들 수 있습니다. 코드를 읽는 사람이 각 위치의 의미를 쉽게 이해할 수 있습니다.

```typescript
// 레이블이 있는 튜플
type Person = [name: string, age: number, isStudent: boolean];

const student: Person = ["홍길동", 20, true];

// 레이블은 문서화 역할만 함 (실제 코드에서는 인덱스로 접근)
console.log(student[0]);  // "홍길동"
console.log(student[1]);  // 20
```

### 튜플 vs 배열

튜플과 배열은 비슷해 보이지만 사용 목적이 다릅니다.

**배열: 같은 타입의 데이터를 여러 개**

```typescript
// 학생들의 점수 목록 (개수가 가변적)
const scores: number[] = [85, 90, 78, 95, 88];
scores.push(92);  // 요소 추가 가능
```

**튜플: 서로 다른 타입의 데이터를 정해진 개수만큼**

```typescript
// 한 학생의 정보 (이름, 나이, 점수 - 고정된 구조)
const student: [string, number, number] = ["홍길동", 20, 85];
// student.push(92);  // ❌ 길이가 고정되어 있음
```

| 특징 | 배열 | 튜플 |
|------|------|------|
| **길이** | 가변적 | 고정적 |
| **타입** | 모든 요소가 같은 타입 | 각 위치마다 다른 타입 가능 |
| **용도** | 같은 종류의 데이터 여러 개 | 구조가 정해진 데이터 묶음 |
| **예시** | 학생 목록, 점수 목록 | 좌표, 사용자 정보 |

**언제 튜플을 사용할까?**

1. 함수에서 여러 값을 반환할 때

```typescript
function getNameAndAge(): [string, number] {
  return ["홍길동", 25];
}

const [name, age] = getNameAndAge();
console.log(\`\${name}은 \${age}세입니다.\`);
```

2. 고정된 구조의 데이터를 표현할 때

```typescript
// 좌표
const point: [number, number] = [10, 20];

// 날짜 (년, 월, 일)
const date: [number, number, number] = [2024, 12, 25];

// 범위 (최소값, 최대값)
const range: [number, number] = [0, 100];
```

3. 간단한 구조에서 객체 대신 사용할 때

```typescript
// 객체 사용
const user1 = { name: "홍길동", age: 25 };

// 튜플 사용 (더 간결)
const user2: [string, number] = ["홍길동", 25];
```

하지만 구조가 복잡해지면 객체를 사용하는 것이 더 명확합니다. 튜플은 간단하고 고정된 구조에만 사용하세요.

---

## 객체 타입

객체는 관련된 데이터를 하나로 묶어서 관리할 때 사용합니다. TypeScript에서는 객체의 구조(어떤 속성이 있고, 각 속성의 타입은 무엇인지)를 미리 정의할 수 있습니다.

### 객체 타입 선언

객체 타입을 선언하는 가장 기본적인 방법은 중괄호 안에 속성명과 타입을 나열하는 것입니다.

```typescript
// 기본 객체 타입
let user: { name: string; age: number };

user = {
  name: "홍길동",
  age: 25
};

console.log(\`\${user.name}은 \${user.age}세입니다.\`);
```

객체 타입을 정의할 때는 각 속성의 이름과 타입을 콜론(`:`)으로 구분하고, 속성들은 세미콜론(`;`) 또는 쉼표(`,`)로 구분합니다.

```typescript
// 세미콜론 사용 (더 일반적)
let user1: {
  name: string;
  age: number;
  city: string;
};

// 쉼표 사용 (같은 의미)
let user2: {
  name: string,
  age: number,
  city: string
};

// 한 줄로도 가능
let user3: { name: string; age: number; city: string };
```

**실전 예제:**

```typescript
// 상품 정보
let product: {
  id: number;
  name: string;
  price: number;
  inStock: boolean;
};

product = {
  id: 1,
  name: "노트북",
  price: 1000000,
  inStock: true
};

console.log(\`상품: \${product.name}\`);
console.log(\`가격: \${product.price.toLocaleString()}원\`);
console.log(\`재고: \${product.inStock ? "있음" : "없음"}\`);
```

### 선택적 속성 (Optional Properties)

때로는 객체의 일부 속성이 있을 수도 있고 없을 수도 있습니다. 이럴 때 속성 이름 뒤에 물음표(`?`)를 붙여서 선택적 속성으로 만들 수 있습니다.

```typescript
// middleName은 있어도 되고 없어도 됨
let user: {
  firstName: string;
  middleName?: string;  // 선택적 속성
  lastName: string;
};

// middleName이 없어도 OK
user = {
  firstName: "길동",
  lastName: "홍"
};

// middleName이 있어도 OK
user = {
  firstName: "철수",
  middleName: "영",
  lastName: "김"
};
```

선택적 속성은 값이 `undefined`일 수 있으므로, 사용할 때 주의해야 합니다.

```typescript
let user: {
  name: string;
  email?: string;
};

user = { name: "홍길동" };

// email이 있는지 확인하고 사용
if (user.email) {
  console.log(\`이메일: \${user.email}\`);
} else {
  console.log("이메일이 없습니다.");
}

// 또는 옵셔널 체이닝 사용
console.log(user.email?.toLowerCase());  // undefined 또는 이메일(소문자)
```

**실전 예제:**

```typescript
// 사용자 프로필
let profile: {
  name: string;
  age: number;
  email?: string;        // 선택적
  phone?: string;        // 선택적
  address?: string;      // 선택적
};

// 최소 정보만 제공
profile = {
  name: "홍길동",
  age: 25
};

// 추가 정보 제공
profile = {
  name: "김철수",
  age: 30,
  email: "kim@example.com",
  phone: "010-1234-5678"
};
```

### 읽기 전용 속성 (Readonly Properties)

객체의 속성을 처음 할당한 후 변경하지 못하게 하려면 `readonly` 키워드를 사용합니다.

```typescript
let user: {
  readonly id: number;    // 읽기 전용
  name: string;
};

user = {
  id: 1,
  name: "홍길동"
};

console.log(user.id);   // ✅ 읽기는 가능
user.name = "김철수";   // ✅ 일반 속성은 변경 가능
user.id = 2;            // ❌ 에러! readonly 속성은 변경 불가
```

`readonly`는 한 번 설정된 값이 절대 바뀌어서는 안 되는 경우에 사용합니다. 예를 들어 사용자 ID, 주문 번호, 생성 날짜 같은 값들이 여기에 해당합니다.

```typescript
// 주문 정보
let order: {
  readonly orderId: string;      // 주문 번호는 변경 불가
  readonly createdAt: Date;      // 생성 날짜는 변경 불가
  status: string;                 // 상태는 변경 가능
  totalPrice: number;            // 금액은 변경 가능
};

order = {
  orderId: "ORD-2024-001",
  createdAt: new Date(),
  status: "pending",
  totalPrice: 50000
};

// 상태와 금액은 변경 가능
order.status = "completed";
order.totalPrice = 45000;

// 주문 번호와 날짜는 변경 불가
// order.orderId = "ORD-2024-002";  // ❌ 에러!
// order.createdAt = new Date();    // ❌ 에러!
```

### 인덱스 시그니처 (Index Signature)

때로는 객체에 어떤 속성들이 있을지 미리 알 수 없지만, 모든 속성이 같은 타입의 값을 가진다는 것은 알고 있을 때가 있습니다. 이럴 때 인덱스 시그니처를 사용합니다.

```typescript
// 모든 속성의 값이 number 타입
let scores: { [key: string]: number };

scores = {
  korean: 85,
  math: 90,
  english: 88,
  science: 92
};

console.log(scores.korean);    // 85
console.log(scores["math"]);   // 90
```

인덱스 시그니처는 `[key: 타입]: 값타입` 형식으로 작성합니다. 여기서 `key`는 임의의 이름이고, 실제 속성 이름은 무엇이든 될 수 있습니다.

```typescript
// 사용자별 점수를 저장하는 객체
let userScores: { [username: string]: number } = {};

userScores["홍길동"] = 85;
userScores["김철수"] = 90;
userScores["이영희"] = 78;

console.log(userScores["홍길동"]);  // 85

// 동적으로 속성 추가 가능
const newUser = "박민수";
userScores[newUser] = 95;
```

**인덱스 시그니처와 일반 속성 함께 사용:**

```typescript
// 필수 속성과 추가 속성을 함께 정의
let user: {
  name: string;              // 필수 속성
  age: number;               // 필수 속성
  [key: string]: any;        // 추가 속성들
};

user = {
  name: "홍길동",
  age: 25,
  city: "서울",            // 추가 속성
  hobby: "독서",           // 추가 속성
  isStudent: true         // 추가 속성
};

console.log(user.name);    // "홍길동"
console.log(user.city);    // "서울"
console.log(user.hobby);   // "독서"
```

인덱스 시그니처는 유연한 객체 구조가 필요할 때 유용하지만, 타입 안정성이 떨어질 수 있습니다. 가능하면 명확한 속성 정의를 사용하는 것이 좋습니다.

---


---
title: "[TS] 데코레이터 - 4"
date: 2025-10-23 16:20:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, 데코레이터, decorator]
pin: true
math: true
mermaid: true
---

## 🎯 학습 목표

* 데코레이터의 개념과 동작 원리를 이해한다
* TypeScript에서 데코레이터 기능을 활성화할 수 있다
* 클래스 데코레이터로 클래스를 수정하고 확장할 수 있다
* 메서드 데코레이터로 메서드 동작을 변경할 수 있다
* 프로퍼티 데코레이터로 속성에 메타데이터를 추가할 수 있다
* 매개변수 데코레이터로 파라미터 정보를 추출할 수 있다
* 데코레이터 팩토리로 설정 가능한 데코레이터를 만들 수 있다
* 실전에서 유효성 검사, 로깅, 의존성 주입을 구현할 수 있다

---

### 📝 연습 문제

**문제 1: HTTP API 데코레이터**

HTTP API를 위한 데코레이터 시스템을 구현하세요.
```typescript
// TODO: 다음 데코레이터들을 구현하세요

// 1. Controller 데코레이터 (클래스)
function Controller(basePath: string) {
  // 구현
}

// 2. HTTP 메서드 데코레이터
function Get(path: string) {
  // 구현
}

function Post(path: string) {
  // 구현
}

// 3. 파라미터 데코레이터
function Param(name: string) {
  // 구현
}

function Body() {
  // 구현
}

// 사용 예시
@Controller('/api/users')
class UserController {
  @Get('/:id')
  getUser(@Param('id') id: string) {
    return { id, name: 'User' };
  }
  
  @Post('/')
  createUser(@Body() body: any) {
    return { id: Date.now(), ...body };
  }
}

// 기대 동작:
// GET /api/users/123 → getUser('123') 호출
// POST /api/users → createUser(body) 호출
```

**문제 2: 비동기 큐 데코레이터**

메서드 실행을 큐에 넣어 순차적으로 처리하는 데코레이터를 구현하세요.

```typescript
// TODO: Queue 데코레이터 구현

function Queue(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  // 구현
  // 힌트: Promise 큐를 사용하여 순차 실행
}

class TaskService {
  @Queue
  async processTask(id: number) {
    console.log(`Processing task ${id}...`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log(`Task ${id} completed`);
    return id;
  }
}

const service = new TaskService();

// 동시에 여러 호출해도 순차 실행되어야 함
service.processTask(1);
service.processTask(2);
service.processTask(3);

// 기대 출력:
// Processing task 1...
// Task 1 completed
// Processing task 2...
// Task 2 completed
// Processing task 3...
// Task 3 completed
```

**문제 3: 이벤트 발행 데코레이터**

메서드 실행 전후에 이벤트를 발행하는 데코레이터를 구현하세요.

```typescript
// TODO: 이벤트 시스템 구현

interface EventEmitter {
  emit(event: string, data: any): void;
  on(event: string, handler: (data: any) => void): void;
}

// 간단한 이벤트 이미터 구현
const eventEmitter: EventEmitter = {
  // 구현
};

function EmitEvent(eventName: string) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    // 구현
    // 메서드 실행 전: `${eventName}:before` 이벤트
    // 메서드 실행 후: `${eventName}:after` 이벤트
  };
}

class UserService {
  @EmitEvent('user:create')
  createUser(name: string) {
    console.log(`Creating user: ${name}`);
    return { id: Date.now(), name };
  }
}

// 이벤트 리스너 등록
eventEmitter.on('user:create:before', (data) => {
  console.log('Before creating user:', data);
});

eventEmitter.on('user:create:after', (data) => {
  console.log('After creating user:', data);
});

const service = new UserService();
service.createUser('홍길동');

// 기대 출력:
// Before creating user: { args: ['홍길동'] }
// Creating user: 홍길동
// After creating user: { args: ['홍길동'], result: { id: ..., name: '홍길동' } }
```

### 다음 Chapter 예고

**Chapter 17: TypeScript 설정과 최적화**

tsconfig.json 완벽 가이드

컴파일 옵션 상세 설명

strict 모드 활용

타입 체크 최적화

프로젝트 레퍼런스

린팅과 포맷팅

빌드 최적화 전략

**데코레이터로 메타프로그래밍을 마스터했다면, 이제 TypeScript 프로젝트를 최적화하는 방법을 배워봅시다!**

END OF CHAPTER 16

16장을 완성했습니다!

**Chapter 16의 특징:**
- 데코레이터의 개념과 필요성
- 5가지 데코레이터 타입 완벽 정리
- 실험적 기능 활성화 방법
- 데코레이터 팩토리 패턴
- 실전 활용 예제 (유효성 검사, 로깅, 의존성 주입)
- Best Practices
- 실행 순서 설명
- 연습 문제 3개

---
title: "[Projects] 도서관 관리 시스템 - 1"
date: 2025-10-15 15:00:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, todo, api]
pin: true
math: true
mermaid: true
---

# Project 2: 도서관 관리 시스템

> **프로젝트 목표**
> - 클래스 상속과 추상 클래스를 실전에 적용한다
> - 복잡한 비즈니스 로직을 설계하고 구현한다
> - 여러 엔티티 간의 관계를 관리한다
> - 날짜 계산 및 연체 처리를 구현한다
> - AI와 협업하되 더 자율적으로 프로젝트를 진행한다

---

## 📋 프로젝트 개요

### 무엇을 만들까요?

도서관에서 책과 회원을 관리하고, 대출/반납 시스템을 운영하는 애플리케이션을 만들어봅시다. 
첫 번째 프로젝트보다 복잡한 구조와 비즈니스 로직을 다룹니다.

### 완성된 앱의 모습
```
=== 도서관 관리 시스템 ===

📚 책 관리
1. TypeScript 프로그래밍 (ISBN: 978-1) - 대출 가능
2. 클린 코드 (ISBN: 978-2) - 대출 중 (홍길동)
3. 리팩토링 (ISBN: 978-3) - 대출 가능

👤 회원 관리
1. 홍길동 (M001) - 일반 회원 - 대출: 1권
2. 김철수 (M002) - 우수 회원 - 대출: 0권

📖 대출 내역
- 홍길동: "클린 코드" (2024-01-10 대출, 반납 예정: 2024-01-24)

⚠️ 연체 도서
- 없음

📊 통계
- 전체 장서: 3권
- 대출 가능: 2권
- 대출 중: 1권
- 전체 회원: 2명
```

### 학습 목표

이 프로젝트를 완성하면:

- ✅ 클래스 상속 구조 설계 능력
- ✅ 추상 클래스 활용 능력
- ✅ 복잡한 비즈니스 로직 구현 능력
- ✅ 엔티티 간 관계 관리 능력
- ✅ 날짜 계산 및 처리 능력
- ✅ 고급 검색 및 필터링 능력
- ✅ 더 자율적인 문제 해결 능력

### 예상 소요 시간

- **총 소요 시간**: 6-8시간
- **1일차 (3-4시간)**: 요구사항 분석, 설계, 기본 엔티티 구현
- **2일차 (3-4시간)**: 대출 시스템, 연체 관리, 고급 기능

### 난이도

⭐⭐⭐⭐☆ (중상급)

- Todo 앱 완성 필수
- TypeScript 클래스/인터페이스 숙련도 필요
- 객체지향 설계 개념 이해 필요
- 날짜 처리 기초 지식 필요

### 첫 번째 프로젝트와의 차이점
```
┌─────────────────────────────────────────────────┐
│            Todo 앱 vs 도서관 시스템             │
├──────────────┬──────────────┬───────────────────┤
│              │   Todo 앱    │   도서관 시스템    │
├──────────────┼──────────────┼───────────────────┤
│ 난이도       │    ⭐⭐⭐     │    ⭐⭐⭐⭐        │
│ 엔티티 수    │    1개       │    3개 (책/회원/대출)│
│ 클래스 상속  │    없음      │    있음           │
│ 관계 관리    │    단순      │    복잡           │
│ 비즈니스 로직│    간단      │    복잡           │
│ 날짜 처리    │    없음      │    있음 (연체)    │
│ 검색/필터    │    기본      │    고급           │
│ AI 의존도    │    높음      │    중간           │
└──────────────┴──────────────┴───────────────────┘
```

---

## Part 1: 프로젝트 계획 세우기 (40-60분)

첫 번째 프로젝트에서 배운 것처럼, 코드 작성 전에 충분히 생각하고 설계하는 시간을 가져봅시다.
이번에는 더 복잡하므로 설계에 더 많은 시간을 투자하세요.

### 🎯 Step 1: 도메인 이해하기

도서관 시스템의 핵심 개념을 먼저 이해해봅시다.

#### 핵심 엔티티 파악

**[ ] 1. 어떤 엔티티(Entity)들이 필요할까요?**
```
생각해보기:
- 도서관에서 관리해야 할 "것"들은 무엇인가?
- 각 "것"은 어떤 정보를 가져야 하나?
- "것"들 사이의 관계는?

내 생각:
┌─────────────────────────────────────┐
│                                     │
│  엔티티 1: ___________              │
│  - 속성: _______________________    │
│  - 속성: _______________________    │
│                                     │
│  엔티티 2: ___________              │
│  - 속성: _______________________    │
│  - 속성: _______________________    │
│                                     │
│  엔티티 3: ___________              │
│  - 속성: _______________________    │
│  - 속성: _______________________    │
│                                     │
└─────────────────────────────────────┘
```

**💡 힌트:**

<details>
<summary>막히셨나요? 힌트 보기</summary>
```
일반적인 도서관 시스템의 핵심 엔티티:

1. 책 (Book)
   - 어떤 정보가 필요할까?
   - 대출 상태는 어떻게 관리할까?

2. 회원 (Member)
   - 회원을 구분하려면?
   - 대출 제한은 어떻게 관리할까?

3. 대출 (Loan)
   - 누가 어떤 책을 빌렸는지 기록
   - 대출 날짜, 반납 예정일
   - 연체 여부
```

</details>

#### 관계 파악

**[ ] 2. 엔티티 간의 관계는?**
```
생각해보기:
- 책과 회원의 관계는?
- 책과 대출의 관계는?
- 회원과 대출의 관계는?

관계도 그리기:
(종이에 그리거나 아래에 텍스트로 표현)

┌──────┐         ┌──────┐         ┌──────┐
│      │ ------- │      │ ------- │      │
│      │         │      │         │      │
└──────┘         └──────┘         └──────┘

내 생각:
_______________________________________
_______________________________________
_______________________________________
```

**💡 관계 예시:**

<details>
<summary>예시 보기</summary>
```
회원 (Member) ──── "빌린다" ──── 책 (Book)
       │                           │
       │                           │
       └──── 대출 (Loan) ──────────┘
       
- 한 회원은 여러 책을 빌릴 수 있다 (1:N)
- 한 책은 한 명에게만 대출된다 (1:1, 현재)
- 대출(Loan)은 회원과 책을 연결한다
```

</details>

#### 비즈니스 규칙 정리

**[ ] 3. 도서관 운영 규칙은?**
```
질문에 답하며 규칙 정리:

1. 대출 규칙:
   □ 한 번에 몇 권까지 빌릴 수 있나?
   □ 대출 기간은?
   □ 이미 대출 중인 책을 빌릴 수 있나?

2. 연체 규칙:
   □ 언제 연체가 되나?
   □ 연체 중에 다른 책을 빌릴 수 있나?
   □ 연체료는?

3. 회원 등급:
   □ 회원 등급이 있나?
   □ 등급에 따른 혜택은?
   □ 등급 변경 조건은?

내가 정한 규칙:
┌─────────────────────────────────────┐
│                                     │
│  대출 규칙:                         │
│  - _____________________________    │
│  - _____________________________    │
│                                     │
│  연체 규칙:                         │
│  - _____________________________    │
│  - _____________________________    │
│                                     │
│  회원 등급:                         │
│  - _____________________________    │
│  - _____________________________    │
│                                     │
└─────────────────────────────────────┘
```

**💡 일반적인 규칙 예시:**

<details>
<summary>예시 보기</summary>
```
대출 규칙:
- 일반 회원: 최대 3권
- 우수 회원: 최대 5권
- 대출 기간: 14일
- 대출 중인 책은 빌릴 수 없음

연체 규칙:
- 반납 예정일 다음 날부터 연체
- 연체 중인 회원은 추가 대출 불가
- 연체료: 1일당 100원

회원 등급:
- 일반 회원: 기본
- 우수 회원: 연체 없이 10권 이상 대출 시
```

</details>

---

### 🎨 Step 2: 클래스 설계하기

이제 객체지향으로 설계해봅시다. 이번에는 **상속 구조**도 고려해야 합니다.

#### Book 클래스 설계

**[ ] 책(Book) 클래스 설계**
```
생각해보기:
- 책은 어떤 정보를 가져야 하나?
- 어떤 메서드가 필요한가?
- 대출 상태를 어떻게 관리할까?

내 설계:
┌─────────────────────────────────────┐
│  class Book {                       │
│                                     │
│    // 속성                          │
│    _____: ______;                   │
│    _____: ______;                   │
│    _____: ______;                   │
│    _____: ______;                   │
│                                     │
│    // 메서드                        │
│    __________________(): ______ {   │
│      // 대출 가능 여부 확인         │
│    }                                │
│                                     │
│    __________________(): ______ {   │
│      // 대출 처리                   │
│    }                                │
│                                     │
│    __________________(): ______ {   │
│      // 반납 처리                   │
│    }                                │
│                                     │
└─────────────────────────────────────┘
```

**필수 고려사항:**
```
□ ISBN은 고유 식별자로 적합한가?
□ 저자는 단일 문자열? 배열?
□ 출판일은 필요한가?
□ 대출 중인지 어떻게 표시할까?
  - isAvailable: boolean?
  - borrowedBy: string | null?
  - currentLoanId: string | null?
```

#### Member 클래스 설계

**[ ] 회원(Member) 클래스 설계**
```
생각해보기:
- 회원을 구분할 고유 ID는?
- 회원 등급을 어떻게 표현할까?
- 대출 중인 책 목록을 어떻게 관리할까?
- 상속을 사용할 필요가 있을까?

내 설계:
┌─────────────────────────────────────┐
│  // 회원 등급 타입                  │
│  type MemberType = ___________      │
│                                     │
│  class Member {                     │
│                                     │
│    // 속성                          │
│    _____: ______;                   │
│    _____: ______;                   │
│    _____: ______;                   │
│    _____: ______;                   │
│                                     │
│    // 메서드                        │
│    __________________(): ______ {   │
│      // 대출 가능 권수 확인         │
│    }                                │
│                                     │
│    __________________(): ______ {   │
│      // 연체 중인지 확인            │
│    }                                │
│                                     │
└─────────────────────────────────────┘
```

**상속 구조 고민:**
```
옵션 1: 단일 Member 클래스
  - memberType 속성으로 구분
  - 간단하지만 타입별 로직이 if문으로 흩어짐

옵션 2: Member 상속 구조
  - abstract Member (추상 클래스)
  - RegularMember extends Member
  - VIPMember extends Member
  - 타입별 로직이 명확하게 분리됨

어떤 방식이 더 좋을까요?
내 선택: ___________________________
이유: _______________________________
```

#### Loan 클래스 설계

**[ ] 대출(Loan) 클래스 설계**
```
생각해보기:
- 대출 정보를 어떻게 저장할까?
- 연체를 어떻게 계산할까?
- 반납 예정일은 어떻게 계산할까?

내 설계:
┌─────────────────────────────────────┐
│  class Loan {                       │
│                                     │
│    // 속성                          │
│    _____: ______;  // 대출 ID       │
│    _____: ______;  // 책 ID         │
│    _____: ______;  // 회원 ID       │
│    _____: ______;  // 대출일        │
│    _____: ______;  // 반납 예정일   │
│    _____: ______;  // 반납일(실제)  │
│                                     │
│    // 메서드                        │
│    __________________(): ______ {   │
│      // 연체 일수 계산              │
│    }                                │
│                                     │
│    __________________(): ______ {   │
│      // 연체 중인지 확인            │
│    }                                │
│                                     │
│    __________________(): ______ {   │
│      // 반납 처리                   │
│    }                                │
│                                     │
└─────────────────────────────────────┘
```

**날짜 처리 고민:**
```
질문:
1. Date 타입을 사용할까? string을 사용할까?
   내 선택: ___________________________
   
2. 반납 예정일을 어떻게 계산할까?
   방법: _______________________________
   
3. 연체 일수를 어떻게 계산할까?
   방법: _______________________________
   
4. 날짜 비교를 어떻게 할까?
   방법: _______________________________
```

#### LibraryManager 클래스 설계

**[ ] 도서관 관리자(LibraryManager) 클래스 설계**
```
생각해보기:
- 모든 엔티티를 관리하는 중앙 클래스
- 어떤 데이터를 보관할까?
- 어떤 기능을 제공할까?

내 설계:
┌─────────────────────────────────────┐
│  class LibraryManager {             │
│                                     │
│    // 속성                          │
│    private books: ______;           │
│    private members: ______;         │
│    private loans: ______;           │
│                                     │
│    // 책 관리                       │
│    addBook(book: Book): ______      │
│    removeBook(isbn: string): ______ │
│    findBook(isbn: string): ______   │
│    searchBooks(query: string): ____ │
│                                     │
│    // 회원 관리                     │
│    registerMember(...): ______      │
│    findMember(id: string): ______   │
│                                     │
│    // 대출 관리                     │
│    borrowBook(...): ______          │
│    returnBook(...): ______          │
│    getOverdueLoans(): ______        │
│                                     │
│    // 통계                          │
│    getStatistics(): ______          │
│                                     │
└─────────────────────────────────────┘
```

---

### 📐 Step 3: 상속 구조 설계

이번 프로젝트의 핵심은 **상속**입니다. 효과적인 상속 구조를 설계해봅시다.

#### 추상 클래스 vs 인터페이스

**[ ] 언제 무엇을 사용할까?**
```
시나리오별 선택:

1. Member를 일반/VIP로 나누기
   □ 인터페이스: IMember
   □ 추상 클래스: abstract Member
   □ 일반 클래스 + 타입 속성
   
   내 선택: ___________________________
   이유: _______________________________

2. Book의 종류 (일반책, 전자책, 정기간행물)
   □ 상속 구조 필요
   □ 단일 클래스로 충분
   
   내 선택: ___________________________
   이유: _______________________________
```

#### Member 상속 구조 설계

**[ ] Member 클래스 계층도 그리기**
```
방법 1: 추상 클래스 사용

         abstract Member
               ↑
      ┌────────┴────────┐
      │                 │
RegularMember      VIPMember
(일반 회원)        (우수 회원)

장점:
- _________________________________
- _________________________________

단점:
- _________________________________
- _________________________________


방법 2: 단일 클래스 + 타입 속성

         Member
    (memberType: "regular" | "vip")

장점:
- _________________________________
- _________________________________

단점:
- _________________________________
- _________________________________


내가 선택한 방법: ___________________
```

**상속 구조를 선택했다면:**
```
abstract Member 설계:
┌─────────────────────────────────────┐
│  abstract class Member {            │
│                                     │
│    // 공통 속성                     │
│    protected _____: ______;         │
│    protected _____: ______;         │
│                                     │
│    // 공통 메서드 (구현 있음)       │
│    __________________(): ______ {   │
│      // 모든 회원이 동일하게 동작  │
│    }                                │
│                                     │
│    // 추상 메서드 (구현 없음)       │
│    abstract getMaxBorrowLimit():    │
│      number;                        │
│                                     │
│    abstract getMembershipFee():     │
│      number;                        │
│                                     │
└─────────────────────────────────────┘

RegularMember 설계:
┌─────────────────────────────────────┐
│  class RegularMember extends        │
│    Member {                         │
│                                     │
│    getMaxBorrowLimit(): number {    │
│      return _____;                  │
│    }                                │
│                                     │
│    getMembershipFee(): number {     │
│      return _____;                  │
│    }                                │
│                                     │
└─────────────────────────────────────┘

VIPMember도 유사하게 설계...
```

---

### ✅ Step 4: 구현 순서 계획

복잡한 시스템이므로 단계별로 구현 순서를 정해봅시다.

**[ ] 구현 우선순위 정하기**
```
1단계 (기초):
  □ _________________________________
  □ _________________________________
  □ _________________________________

2단계 (핵심):
  □ _________________________________
  □ _________________________________
  □ _________________________________

3단계 (고급):
  □ _________________________________
  □ _________________________________
  □ _________________________________

4단계 (완성):
  □ _________________________________
  □ _________________________________
  □ _________________________________
```

**💡 추천 순서:**

<details>
<summary>힌트 보기</summary>
```
1단계: 기본 엔티티
  - Book 클래스 (대출 상태 제외)
  - Member 클래스 or 상속 구조
  - 기본 타입 정의

2단계: 간단한 관리 기능
  - 책 추가/삭제/조회
  - 회원 등록/조회
  - LibraryManager 기본 구조

3단계: 대출 시스템
  - Loan 클래스
  - 대출 기능 (borrowBook)
  - 반납 기능 (returnBook)
  - 대출 가능 여부 검증

4단계: 고급 기능
  - 연체 계산
  - 검색/필터링
  - 통계
  - API 연동 (선택)
```

</details>

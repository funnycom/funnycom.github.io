---
title: "[TS] 제네릭 - 1"
date: 2025-10-14 10:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, 제네릭, Generics]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 제네릭이 무엇이고 왜 필요한지 이해한다
> - 제네릭 함수를 작성할 수 있다
> - 제네릭 인터페이스와 타입을 정의할 수 있다
> - 제네릭 제약조건을 사용할 수 있다
> - 실전에서 제네릭을 활용할 수 있다

---

## 제네릭이 필요한 이유

지금까지 우리는 특정 타입에만 동작하는 함수를 작성했습니다. 예를 들어 배열의 첫 번째 요소를 반환하는 함수를 만든다면:

```typescript
// 숫자 배열용
function getFirstNumber(arr: number[]): number {
  return arr[0];
}

// 문자열 배열용
function getFirstString(arr: string[]): string {
  return arr[0];
}

// 불린 배열용
function getFirstBoolean(arr: boolean[]): boolean {
  return arr[0];
}

const num = getFirstNumber([1, 2, 3]);        // 1
const str = getFirstString(["a", "b", "c"]);  // "a"
const bool = getFirstBoolean([true, false]);  // true
```

이 세 함수는 로직이 완전히 똑같습니다! 타입만 다를 뿐이죠. 이런 상황에서 코드를 반복해서 작성하는 것은 비효율적입니다. 만약 새로운 타입을 추가해야 한다면? 또 새로운 함수를 만들어야 할까요?

**any를 사용하면 어떨까요?**

```typescript
function getFirst(arr: any[]): any {
  return arr[0];
}

const num = getFirst([1, 2, 3]);        // any 타입
const str = getFirst(["a", "b", "c"]);  // any 타입
```

`any`를 사용하면 하나의 함수로 모든 타입을 처리할 수 있지만, 큰 문제가 있습니다. 반환 타입도 `any`가 되어 타입 안정성을 완전히 잃게 됩니다.

```typescript
const num = getFirst([1, 2, 3]);
// num은 any 타입이므로 아무 메서드나 호출 가능
num.toUpperCase();  // 컴파일 에러 없음! 하지만 런타임 에러 발생
```

**제네릭이 해결책입니다!**

제네릭을 사용하면 타입 안정성을 유지하면서 재사용 가능한 함수를 만들 수 있습니다.

```typescript
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

const num = getFirst([1, 2, 3]);        // number 타입
const str = getFirst(["a", "b", "c"]);  // string 타입
const bool = getFirst([true, false]);   // boolean 타입

// num.toUpperCase();  // ✅ 컴파일 에러! number에는 toUpperCase가 없음
str.toUpperCase();     // ✅ OK! string에는 toUpperCase가 있음
```

**시각적 이해:**

```
일반 함수 (특정 타입만)
┌──────────────┐
│ number[] 입력 │ → 함수 → number 출력
└──────────────┘

제네릭 함수 (모든 타입)
┌──────────────┐
│  T[] 입력     │ → 함수 → T 출력
└──────────────┘
   ↓ 호출 시점에 T가 결정됨
   
number[]로 호출 → T는 number
string[]로 호출 → T는 string
boolean[]로 호출 → T는 boolean
```

**제네릭의 장점:**

1. **코드 재사용**: 하나의 함수로 여러 타입 처리
2. **타입 안정성**: `any`와 달리 타입 정보 유지
3. **가독성**: 의도가 명확한 코드
4. **유지보수성**: 중복 코드 감소

---

## 제네릭 함수

제네릭 함수는 타입을 매개변수처럼 받을 수 있는 함수입니다. 함수 이름 뒤에 꺾쇠괄호(`<>`) 안에 타입 매개변수를 선언합니다.

### 기본 제네릭 함수

```typescript
// T는 타입 매개변수 (Type Parameter)
function identity<T>(value: T): T {
  return value;
}

// 사용 방법 1: 타입 명시
const num1 = identity<number>(42);
const str1 = identity<string>("hello");

// 사용 방법 2: 타입 추론 (더 일반적)
const num2 = identity(42);      // TypeScript가 T를 number로 추론
const str2 = identity("hello");  // TypeScript가 T를 string으로 추론

console.log(num2);  // 42
console.log(str2);  // hello
```

타입 매개변수는 관례적으로 대문자 `T`를 사용하지만, 의미있는 이름을 사용할 수도 있습니다.

```typescript
// 관례적인 이름들
function example1<T>(value: T): T { }           // T (Type)
function example2<K, V>(key: K, value: V) { }   // K (Key), V (Value)
function example3<E>(element: E): E[] { }       // E (Element)

// 의미있는 이름
function wrap<Item>(item: Item): Item[] {
  return [item];
}

const numbers = wrap(42);         // number[]
const strings = wrap("hello");    // string[]
```

### 실전 예제: 배열 유틸리티 함수

제네릭을 사용하여 모든 타입의 배열에서 동작하는 유틸리티 함수를 만들어봅시다.

```typescript
// 배열의 마지막 요소 반환
function getLast<T>(arr: T[]): T | undefined {
  if (arr.length === 0) {
    return undefined;
  }
  return arr[arr.length - 1];
}

console.log(getLast([1, 2, 3]));        // 3
console.log(getLast(["a", "b", "c"]));  // "c"
console.log(getLast([]));               // undefined

// 배열 뒤집기
function reverse<T>(arr: T[]): T[] {
  const result: T[] = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
}

console.log(reverse([1, 2, 3]));           // [3, 2, 1]
console.log(reverse(["a", "b", "c"]));     // ["c", "b", "a"]

// 배열에서 조건에 맞는 첫 번째 요소 찾기
function find<T>(arr: T[], predicate: (item: T) => boolean): T | undefined {
  for (const item of arr) {
    if (predicate(item)) {
      return item;
    }
  }
  return undefined;
}

const numbers = [1, 2, 3, 4, 5];
const firstEven = find(numbers, (n) => n % 2 === 0);
console.log(firstEven);  // 2

const words = ["apple", "banana", "cherry"];
const longWord = find(words, (w) => w.length > 5);
console.log(longWord);  // "banana"
```

### 여러 타입 매개변수 사용하기

함수가 여러 개의 서로 다른 타입을 다루어야 할 때는 여러 타입 매개변수를 사용할 수 있습니다.

```typescript
// 두 값을 쌍으로 묶기
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const pair1 = pair("name", 25);           // [string, number]
const pair2 = pair(true, "yes");          // [boolean, string]
const pair3 = pair(100, [1, 2, 3]);       // [number, number[]]

console.log(pair1);  // ["name", 25]
console.log(pair2);  // [true, "yes"]
console.log(pair3);  // [100, [1, 2, 3]]

// 객체 생성하기
function createPair<K, V>(key: K, value: V): { key: K; value: V } {
  return { key, value };
}

const obj1 = createPair("age", 25);
console.log(obj1);  // { key: "age", value: 25 }

const obj2 = createPair(1, "first");
console.log(obj2);  // { key: 1, value: "first" }

// 두 배열을 합치기
function merge<T, U>(arr1: T[], arr2: U[]): (T | U)[] {
  return [...arr1, ...arr2];
}

const merged1 = merge([1, 2], ["a", "b"]);
console.log(merged1);  // [1, 2, "a", "b"]

const merged2 = merge([true], [1, 2, 3]);
console.log(merged2);  // [true, 1, 2, 3]
```

**실전 예제: 키-값 저장소**

```typescript
// 간단한 키-값 저장소
class SimpleStorage<K, V> {
  private storage = new Map<K, V>();
  
  set(key: K, value: V): void {
    this.storage.set(key, value);
    console.log(\`저장됨: \${key} → \${value}\`);
  }
  
  get(key: K): V | undefined {
    return this.storage.get(key);
  }
  
  has(key: K): boolean {
    return this.storage.has(key);
  }
  
  delete(key: K): boolean {
    const result = this.storage.delete(key);
    if (result) {
      console.log(\`삭제됨: \${key}\`);
    }
    return result;
  }
  
  getAll(): [K, V][] {
    return Array.from(this.storage.entries());
  }
}

// 문자열 키, 숫자 값
const numberStorage = new SimpleStorage<string, number>();
numberStorage.set("age", 25);
numberStorage.set("score", 95);
console.log(numberStorage.get("age"));  // 25

// 숫자 키, 문자열 값
const stringStorage = new SimpleStorage<number, string>();
stringStorage.set(1, "first");
stringStorage.set(2, "second");
console.log(stringStorage.get(1));  // "first"

// 모든 항목 출력
console.log(numberStorage.getAll());  // [["age", 25], ["score", 95]]
```

---

## 제네릭 인터페이스와 타입

제네릭은 함수뿐만 아니라 인터페이스와 타입 별칭에도 사용할 수 있습니다. 이를 통해 재사용 가능한 타입을 정의할 수 있습니다.

### 제네릭 인터페이스

```typescript
// 제네릭 인터페이스 정의
interface Box<T> {
  value: T;
}

// 사용
const numberBox: Box<number> = { value: 42 };
const stringBox: Box<string> = { value: "hello" };
const booleanBox: Box<boolean> = { value: true };

console.log(numberBox.value);   // 42
console.log(stringBox.value);   // "hello"
console.log(booleanBox.value);  // true
```

**시각적 이해:**

```
Box<T> 인터페이스
┌─────────────┐
│    Box      │
│  ┌───────┐  │
│  │   T   │  │  ← T는 무엇이든 될 수 있음
│  └───────┘  │
└─────────────┘

사용할 때:
Box<number>     Box<string>     Box<boolean>
┌─────────┐    ┌─────────┐     ┌─────────┐
│   42    │    │ "hello" │     │  true   │
└─────────┘    └─────────┘     └─────────┘
```

### 실전 예제: API 응답 래퍼

실제 프로젝트에서는 API 응답을 감싸는 공통 구조가 필요할 때가 많습니다.

```typescript
// 성공 응답
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
}

// 실패 응답
interface ErrorResponse {
  success: false;
  error: string;
  errorCode?: number;
}

// API 응답 타입 (유니온)
type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

// 사용자 정보 인터페이스
interface User {
  id: number;
  name: string;
  email: string;
}

// 상품 정보 인터페이스
interface Product {
  id: number;
  name: string;
  price: number;
}

// 다양한 타입의 API 응답 처리
function handleUserResponse(response: ApiResponse<User>): void {
  if (response.success) {
    console.log("사용자 정보:", response.data.name);
    console.log("이메일:", response.data.email);
  } else {
    console.log("에러:", response.error);
  }
}

function handleProductResponse(response: ApiResponse<Product[]>): void {
  if (response.success) {
    console.log(\`\${response.data.length}개의 상품을 찾았습니다.\`);
    response.data.forEach(product => {
      console.log(\`- \${product.name}: \${product.price}원\`);
    });
  } else {
    console.log("에러:", response.error);
  }
}

// 테스트
const userSuccess: ApiResponse<User> = {
  success: true,
  data: {
    id: 1,
    name: "홍길동",
    email: "hong@example.com"
  }
};

const userError: ApiResponse<User> = {
  success: false,
  error: "사용자를 찾을 수 없습니다",
  errorCode: 404
};

const productSuccess: ApiResponse<Product[]> = {
  success: true,
  data: [
    { id: 1, name: "노트북", price: 1000000 },
    { id: 2, name: "마우스", price: 30000 }
  ]
};

handleUserResponse(userSuccess);
handleUserResponse(userError);
handleProductResponse(productSuccess);
```

### 제네릭 타입 별칭

타입 별칭에도 제네릭을 사용할 수 있습니다.

```typescript
// 제네릭 타입 별칭
type Result<T> = {
  success: boolean;
  data: T;
  timestamp: Date;
};

type Nullable<T> = T | null;
type Optional<T> = T | undefined;
type ArrayOrSingle<T> = T | T[];

// 사용
const result1: Result<string> = {
  success: true,
  data: "완료",
  timestamp: new Date()
};

const result2: Result<number[]> = {
  success: true,
  data: [1, 2, 3],
  timestamp: new Date()
};

let name: Nullable<string> = "홍길동";
name = null;  // ✅ OK

let age: Optional<number> = 25;
age = undefined;  // ✅ OK

let id: ArrayOrSingle<number> = 1;
id = [1, 2, 3];  // ✅ OK
```

### 여러 타입 매개변수를 가진 인터페이스

```typescript
// 키-값 쌍 인터페이스
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

// 사용
const pair1: KeyValuePair<string, number> = {
  key: "age",
  value: 25
};

const pair2: KeyValuePair<number, string> = {
  key: 1,
  value: "first"
};

console.log(\`\${pair1.key}: \${pair1.value}\`);  // age: 25
console.log(\`\${pair2.key}: \${pair2.value}\`);  // 1: first

// 딕셔너리 인터페이스
interface Dictionary<K, V> {
  set(key: K, value: V): void;
  get(key: K): V | undefined;
  has(key: K): boolean;
  delete(key: K): boolean;
}

// 구현
class SimpleDictionary<K, V> implements Dictionary<K, V> {
  private items = new Map<K, V>();
  
  set(key: K, value: V): void {
    this.items.set(key, value);
  }
  
  get(key: K): V | undefined {
    return this.items.get(key);
  }
  
  has(key: K): boolean {
    return this.items.has(key);
  }
  
  delete(key: K): boolean {
    return this.items.delete(key);
  }
}

const dict = new SimpleDictionary<string, number>();
dict.set("one", 1);
dict.set("two", 2);
console.log(dict.get("one"));  // 1
console.log(dict.has("three"));  // false
```

---

## 제네릭 제약조건 (Generic Constraints)

때로는 제네릭 타입이 특정 조건을 만족해야 할 때가 있습니다. 예를 들어, 길이를 가진 타입만 받고 싶다거나, 특정 속성을 가진 타입만 받고 싶을 때가 있습니다. 이럴 때 제네릭 제약조건을 사용합니다.

### extends를 사용한 제약조건

`extends` 키워드를 사용하여 타입 매개변수가 특정 타입을 확장하도록 제한할 수 있습니다.

```typescript
// 길이를 가진 타입만 허용
interface HasLength {
  length: number;
}

function getLength<T extends HasLength>(item: T): number {
  return item.length;
}

// ✅ OK - 모두 length 속성을 가짐
console.log(getLength("hello"));        // 5
console.log(getLength([1, 2, 3]));      // 3
console.log(getLength({ length: 10 })); // 10

// ❌ 에러 - length 속성이 없음
// console.log(getLength(123));
// console.log(getLength(true));
```

**왜 제약조건이 필요할까요?**

제약조건 없이 작성하면 에러가 발생합니다:

```typescript
// ❌ 제약조건 없음
function getLengthBad<T>(item: T): number {
  // return item.length;  // 에러! T에 length가 있다는 보장이 없음
}

// ✅ 제약조건 있음
function getLengthGood<T extends HasLength>(item: T): number {
  return item.length;  // OK! T는 반드시 length를 가짐
}
```

### 실전 예제: 배열이나 문자열만 받기

```typescript
// 배열이나 문자열만 받는 함수
type ArrayOrString<T> = T[] | string;

function printItems<T>(items: ArrayOrString<T>): void {
  if (typeof items === "string") {
    console.log("문자열:", items);
    for (const char of items) {
      console.log(\`  - \${char}\`);
    }
  } else {
    console.log("배열:", items);
    items.forEach(item => {
      console.log(\`  - \${item}\`);
    });
  }
}

printItems("hello");
// 문자열: hello
//   - h
//   - e
//   - l
//   - l
//   - o

printItems([1, 2, 3]);
// 배열: [1, 2, 3]
//   - 1
//   - 2
//   - 3
```

### 객체의 키로 제약하기

객체의 특정 키에만 접근하도록 제한할 수 있습니다.

```typescript
// K는 T의 키 중 하나여야 함
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = {
  name: "홍길동",
  age: 25,
  city: "서울"
};

const name = getProperty(person, "name");  // ✅ OK
const age = getProperty(person, "age");    // ✅ OK

// const invalid = getProperty(person, "email");  // ❌ 에러! email은 person의 키가 아님

console.log(name);  // "홍길동"
console.log(age);   // 25
```

**시각적 이해:**

```
person 객체
┌─────────────┐
│ name: "..."  │
│ age: 25     │ ← keyof T는 "name" | "age" | "city"
│ city: "..." │
└─────────────┘

K extends keyof T
→ K는 "name", "age", "city" 중 하나여야 함
```

**실전 예제: 객체 업데이트 함수**

```typescript
// 객체의 특정 속성만 업데이트
function updateProperty<T, K extends keyof T>(
  obj: T,
  key: K,
  value: T[K]
): void {
  obj[key] = value;
  console.log(\`\${String(key)}이(가) \${value}(으)로 업데이트되었습니다.\`);
}

interface User {
  name: string;
  age: number;
  email: string;
}

const user: User = {
  name: "홍길동",
  age: 25,
  email: "hong@example.com"
};

updateProperty(user, "name", "김철수");  // ✅ OK
updateProperty(user, "age", 30);        // ✅ OK

// updateProperty(user, "age", "30");  // ❌ 에러! age는 number여야 함
// updateProperty(user, "phone", "010-1234-5678");  // ❌ 에러! phone은 User의 키가 아님

console.log(user);
// { name: "김철수", age: 30, email: "hong@example.com" }
```

### 여러 제약조건 결합하기

```typescript
// 이름과 나이를 모두 가진 타입만 허용
interface Named {
  name: string;
}

interface Aged {
  age: number;
}

function printInfo<T extends Named & Aged>(obj: T): void {
  console.log(\`이름: \${obj.name}\`);
  console.log(\`나이: \${obj.age}세\`);
}

// ✅ OK - 둘 다 가짐
printInfo({ name: "홍길동", age: 25 });
printInfo({ name: "김철수", age: 30, city: "서울" });  // 추가 속성도 OK

// ❌ 에러 - name이 없음
// printInfo({ age: 25 });

// ❌ 에러 - age가 없음
// printInfo({ name: "이영희" });
```

---

## 제네릭 클래스

클래스에도 제네릭을 사용할 수 있습니다. 제네릭 클래스는 다양한 타입의 데이터를 다루는 컬렉션이나 컨테이너를 만들 때 유용합니다.

### 기본 제네릭 클래스

```typescript
// 제네릭 스택 (LIFO - Last In First Out)
class Stack<T> {
  private items: T[] = [];
  
  // 추가
  push(item: T): void {
    this.items.push(item);
    console.log(\`추가됨: \${item}\`);
  }
  
  // 제거하고 반환
  pop(): T | undefined {
    const item = this.items.pop();
    if (item !== undefined) {
      console.log(\`제거됨: \${item}\`);
    }
    return item;
  }
  
  // 최상단 확인
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }
  
  // 비어있는지 확인
  isEmpty(): boolean {
    return this.items.length === 0;
  }
  
  // 크기
  size(): number {
    return this.items.length;
  }
  
  // 모든 항목 출력
  print(): void {
    console.log("스택:", this.items);
  }
}

// 숫자 스택
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
numberStack.push(3);
numberStack.print();        // [1, 2, 3]
console.log(numberStack.pop());  // 3
numberStack.print();        // [1, 2]

// 문자열 스택
const stringStack = new Stack<string>();
stringStack.push("first");
stringStack.push("second");
stringStack.push("third");
console.log(stringStack.peek());  // "third"
stringStack.print();              // ["first", "second", "third"]
```

### 실전 예제: 제네릭 큐 (Queue)

큐는 먼저 들어간 것이 먼저 나오는 FIFO(First In First Out) 자료구조입니다.

```typescript
class Queue<T> {
  private items: T[] = [];
  
  // 뒤에 추가
  enqueue(item: T): void {
    this.items.push(item);
    console.log(\`대기열에 추가: \${item}\`);
  }
  
  // 앞에서 제거하고 반환
  dequeue(): T | undefined {
    if (this.isEmpty()) {
      console.log("대기열이 비어있습니다");
      return undefined;
    }
    const item = this.items.shift();
    console.log(\`처리됨: \${item}\`);
    return item;
  }
  
  // 맨 앞 확인
  front(): T | undefined {
    return this.items[0];
  }
  
  // 비어있는지 확인
  isEmpty(): boolean {
    return this.items.length === 0;
  }
  
  // 크기
  size(): number {
    return this.items.length;
  }
  
  // 모든 항목 출력
  print(): void {
    console.log("대기열:", this.items);
  }
}

// 고객 서비스 대기열
interface Customer {
  name: string;
  ticketNumber: number;
}

const customerQueue = new Queue<Customer>();

customerQueue.enqueue({ name: "홍길동", ticketNumber: 1 });
customerQueue.enqueue({ name: "김철수", ticketNumber: 2 });
customerQueue.enqueue({ name: "이영희", ticketNumber: 3 });

customerQueue.print();
// 대기열: [
//   { name: "홍길동", ticketNumber: 1 },
//   { name: "김철수", ticketNumber: 2 },
//   { name: "이영희", ticketNumber: 3 }
// ]

console.log("다음 고객:", customerQueue.front());
// { name: "홍길동", ticketNumber: 1 }

customerQueue.dequeue();  // 처리됨: 홍길동
customerQueue.dequeue();  // 처리됨: 김철수

customerQueue.print();
// 대기열: [{ name: "이영희", ticketNumber: 3 }]
```

### 실전 예제: 제네릭 리스트

```typescript
class ArrayList<T> {
  private items: T[] = [];
  
  // 추가
  add(item: T): void {
    this.items.push(item);
  }
  
  // 인덱스로 가져오기
  get(index: number): T | undefined {
    if (index < 0 || index >= this.items.length) {
      return undefined;
    }
    return this.items[index];
  }
  
  // 인덱스로 제거
  remove(index: number): T | undefined {
    if (index < 0 || index >= this.items.length) {
      return undefined;
    }
    return this.items.splice(index, 1)[0];
  }
  
  // 조건에 맞는 항목 찾기
  find(predicate: (item: T) => boolean): T | undefined {
    return this.items.find(predicate);
  }
  
  // 조건에 맞는 항목 필터링
  filter(predicate: (item: T) => boolean): T[] {
    return this.items.filter(predicate);
  }
  
  // 변환
  map<U>(transform: (item: T) => U): U[] {
    return this.items.map(transform);
  }
  
  // 크기
  size(): number {
    return this.items.length;
  }
  
  // 모든 항목 가져오기
  toArray(): T[] {
    return [...this.items];
  }
  
  // 출력
  print(): void {
    console.log(this.items);
  }
}

// 사용 예시
interface Task {
  id: number;
  title: string;
  completed: boolean;
}

const taskList = new ArrayList<Task>();

taskList.add({ id: 1, title: "TypeScript 공부하기", completed: false });
taskList.add({ id: 2, title: "제네릭 이해하기", completed: true });
taskList.add({ id: 3, title: "프로젝트 만들기", completed: false });

console.log("전체 작업:");
taskList.print();

// 완료된 작업 찾기
const completed = taskList.filter(task => task.completed);
console.log("\n완료된 작업:", completed);

// 미완료 작업 찾기
const incomplete = taskList.filter(task => !task.completed);
console.log("미완료 작업:", incomplete);

// 작업 제목만 추출
const titles = taskList.map(task => task.title);
console.log("\n작업 제목들:", titles);

// 특정 작업 찾기
const task = taskList.find(t => t.id === 2);
console.log("\nID 2인 작업:", task);
```

---

## 제네릭 유틸리티 함수 만들기

제네릭을 활용하여 재사용 가능한 유틸리티 함수를 만들어봅시다.

### 배열 유틸리티

```typescript
// 배열을 N개씩 묶기
function chunk<T>(array: T[], size: number): T[][] {
  const result: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }
  return result;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(chunk(numbers, 3));
// [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

const letters = ["a", "b", "c", "d", "e"];
console.log(chunk(letters, 2));
// [["a", "b"], ["c", "d"], ["e"]]

// 배열에서 중복 제거
function unique<T>(array: T[]): T[] {
  return Array.from(new Set(array));
}

console.log(unique([1, 2, 2, 3, 3, 3, 4]));
// [1, 2, 3, 4]

console.log(unique(["a", "b", "a", "c", "b"]));
// ["a", "b", "c"]

// 배열 섞기
function shuffle<T>(array: T[]): T[] {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

console.log(shuffle([1, 2, 3, 4, 5]));
// [3, 1, 5, 2, 4] (랜덤)

// 배열을 특정 개수만큼 무작위로 선택
function sample<T>(array: T[], count: number): T[] {
  const shuffled = shuffle(array);
  return shuffled.slice(0, Math.min(count, array.length));
}

console.log(sample([1, 2, 3, 4, 5], 3));
// [2, 5, 1] (랜덤하게 3개 선택)
```

### 객체 유틸리티

```typescript
// 객체의 특정 키만 선택
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;
  keys.forEach(key => {
    result[key] = obj[key];
  });
  return result;
}

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  city: string;
}

const user: User = {
  id: 1,
  name: "홍길동",
  email: "hong@example.com",
  age: 25,
  city: "서울"
};

const basicInfo = pick(user, ["name", "email"]);
console.log(basicInfo);
// { name: "홍길동", email: "hong@example.com" }

// 객체의 특정 키 제외
function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const result = { ...obj };
  keys.forEach(key => {
    delete result[key];
  });
  return result;
}

const publicInfo = omit(user, ["id", "email"]);
console.log(publicInfo);
// { name: "홍길동", age: 25, city: "서울" }

// 두 객체 병합
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const person = { name: "홍길동", age: 25 };
const contact = { email: "hong@example.com", phone: "010-1234-5678" };

const merged = merge(person, contact);
console.log(merged);
// {
//   name: "홍길동",
//   age: 25,
//   email: "hong@example.com",
//   phone: "010-1234-5678"
// }
```

### 비동기 유틸리티

```typescript
// 지연 실행
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 재시도 로직
async function retry<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  delayMs: number = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      console.log(\`시도 \${attempt}/\${maxAttempts}\`);
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) {
        throw error;
      }
      console.log(\`실패. \${delayMs}ms 후 재시도...\`);
      await delay(delayMs);
    }
  }
  throw new Error("모든 시도 실패");
}

// 타임아웃
async function timeout<T>(
  promise: Promise<T>,
  ms: number
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) => 
      setTimeout(() => reject(new Error("시간 초과")), ms)
    )
  ]);
}

// 사용 예시
async function fetchData(): Promise<string> {
  // 50% 확률로 성공
  if (Math.random() > 0.5) {
    return "데이터";
  }
  throw new Error("네트워크 오류");
}

// retry(fetchData, 3, 500)
//   .then(data => console.log("성공:", data))
//   .catch(error => console.log("실패:", error.message));
```

---

## 제네릭 활용 팁

제네릭을 효과적으로 사용하기 위한 실전 팁들입니다.

### 팁 1: 기본 타입 매개변수

타입 매개변수에 기본값을 지정할 수 있습니다.

```typescript
// 기본 타입은 string
interface Container<T = string> {
  value: T;
}

const stringContainer: Container = { value: "hello" };  // Container<string>
const numberContainer: Container<number> = { value: 42 };

// 기본값이 있는 제네릭 함수
function createArray<T = number>(length: number, value: T): T[] {
  return Array(length).fill(value);
}

const numbers = createArray(5, 0);      // number[]
const strings = createArray(3, "hi");   // string[]
```

### 팁 2: 조건부 타입과 제네릭

```typescript
// T가 배열이면 요소 타입, 아니면 T 그대로
type Unwrap<T> = T extends Array<infer U> ? U : T;

type Test1 = Unwrap<number[]>;    // number
type Test2 = Unwrap<string[]>;    // string
type Test3 = Unwrap<boolean>;     // boolean

// 실전 예제: 반환 타입 추출
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getString(): string {
  return "hello";
}

type Result = ReturnType<typeof getString>;  // string
```

### 팁 3: 제네릭과 유니온 타입

```typescript
// 배열이거나 단일 값을 받는 함수
function toArray<T>(input: T | T[]): T[] {
  return Array.isArray(input) ? input : [input];
}

console.log(toArray(1));           // [1]
console.log(toArray([1, 2, 3]));   // [1, 2, 3]
console.log(toArray("hello"));     // ["hello"]
```

### 팁 4: 제네릭 타입 가드

```typescript
// 타입 가드 함수
function isArray<T>(value: T | T[]): value is T[] {
  return Array.isArray(value);
}

function processValue<T>(value: T | T[]): void {
  if (isArray(value)) {
    console.log(\`배열 길이: \${value.length}\`);
    value.forEach(item => console.log(item));
  } else {
    console.log(\`단일 값: \${value}\`);
  }
}

processValue(42);           // 단일 값: 42
processValue([1, 2, 3]);    // 배열 길이: 3
```

### 주의사항

**1. 제네릭을 남용하지 마세요**

```typescript
// ❌ 불필요한 제네릭
function add<T>(a: number, b: number): number {
  return a + b;
}

// ✅ 간단하게
function add(a: number, b: number): number {
  return a + b;
}
```

**2. 의미있는 타입 매개변수 이름 사용하기**

```typescript
// ❌ 의미 없는 이름
function process<A, B, C>(a: A, b: B): C {
  // ...
}

// ✅ 의미있는 이름
function transform<Input, Output>(data: Input): Output {
  // ...
}
```

**3. 제약조건을 적절히 사용하기**

```typescript
// ❌ 너무 제한적
function print<T extends string>(value: T): void {
  console.log(value);
}

// ✅ 적절한 제약
function print<T>(value: T): void {
  console.log(value);
}
```

---

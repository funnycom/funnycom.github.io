---
title: "[TS] 인터페이스와 타입 별칭 - 1"
date: 2025-10-14 15:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, ts함수]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 인터페이스로 객체 구조를 정의할 수 있다
> - 타입 별칭을 사용하여 타입에 이름을 붙일 수 있다
> - 인터페이스를 확장하고 병합할 수 있다
> - 인터페이스와 타입 별칭의 차이를 이해하고 적절히 선택할 수 있다

---

## 왜 인터페이스와 타입 별칭이 필요한가?

지금까지 우리는 객체 타입을 이렇게 정의했습니다:

```typescript
let user1: { name: string; age: number; email: string };
let user2: { name: string; age: number; email: string };
let user3: { name: string; age: number; email: string };
```

같은 구조를 계속 반복해서 작성하는 것은 비효율적입니다. 또한 나중에 구조를 변경하려면 모든 곳을 찾아서 수정해야 합니다. 만약 사용자 타입에 `phone` 속성을 추가하려면 어떻게 될까요? 세 곳 모두 수정해야 합니다!

인터페이스와 타입 별칭을 사용하면 타입에 이름을 붙여서 재사용할 수 있습니다.

```typescript
// 인터페이스로 정의
interface User {
  name: string;
  age: number;
  email: string;
}

// 이제 간단하게 사용
let user1: User;
let user2: User;
let user3: User;
```

**장점:**
- 코드 중복 제거
- 유지보수 용이 (한 곳만 수정하면 됨)
- 코드 의미가 명확해짐
- 자동완성 지원

---

## 인터페이스 (Interface)

인터페이스는 객체의 "설계도"입니다. 객체가 어떤 속성과 메서드를 가져야 하는지 정의합니다.

### 기본 인터페이스 정의

인터페이스는 `interface` 키워드로 정의합니다. 관례적으로 인터페이스 이름은 대문자로 시작합니다.

```typescript
// 사용자 인터페이스 정의
interface User {
  name: string;
  age: number;
  email: string;
}

// 인터페이스 사용
const user: User = {
  name: "홍길동",
  age: 25,
  email: "hong@example.com"
};

console.log(\`이름: \${user.name}\`);
console.log(\`나이: \${user.age}세\`);
console.log(\`이메일: \${user.email}\`);
```

인터페이스를 사용하면 객체가 정확한 구조를 가지고 있는지 TypeScript가 확인해줍니다.

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

// ❌ 에러! email 속성이 없음
const user1: User = {
  name: "홍길동",
  age: 25
};

// ❌ 에러! age는 number여야 함
const user2: User = {
  name: "김철수",
  age: "25",
  email: "kim@example.com"
};

// ✅ 올바름
const user3: User = {
  name: "이영희",
  age: 30,
  email: "lee@example.com"
};
```

**실전 예제:**

```typescript
// 상품 인터페이스
interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
  inStock: boolean;
}

// 상품 목록
const products: Product[] = [
  {
    id: 1,
    name: "노트북",
    price: 1000000,
    category: "전자제품",
    inStock: true
  },
  {
    id: 2,
    name: "마우스",
    price: 30000,
    category: "전자제품",
    inStock: true
  },
  {
    id: 3,
    name: "키보드",
    price: 80000,
    category: "전자제품",
    inStock: false
  }
];

// 상품 정보 출력 함수
function printProduct(product: Product): void {
  console.log(\`[\${product.id}] \${product.name}\`);
  console.log(\`  가격: \${product.price.toLocaleString()}원\`);
  console.log(\`  카테고리: \${product.category}\`);
  console.log(\`  재고: \${product.inStock ? "있음" : "없음"}\`);
}

products.forEach(printProduct);
```

### 선택적 속성과 읽기 전용 속성

Chapter 7에서 배운 것처럼 인터페이스에도 선택적 속성과 읽기 전용 속성을 정의할 수 있습니다.

```typescript
interface User {
  readonly id: number;      // 읽기 전용 (변경 불가)
  name: string;
  age: number;
  email?: string;           // 선택적 속성 (있어도 되고 없어도 됨)
  phone?: string;           // 선택적 속성
}

const user: User = {
  id: 1,
  name: "홍길동",
  age: 25
  // email과 phone은 생략 가능
};

console.log(user.id);     // ✅ 읽기는 가능
// user.id = 2;           // ❌ 에러! readonly는 수정 불가

user.name = "김철수";     // ✅ 일반 속성은 수정 가능

// 선택적 속성 사용 시 체크
if (user.email) {
  console.log(\`이메일: \${user.email}\`);
} else {
  console.log("이메일 없음");
}
```

**선택적 속성 활용 예제:**

```typescript
// 블로그 포스트 인터페이스
interface BlogPost {
  readonly id: number;
  title: string;
  content: string;
  author: string;
  createdAt: Date;
  updatedAt?: Date;        // 수정되지 않았으면 없을 수 있음
  tags?: string[];         // 태그가 없을 수도 있음
  viewCount?: number;      // 조회수가 집계되지 않았을 수도 있음
}

function createPost(title: string, content: string, author: string): BlogPost {
  return {
    id: Date.now(),
    title,
    content,
    author,
    createdAt: new Date()
    // 나머지는 선택적이므로 생략 가능
  };
}

function printPost(post: BlogPost): void {
  console.log(\`제목: \${post.title}\`);
  console.log(\`작성자: \${post.author}\`);
  console.log(\`작성일: \${post.createdAt.toLocaleDateString()}\`);
  
  if (post.updatedAt) {
    console.log(\`수정일: \${post.updatedAt.toLocaleDateString()}\`);
  }
  
  if (post.tags && post.tags.length > 0) {
    console.log(\`태그: \${post.tags.join(", ")}\`);
  }
  
  console.log(\`조회수: \${post.viewCount || 0}회\`);
}

const post = createPost(
  "TypeScript 입문",
  "TypeScript를 배워봅시다!",
  "홍길동"
);

printPost(post);
```

### 메서드가 있는 인터페이스

인터페이스는 속성뿐만 아니라 메서드(함수)도 정의할 수 있습니다.

```typescript
interface Calculator {
  // 속성
  brand: string;
  model: string;
  
  // 메서드
  add(a: number, b: number): number;
  subtract(a: number, b: number): number;
  multiply(a: number, b: number): number;
  divide(a: number, b: number): number;
}

const myCalculator: Calculator = {
  brand: "Samsung",
  model: "SCI-100",
  
  add(a: number, b: number): number {
    return a + b;
  },
  
  subtract(a: number, b: number): number {
    return a - b;
  },
  
  multiply(a: number, b: number): number {
    return a * b;
  },
  
  divide(a: number, b: number): number {
    if (b === 0) {
      throw new Error("0으로 나눌 수 없습니다");
    }
    return a / b;
  }
};

console.log(\`\${myCalculator.brand} \${myCalculator.model}\`);
console.log(\`10 + 5 = \${myCalculator.add(10, 5)}\`);
console.log(\`10 - 5 = \${myCalculator.subtract(10, 5)}\`);
console.log(\`10 × 5 = \${myCalculator.multiply(10, 5)}\`);
console.log(\`10 ÷ 5 = \${myCalculator.divide(10, 5)}\`);
```

**실전 예제: 게임 캐릭터**

```typescript
interface Character {
  // 속성
  readonly id: number;
  name: string;
  level: number;
  hp: number;
  maxHp: number;
  attack: number;
  
  // 메서드
  takeDamage(damage: number): void;
  heal(amount: number): void;
  levelUp(): void;
  getStatus(): string;
}

const warrior: Character = {
  id: 1,
  name: "전사",
  level: 1,
  hp: 100,
  maxHp: 100,
  attack: 20,
  
  takeDamage(damage: number): void {
    this.hp = Math.max(0, this.hp - damage);
    console.log(\`\${this.name}이(가) \${damage}의 피해를 입었습니다.\`);
    console.log(\`남은 HP: \${this.hp}/\${this.maxHp}\`);
    
    if (this.hp === 0) {
      console.log(\`\${this.name}이(가) 쓰러졌습니다!\`);
    }
  },
  
  heal(amount: number): void {
    const oldHp = this.hp;
    this.hp = Math.min(this.maxHp, this.hp + amount);
    const actualHeal = this.hp - oldHp;
    console.log(\`\${this.name}이(가) \${actualHeal}만큼 회복했습니다.\`);
    console.log(\`현재 HP: \${this.hp}/\${this.maxHp}\`);
  },
  
  levelUp(): void {
    this.level++;
    this.maxHp += 20;
    this.hp = this.maxHp;
    this.attack += 5;
    console.log(\`\${this.name}의 레벨이 \${this.level}(으)로 올랐습니다!\`);
    console.log(\`최대 HP: \${this.maxHp}, 공격력: \${this.attack}\`);
  },
  
  getStatus(): string {
    return \`[\${this.name}] Lv.\${this.level} HP:\${this.hp}/\${this.maxHp} ATK:\${this.attack}\`;
  }
};

console.log("=== 게임 시작 ===");
console.log(warrior.getStatus());

warrior.takeDamage(30);
warrior.heal(15);
warrior.levelUp();
console.log(warrior.getStatus());
```

---

## 인터페이스 확장 (Extension)

인터페이스는 다른 인터페이스를 확장하여 새로운 인터페이스를 만들 수 있습니다. 이는 코드 재사용성을 높이고 계층 구조를 표현하는 데 유용합니다.

### 기본 확장

`extends` 키워드를 사용하여 인터페이스를 확장합니다.

```typescript
// 기본 인터페이스
interface Person {
  name: string;
  age: number;
}

// Person을 확장한 Student
interface Student extends Person {
  studentId: string;
  grade: number;
}

// Person을 확장한 Teacher
interface Teacher extends Person {
  teacherId: string;
  subject: string;
}

const student: Student = {
  name: "홍길동",
  age: 20,
  studentId: "2024001",
  grade: 3
};

const teacher: Teacher = {
  name: "김선생",
  age: 35,
  teacherId: "T001",
  subject: "수학"
};

console.log(\`학생: \${student.name} (\${student.studentId})\`);
console.log(\`선생님: \${teacher.name} - \${teacher.subject} 담당\`);
```

**시각적 이해:**

```
       Person
      /      \
     /        \
  Student   Teacher
  
Person의 속성 (name, age)을
Student와 Teacher가 모두 가짐
```

### 여러 인터페이스 확장

하나의 인터페이스가 여러 인터페이스를 동시에 확장할 수 있습니다.

```typescript
// 이름 정보
interface Named {
  name: string;
}

// 나이 정보
interface Aged {
  age: number;
}

// 연락처 정보
interface Contactable {
  email: string;
  phone: string;
}

// 여러 인터페이스를 확장
interface Person extends Named, Aged, Contactable {
  address: string;
}

const person: Person = {
  name: "홍길동",
  age: 25,
  email: "hong@example.com",
  phone: "010-1234-5678",
  address: "서울시 강남구"
};

console.log(\`이름: \${person.name}\`);
console.log(\`연락처: \${person.email}, \${person.phone}\`);
```

**시각적 이해:**

```
Named + Aged + Contactable
           ↓
         Person
(모든 속성을 포함)
```

**실전 예제: 전자상거래 시스템**

```typescript
// 기본 엔티티 (모든 것의 기본)
interface Entity {
  readonly id: number;
  createdAt: Date;
}

// 타임스탬프 (생성/수정 시간)
interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

// 제품 기본 정보
interface ProductBase extends Entity {
  name: string;
  price: number;
  description: string;
}

// 재고 정보
interface Stockable {
  quantity: number;
  inStock: boolean;
}

// 할인 가능
interface Discountable {
  discountRate?: number;
  discountedPrice?: number;
}

// 실제 상품 (여러 인터페이스 확장)
interface Product extends ProductBase, Stockable, Discountable, Timestamped {
  category: string;
  imageUrl: string;
}

function createProduct(
  name: string,
  price: number,
  description: string,
  quantity: number,
  category: string
): Product {
  return {
    id: Date.now(),
    name,
    price,
    description,
    quantity,
    inStock: quantity > 0,
    category,
    imageUrl: "/images/default.jpg",
    createdAt: new Date(),
    updatedAt: new Date()
  };
}

function applyDiscount(product: Product, rate: number): void {
  product.discountRate = rate;
  product.discountedPrice = product.price * (1 - rate);
  product.updatedAt = new Date();
}

const laptop = createProduct(
  "노트북",
  1000000,
  "고성능 노트북",
  10,
  "전자제품"
);

applyDiscount(laptop, 0.1);  // 10% 할인

console.log(\`상품: \${laptop.name}\`);
console.log(\`원가: \${laptop.price.toLocaleString()}원\`);
console.log(\`할인가: \${laptop.discountedPrice?.toLocaleString()}원\`);
console.log(\`재고: \${laptop.quantity}개\`);
```

### 인터페이스 확장 시 속성 재정의

인터페이스를 확장할 때 부모 인터페이스의 속성을 더 구체적인 타입으로 재정의할 수 있습니다.

```typescript
interface Animal {
  name: string;
  age: number;
  makeSound(): void;
}

// Dog는 Animal을 확장하면서 makeSound를 더 구체적으로 정의
interface Dog extends Animal {
  breed: string;
  makeSound(): void;  // 재정의 (더 구체적인 구현)
}

const myDog: Dog = {
  name: "멍멍이",
  age: 3,
  breed: "골든 리트리버",
  makeSound() {
    console.log("멍멍!");
  }
};

myDog.makeSound();  // 멍멍!
```

---

## 타입 별칭 (Type Alias)

타입 별칭은 `type` 키워드를 사용하여 타입에 이름을 붙이는 것입니다. 인터페이스와 비슷하지만 더 유연합니다.

### 기본 타입 별칭

```typescript
// 문자열 타입에 별칭 붙이기
type UserName = string;
type UserAge = number;

const name: UserName = "홍길동";
const age: UserAge = 25;

// 객체 타입에 별칭 붙이기
type User = {
  name: string;
  age: number;
  email: string;
};

const user: User = {
  name: "홍길동",
  age: 25,
  email: "hong@example.com"
};
```

타입 별칭은 원시 타입, 유니온 타입, 튜플 등 모든 타입에 이름을 붙일 수 있습니다.

### 유니온 타입에 별칭 붙이기

타입 별칭의 강력한 기능 중 하나는 유니온 타입에 이름을 붙일 수 있다는 것입니다.

```typescript
// 상태 타입
type Status = "pending" | "approved" | "rejected";

// 역할 타입
type Role = "admin" | "user" | "guest";

// ID 타입 (문자열 또는 숫자)
type ID = string | number;

function updateStatus(id: ID, status: Status): void {
  console.log(\`ID \${id}의 상태를 \${status}(으)로 변경합니다.\`);
}

updateStatus(1, "approved");
updateStatus("user-123", "pending");
// updateStatus(1, "invalid");  // ❌ 에러! Status 타입이 아님
```

**실전 예제:**

```typescript
// 결제 방법
type PaymentMethod = "card" | "cash" | "transfer" | "point";

// 배송 상태
type DeliveryStatus = 
  | "preparing"    // 준비 중
  | "shipped"      // 배송 중
  | "delivered"    // 배송 완료
  | "returned";    // 반품

// 주문 정보
type Order = {
  orderId: string;
  productName: string;
  quantity: number;
  paymentMethod: PaymentMethod;
  deliveryStatus: DeliveryStatus;
  totalPrice: number;
};

function createOrder(
  productName: string,
  quantity: number,
  paymentMethod: PaymentMethod
): Order {
  return {
    orderId: \`ORD-\${Date.now()}\`,
    productName,
    quantity,
    paymentMethod,
    deliveryStatus: "preparing",
    totalPrice: 10000 * quantity
  };
}

function updateDeliveryStatus(
  order: Order,
  status: DeliveryStatus
): void {
  order.deliveryStatus = status;
  
  const statusText = {
    preparing: "준비 중",
    shipped: "배송 중",
    delivered: "배송 완료",
    returned: "반품"
  };
  
  console.log(\`주문 \${order.orderId}: \${statusText[status]}\`);
}

const myOrder = createOrder("노트북", 1, "card");
console.log(\`주문 생성: \${myOrder.orderId}\`);

updateDeliveryStatus(myOrder, "shipped");
updateDeliveryStatus(myOrder, "delivered");
```

### 튜플 타입에 별칭 붙이기

```typescript
// 좌표 타입
type Point2D = [number, number];
type Point3D = [number, number, number];

// RGB 색상
type RGB = [number, number, number];

// 사용자 정보 (이름, 나이, 이메일)
type UserInfo = [string, number, string];

const point: Point2D = [10, 20];
const color: RGB = [255, 128, 0];
const user: UserInfo = ["홍길동", 25, "hong@example.com"];

console.log(\`좌표: (\${point[0]}, \${point[1]})\`);
console.log(\`색상: RGB(\${color[0]}, \${color[1]}, \${color[2]})\`);
console.log(\`사용자: \${user[0]}, \${user[1]}세, \${user[2]}\`);
```

### 함수 타입에 별칭 붙이기

함수 타입에도 별칭을 붙일 수 있습니다.

```typescript
// 계산 함수 타입
type MathOperation = (a: number, b: number) => number;

// 문자열 변환 함수 타입
type StringTransformer = (str: string) => string;

// 숫자 검증 함수 타입
type NumberValidator = (n: number) => boolean;

// 사용 예시
const add: MathOperation = (a, b) => a + b;
const multiply: MathOperation = (a, b) => a * b;

const toUpperCase: StringTransformer = (str) => str.toUpperCase();
const toLowerCase: StringTransformer = (str) => str.toLowerCase();

const isEven: NumberValidator = (n) => n % 2 === 0;
const isPositive: NumberValidator = (n) => n > 0;

console.log(add(10, 5));              // 15
console.log(toUpperCase("hello"));    // HELLO
console.log(isEven(4));               // true
```

**실전 예제: 이벤트 핸들러**

```typescript
// 이벤트 핸들러 타입들
type ClickHandler = (x: number, y: number) => void;
type KeyHandler = (key: string) => void;
type ChangeHandler = (value: string) => void;

// 버튼 컴포넌트
type Button = {
  id: string;
  text: string;
  onClick: ClickHandler;
};

// 입력 필드 컴포넌트
type Input = {
  id: string;
  placeholder: string;
  onChange: ChangeHandler;
};

const loginButton: Button = {
  id: "login-btn",
  text: "로그인",
  onClick: (x, y) => {
    console.log(\`버튼 클릭: 좌표 (\${x}, \${y})\`);
    console.log("로그인 처리 중...");
  }
};

const emailInput: Input = {
  id: "email-input",
  placeholder: "이메일을 입력하세요",
  onChange: (value) => {
    console.log(\`입력값 변경: \${value}\`);
  }
};

// 이벤트 시뮬레이션
loginButton.onClick(100, 200);
emailInput.onChange("hong@example.com");
```

---

## 인터페이스 vs 타입 별칭

인터페이스와 타입 별칭은 비슷해 보이지만 몇 가지 중요한 차이점이 있습니다. 언제 어떤 것을 사용해야 할까요?

### 공통점

둘 다 객체의 구조를 정의할 수 있습니다.

```typescript
// 인터페이스로 정의
interface UserInterface {
  name: string;
  age: number;
}

// 타입 별칭으로 정의
type UserType = {
  name: string;
  age: number;
};

// 둘 다 똑같이 사용 가능
const user1: UserInterface = { name: "홍길동", age: 25 };
const user2: UserType = { name: "김철수", age: 30 };
```

### 차이점 1: 확장 방법

**인터페이스는 `extends`로 확장:**

```typescript
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

const myDog: Dog = {
  name: "멍멍이",
  breed: "골든 리트리버"
};
```

**타입 별칭은 `&`(교차 타입)로 확장:**

```typescript
type Animal = {
  name: string;
};

type Dog = Animal & {
  breed: string;
};

const myDog: Dog = {
  name: "멍멍이",
  breed: "골든 리트리버"
};
```

### 차이점 2: 선언 병합

인터페이스는 같은 이름으로 여러 번 선언하면 자동으로 병합됩니다. 타입 별칭은 불가능합니다.

```typescript
// 인터페이스: 선언 병합 가능
interface User {
  name: string;
}

interface User {
  age: number;
}

// 두 선언이 자동으로 병합됨
const user: User = {
  name: "홍길동",
  age: 25  // 둘 다 필요
};

// 타입 별칭: 선언 병합 불가능
type Product = {
  name: string;
};

// type Product = {  // ❌ 에러! 중복 선언 불가
//   price: number;
// };
```

**선언 병합이 유용한 경우:**

```typescript
// 기본 Window 인터페이스 확장
interface Window {
  myCustomProperty: string;
}

// 이제 window.myCustomProperty 사용 가능
window.myCustomProperty = "Hello";
```

### 차이점 3: 타입의 종류

타입 별칭은 인터페이스보다 더 많은 종류의 타입에 이름을 붙일 수 있습니다.

```typescript
// ✅ 타입 별칭만 가능
type ID = string | number;
type Point = [number, number];
type Callback = () => void;
type StringOrNumber = string | number;

// ❌ 인터페이스로는 불가능
// interface ID = string | number;  // 에러!
```

### 시각적 비교

```
┌─────────────────────────────────────────────────┐
│               Interface vs Type                 │
├─────────────────────────────────────────────────┤
│                                                 │
│  Interface              Type Alias              │
│  ┌──────────┐          ┌──────────┐            │
│  │  객체    │          │  객체    │            │
│  │  구조    │          │  유니온  │            │
│  │  정의    │          │  튜플    │            │
│  │         │          │  함수    │            │
│  │  확장    │          │  원시    │            │
│  │  (extends)│         │         │            │
│  │         │          │  교차    │            │
│  │  병합    │          │  (&)     │            │
│  │  가능    │          │         │            │
│  └──────────┘          └──────────┘            │
│                                                 │
│  ✅ 객체 지향적        ✅ 더 유연함             │
│  ✅ 확장 용이         ✅ 모든 타입 가능          │
│  ✅ 선언 병합         ✅ 유니온/튜플 지원        │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 언제 무엇을 사용할까?

**인터페이스를 사용하세요:**

1. 객체의 구조를 정의할 때
2. 클래스와 함께 사용할 때
3. 라이브러리나 API를 만들 때 (확장 가능성)
4. 선언 병합이 필요할 때

```typescript
// ✅ 인터페이스가 적합한 경우
interface User {
  name: string;
  age: number;
  email: string;
}

interface Admin extends User {
  permissions: string[];
}
```

**타입 별칭을 사용하세요:**

1. 유니온 타입을 정의할 때
2. 튜플 타입을 정의할 때
3. 함수 타입을 정의할 때
4. 원시 타입에 의미있는 이름을 붙일 때

```typescript
// ✅ 타입 별칭이 적합한 경우
type Status = "pending" | "approved" | "rejected";
type Point = [number, number];
type Callback = (data: string) => void;
type ID = string | number;
```

**실전 가이드:**

```typescript
// 객체 구조 → Interface
interface Product {
  id: number;
  name: string;
  price: number;
}

// 상태 관리 → Type Alias
type LoadingState = "idle" | "loading" | "success" | "error";

// 함수 타입 → Type Alias
type EventHandler = (event: string) => void;

// 객체 확장 → Interface
interface ExtendedProduct extends Product {
  category: string;
  inStock: boolean;
}

// 복잡한 유니온 → Type Alias
type ApiResponse = 
  | { success: true; data: Product[] }
  | { success: false; error: string };
```

---

## 인터페이스 병합 (Declaration Merging)

TypeScript의 독특한 기능 중 하나는 같은 이름의 인터페이스를 여러 번 선언하면 자동으로 병합된다는 것입니다.

### 기본 병합

```typescript
interface Box {
  width: number;
  height: number;
}

interface Box {
  depth: number;
}

// 두 선언이 자동으로 병합됨
// Box = { width, height, depth }

const box: Box = {
  width: 100,
  height: 50,
  depth: 30
};

console.log(\`크기: \${box.width} × \${box.height} × \${box.depth}\`);
```

### 병합의 실용적 사용

인터페이스 병합은 주로 기존 타입을 확장할 때 유용합니다.

```typescript
// 기본 User 인터페이스
interface User {
  name: string;
  email: string;
}

// 나중에 필요한 속성 추가
interface User {
  phone?: string;
}

// 또 다른 속성 추가
interface User {
  address?: string;
}

// 모든 속성이 병합됨
const user: User = {
  name: "홍길동",
  email: "hong@example.com",
  phone: "010-1234-5678",
  address: "서울시 강남구"
};
```

**주의사항:**

병합할 때 같은 속성을 다른 타입으로 정의하면 에러가 발생합니다.

```typescript
interface Product {
  name: string;
  price: number;
}

// interface Product {
//   price: string;  // ❌ 에러! price는 이미 number로 정의됨
// }
```

### 메서드 오버로딩

인터페이스 병합을 통해 메서드 오버로딩을 구현할 수 있습니다.

```typescript
interface Calculator {
  calculate(a: number, b: number): number;
}

interface Calculator {
  calculate(a: string): number;
}

const calc: Calculator = {
  calculate(a: number | string, b?: number): number {
    if (typeof a === "string") {
      return parseInt(a);
    }
    return a + (b || 0);
  }
};

console.log(calc.calculate(10, 20));  // 30
console.log(calc.calculate("100"));   // 100
```

---

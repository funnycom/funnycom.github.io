---
title: "[TS] 투두 앱 - 2가지 버전"
date: 2025-10-23 15:55:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, todo, 할일관리]
pin: true
math: true
mermaid: true
---

D:\typescript-프로젝트-추천 폴더에 시작화면 있음

# React를 사용하지 않은 경우 (Vanilla TypeScript + HTML)

이 방식은 웹의 가장 기본적인 동작 원리를 이해하는 데 도움이 됩니다. TypeScript 코드가 직접 HTML 요소를 찾아내고, 사용자의 입력에 따라 화면을 변경(DOM 조작)하는 '명령형' 프로그래밍 방식입니다.

## 핵심 아이디어:

**상태 관리:** todos라는 배열에 할 일 목록 데이터를 저장합니다.

**DOM 조작:** 사용자가 할 일을 추가하거나 삭제하면, todos 배열을 변경하고 이 배열의 내용에 맞게 HTML 목록을 처음부터 다시 그립니다.

## 1-1. index.html (HTML 구조)

먼저, 앱의 뼈대가 될 HTML 파일을 작성합니다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanilla TS Todo List</title>
    <style>
        /* 간단한 스타일링 */
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #f4f4f4; padding: 20px; color: #333; }
        .container { max-width: 500px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        form { display: flex; gap: 10px; margin-bottom: 20px; }
        input[type="text"] { flex-grow: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
        button { padding: 10px 15px; border: none; background-color: #007bff; color: white; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        ul { list-style-type: none; padding: 0; }
        li { display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #eee; cursor: pointer; }
        li.completed { text-decoration: line-through; color: #888; }
        .delete-btn { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
        .delete-btn:hover { background-color: #c82333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>할 일 목록</h1>
        <form id="todo-form">
            <input type="text" id="todo-input" placeholder="새로운 할 일을 입력하세요" required>
            <button type="submit">추가</button>
        </form>
        <ul id="todo-list"></ul>
    </div>
    <!-- TypeScript를 컴파일한 JavaScript 파일을 불러옵니다 -->
    <script src="main.js"></script>
</body>
</html>
```

## 1-2. main.ts (TypeScript 로직)

이제 HTML을 제어하는 로직을 작성합니다.

```typescript
// 할 일 항목의 타입을 정의합니다.
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

// 할 일 목록을 저장할 배열 (애플리케이션의 '상태')
let todos: Todo[] = [];

// HTML 요소들을 가져옵니다. 타입 단언(as)을 사용해 TypeScript에게 요소의 타입을 알려줍니다.
const todoForm = document.getElementById('todo-form') as HTMLFormElement;
const todoInput = document.getElementById('todo-input') as HTMLInputElement;
const todoList = document.getElementById('todo-list') as HTMLUListElement;

// 할 일 목록을 화면에 렌더링하는 함수
function renderTodos() {
  // 기존 목록을 비웁니다.
  todoList.innerHTML = '';
  
  // todos 배열의 각 항목에 대해 <li> 요소를 생성합니다.
  todos.forEach(todo => {
    const li = document.createElement('li');
    li.textContent = todo.text;
    if (todo.completed) {
      li.classList.add('completed');
    }

    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = '삭제';
    deleteBtn.classList.add('delete-btn');
    
    // 할 일 텍스트 클릭 시 완료/미완료 토글
    li.addEventListener('click', () => {
      toggleTodo(todo.id);
    });

    // 삭제 버튼 클릭 시 항목 삭제
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // 부모 요소(li)의 클릭 이벤트가 실행되지 않도록 함
      deleteTodo(todo.id);
    });

    li.appendChild(deleteBtn);
    todoList.appendChild(li);
  });
}

// 새로운 할 일을 추가하는 함수
function addTodo(text: string) {
  const newTodo: Todo = {
    id: Date.now(), // 간단하게 현재 시간을 ID로 사용
    text: text,
    completed: false,
  };
  todos.push(newTodo);
  renderTodos(); // 목록을 다시 렌더링
}

// 할 일의 완료 상태를 변경하는 함수
function toggleTodo(id: number) {
  todos = todos.map(todo =>
    todo.id === id ? { ...todo, completed: !todo.completed } : todo
  );
  renderTodos();
}

// 할 일을 삭제하는 함수
function deleteTodo(id: number) {
  todos = todos.filter(todo => todo.id !== id);
  renderTodos();
}

// 폼 제출 이벤트 리스너
todoForm.addEventListener('submit', (e) => {
  e.preventDefault(); // 폼의 기본 동작(페이지 새로고침)을 막습니다.
  const newTodoText = todoInput.value.trim();
  if (newTodoText) {
    addTodo(newTodoText);
    todoInput.value = ''; // 입력창 비우기
    todoInput.focus();
  }
});

// 초기 렌더링
renderTodos();
```

**실행 방법:** 이 .ts 파일을 브라우저에서 실행하려면 TypeScript 컴파일러(tsc)를 사용하여 JavaScript 파일로 변환해야 합니다. (tsc main.ts 명령어 실행)


# 2. React와 TypeScript를 사용한 경우

React는 '선언형' UI 라이브러리입니다. DOM을 직접 조작하는 대신, '상태(state)'가 변경되면 화면이 어떻게 보여야 하는지만 정의하면 React가 알아서 효율적으로 화면을 업데이트해 줍니다.

## 핵심 아이디어:

**상태 관리:** useState 훅(Hook)을 사용하여 todos 배열 상태를 관리합니다.

**선언형 UI:** JSX 문법을 사용하여 todos 배열을 화면 요소(<li>)로 변환(mapping)하는 방법을 선언합니다.

**단방향 데이터 흐름:** 사용자의 액션(클릭 등)이 발생하면 상태를 변경하는 함수(setTodos)를 호출하고, 상태가 변경되면 React가 UI를 다시 렌더링합니다.

## TodoApp.tsx (React 컴포넌트)

React 프로젝트 환경에서 아래와 같은 컴포넌트 파일을 작성합니다.

```tsx
import React, { useState, FormEvent, ChangeEvent } from 'react';

// 할 일 항목의 타입을 정의합니다.
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  // useState 훅으로 상태 관리
  const [todos, setTodos] = useState<Todo[]>([]);
  const [inputText, setInputText] = useState<string>('');

  const handleInputChange = (e: ChangeEvent<HTMLInputElement>) => {
    setInputText(e.target.value);
  };

  const handleFormSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (inputText.trim() === '') return;

    const newTodo: Todo = {
      id: Date.now(),
      text: inputText,
      completed: false,
    };
    
    // 상태 업데이트 함수를 사용하여 새로운 todo 추가 (불변성 유지)
    setTodos(prevTodos => [...prevTodos, newTodo]);
    setInputText('');
  };

  const toggleTodo = (id: number) => {
    setTodos(
      todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };
  
  const deleteTodo = (id: number) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div style={{ maxWidth: '500px', margin: 'auto', background: 'white', padding: '20px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)', fontFamily: 'sans-serif' }}>
      <h1>할 일 목록 (React)</h1>
      <form onSubmit={handleFormSubmit} style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
        <input
          type="text"
          value={inputText}
          onChange={handleInputChange}
          placeholder="새로운 할 일을 입력하세요"
          style={{ flexGrow: 1, padding: '10px', border: '1px solid #ddd', borderRadius: '4px', fontSize: '16px' }}
        />
        <button type="submit" style={{ padding: '10px 15px', border: 'none', backgroundColor: '#007bff', color: 'white', borderRadius: '4px', cursor: 'pointer' }}>추가</button>
      </form>
      <ul style={{ listStyleType: 'none', padding: 0 }}>
        {todos.map(todo => (
          <li
            key={todo.id}
            onClick={() => toggleTodo(todo.id)}
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              padding: '12px 0',
              borderBottom: '1px solid #eee',
              cursor: 'pointer',
              textDecoration: todo.completed ? 'line-through' : 'none',
              color: todo.completed ? '#888' : '#333'
            }}
          >
            {todo.text}
            <button
              onClick={(e) => {
                e.stopPropagation(); // li의 클릭 이벤트가 실행되지 않도록 함
                deleteTodo(todo.id);
              }}
              style={{ backgroundColor: '#dc3545', color: 'white', border: 'none', padding: '5px 10px', borderRadius: '4px', cursor: 'pointer' }}
            >
              삭제
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default TodoApp;
```

## 두 방식의 핵심 차이점

**DOM 제어권:** Vanilla 방식에서는 개발자가 직접 DOM을 조작해야 하지만, React에서는 React가 가상 DOM(Virtual DOM)을 통해 이 작업을 대신 해 줍니다. 개발자는 '상태'만 신경 쓰면 됩니다.

**코드 구조:** Vanilla 방식은 기능(추가, 삭제, 렌더링)별로 함수가 나뉘는 경향이 있고, React는 관련된 상태와 UI 로직이 하나의 '컴포넌트' 안에 모여있어 재사용과 관리가 더 쉽습니다.

**생산성:** 작은 앱에서는 Vanilla 방식도 충분하지만, 애플리케이션이 복잡해질수록 상태 관리가 어려워집니다. React는 복잡한 UI를 체계적으로 관리할 수 있게 도와주어 생산성을 크게 높여줍니다.

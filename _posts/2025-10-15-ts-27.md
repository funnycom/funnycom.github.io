---
title: "[Projects] 도서관 관리 시스템 - 2"
date: 2025-10-15 15:00:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS]
pin: true
math: true
mermaid: true
published: false
---

# Project 2: 도서관 관리 시스템

> **프로젝트 목표**
> - 클래스 상속과 추상 클래스를 실전에 적용한다
> - 복잡한 비즈니스 로직을 설계하고 구현한다
> - 여러 엔티티 간의 관계를 관리한다
> - 날짜 계산 및 연체 처리를 구현한다
> - AI와 협업하되 더 자율적으로 프로젝트를 진행한다

---

## Part 2: AI와 함께 구현하기 (3-4시간)

이제 설계를 바탕으로 구현해봅시다. 
첫 번째 프로젝트에서 배운 AI 활용법을 적용하되, 이번에는 **더 자율적**으로 진행하세요.

### 🚀 구현 전 체크리스트

**[ ] 시작하기 전에**
```
□ Part 1의 설계를 완료했나요?
□ 각 클래스의 역할이 명확한가요?
□ 상속 구조를 결정했나요?
□ 구현 순서를 정했나요?
□ 첫 번째 프로젝트의 코드를 참고할 수 있나요?
```

---

### 📝 Step 1: 기본 타입 및 인터페이스 정의

#### 설계 확인

Part 1에서 정리한 설계를 다시 확인하세요:
- Book은 어떤 속성을 가지나요?
- Member는 어떤 타입인가요?
- Loan은 어떤 정보를 담나요?

#### AI에게 요청하기

**프롬프트 템플릿:**
```
"TypeScript로 도서관 관리 시스템의 타입을 정의해줘.

1. Book 인터페이스:
   - isbn: 문자열 (고유 식별자)
   - title: 문자열
   - author: 문자열
   - publishedYear: 숫자
   - isAvailable: 불린 (대출 가능 여부)
   
2. MemberType:
   - "regular" | "vip"
   
3. Loan 인터페이스:
   - id: 문자열
   - bookIsbn: 문자열
   - memberId: 문자열
   - borrowDate: Date
   - dueDate: Date
   - returnDate: Date | null

조건:
- 모든 인터페이스에 JSDoc 주석
- readonly 속성은 isbn, id만
- Date 타입 사용

각 타입을 별도 파일로 작성할 수 있게 export 포함해줘."
```

**💡 자율 학습 포인트:**
```
AI가 생성한 코드를 받으면:

1. 스스로 분석하기:
   □ 내가 설계한 것과 비교
   □ 차이점이 있다면 왜 다를까?
   □ 더 나은 방법은 없을까?

2. 개선하기:
   □ 내 설계가 더 좋다면 수정 요청
   □ AI 설계가 더 좋다면 왜 그런지 질문
   
3. 확장하기:
   □ 추가 속성이 필요한가?
   □ 유틸리티 타입이 필요한가?
```

---

### 📝 Step 2: Book 클래스 구현

#### 스스로 먼저 구조 작성하기

AI에게 요청하기 전에, 먼저 스스로 기본 구조를 작성해보세요:
```typescript
// 1분 동안 스스로 작성해보기
class Book {
  // 여기에 속성과 메서드를 적어보세요
}
```

#### AI에게 요청하기

**프롬프트 예시:**
```
"Book 클래스를 구현해줘.

속성:
- private 또는 public 적절히 사용
- Book 인터페이스의 모든 속성 포함

생성자:
- isbn, title, author, publishedYear를 매개변수로
- isAvailable는 true로 초기화

메서드:
1. getInfo(): string
   - 책 정보를 문자열로 반환
   - 예: "[ISBN] 제목 - 저자 (출판년도)"

2. checkout(): boolean
   - 대출 처리
   - 이미 대출 중이면 false
   - 성공하면 isAvailable를 false로 변경하고 true 반환

3. returnBook(): boolean
   - 반납 처리
   - 대출 중이 아니면 false
   - 성공하면 isAvailable를 true로 변경하고 true 반환

조건:
- JSDoc 주석 추가
- 에러 케이스 고려
- 타입 안전성 확보

생성자 매개변수에 접근 제어자 사용해줘."
```

#### 받은 코드 분석 및 테스트

**[ ] 코드 리뷰 체크리스트:**
```
□ 내가 작성한 구조와 비교했나?
□ 모든 메서드가 의도대로 동작하나?
□ 에러 처리가 적절한가?
□ 더 개선할 점은 없나?
```

**테스트 코드 작성 (스스로 해보기):**
```typescript
// AI에게 요청하지 말고 직접 작성해보세요
const book = new Book(
  "978-1234567890",
  "TypeScript 프로그래밍",
  "홍길동",
  2024
);

// 테스트 시나리오:
// 1. 책 정보 출력
// 2. 대출 시도 (성공해야 함)
// 3. 다시 대출 시도 (실패해야 함)
// 4. 반납
// 5. 다시 대출 (성공해야 함)

// 막히면 AI에게:
// "Book 클래스를 테스트하는 코드만 작성해줘"
```

---

### 📝 Step 3: Member 클래스 구현

여기서는 두 가지 방법 중 선택하세요:

#### 방법 A: 단일 Member 클래스

**프롬프트 예시:**
---

## Part 2: AI와 함께 구현하기 (3-4시간)

이제 설계를 바탕으로 구현해봅시다. 
첫 번째 프로젝트에서 배운 AI 활용법을 적용하되, 이번에는 **더 자율적**으로 진행하세요.

### 🚀 구현 전 체크리스트

**[ ] 시작하기 전에**
```
□ Part 1의 설계를 완료했나요?
□ 각 클래스의 역할이 명확한가요?
□ 상속 구조를 결정했나요?
□ 구현 순서를 정했나요?
□ 첫 번째 프로젝트의 코드를 참고할 수 있나요?
```

---

### 📝 Step 1: 기본 타입 및 인터페이스 정의

#### 설계 확인

Part 1에서 정리한 설계를 다시 확인하세요:
- Book은 어떤 속성을 가지나요?
- Member는 어떤 타입인가요?
- Loan은 어떤 정보를 담나요?

#### AI에게 요청하기

**프롬프트 템플릿:**
```
"TypeScript로 도서관 관리 시스템의 타입을 정의해줘.

1. Book 인터페이스:
   - isbn: 문자열 (고유 식별자)
   - title: 문자열
   - author: 문자열
   - publishedYear: 숫자
   - isAvailable: 불린 (대출 가능 여부)
   
2. MemberType:
   - "regular" | "vip"
   
3. Loan 인터페이스:
   - id: 문자열
   - bookIsbn: 문자열
   - memberId: 문자열
   - borrowDate: Date
   - dueDate: Date
   - returnDate: Date | null

조건:
- 모든 인터페이스에 JSDoc 주석
- readonly 속성은 isbn, id만
- Date 타입 사용

각 타입을 별도 파일로 작성할 수 있게 export 포함해줘."
```

**💡 자율 학습 포인트:**
```
AI가 생성한 코드를 받으면:

1. 스스로 분석하기:
   □ 내가 설계한 것과 비교
   □ 차이점이 있다면 왜 다를까?
   □ 더 나은 방법은 없을까?

2. 개선하기:
   □ 내 설계가 더 좋다면 수정 요청
   □ AI 설계가 더 좋다면 왜 그런지 질문
   
3. 확장하기:
   □ 추가 속성이 필요한가?
   □ 유틸리티 타입이 필요한가?
```

---

### 📝 Step 2: Book 클래스 구현

#### 스스로 먼저 구조 작성하기

AI에게 요청하기 전에, 먼저 스스로 기본 구조를 작성해보세요:
```typescript
// 1분 동안 스스로 작성해보기
class Book {
  // 여기에 속성과 메서드를 적어보세요
}
```

#### AI에게 요청하기

**프롬프트 예시:**
```
"Book 클래스를 구현해줘.

속성:
- private 또는 public 적절히 사용
- Book 인터페이스의 모든 속성 포함

생성자:
- isbn, title, author, publishedYear를 매개변수로
- isAvailable는 true로 초기화

메서드:
1. getInfo(): string
   - 책 정보를 문자열로 반환
   - 예: "[ISBN] 제목 - 저자 (출판년도)"

2. checkout(): boolean
   - 대출 처리
   - 이미 대출 중이면 false
   - 성공하면 isAvailable를 false로 변경하고 true 반환

3. returnBook(): boolean
   - 반납 처리
   - 대출 중이 아니면 false
   - 성공하면 isAvailable를 true로 변경하고 true 반환

조건:
- JSDoc 주석 추가
- 에러 케이스 고려
- 타입 안전성 확보

생성자 매개변수에 접근 제어자 사용해줘."
```

#### 받은 코드 분석 및 테스트

**[ ] 코드 리뷰 체크리스트:**
```
□ 내가 작성한 구조와 비교했나?
□ 모든 메서드가 의도대로 동작하나?
□ 에러 처리가 적절한가?
□ 더 개선할 점은 없나?
```

**테스트 코드 작성 (스스로 해보기):**
```typescript
// AI에게 요청하지 말고 직접 작성해보세요
const book = new Book(
  "978-1234567890",
  "TypeScript 프로그래밍",
  "홍길동",
  2024
);

// 테스트 시나리오:
// 1. 책 정보 출력
// 2. 대출 시도 (성공해야 함)
// 3. 다시 대출 시도 (실패해야 함)
// 4. 반납
// 5. 다시 대출 (성공해야 함)

// 막히면 AI에게:
// "Book 클래스를 테스트하는 코드만 작성해줘"
```

---

### 📝 Step 3: Member 클래스 구현

여기서는 두 가지 방법 중 선택하세요:

#### 방법 A: 단일 Member 클래스

**프롬프트 예시:**
```
"Member 클래스를 구현해줘.

속성:
- id: 문자열 (readonly)
- name: 문자열
- memberType: "regular" | "vip"
- borrowedBooks: 문자열 배열 (ISBN 목록)
- registeredDate: Date

생성자:
- id, name, memberType을 매개변수로
- borrowedBooks는 빈 배열로 초기화
- registeredDate는 현재 날짜로

메서드:
1. getMaxBorrowLimit(): number
   - regular면 3, vip면 5 반환

2. canBorrow(): boolean
   - 현재 대출 중인 책 수가 한도 미만이면 true

3. addBorrowedBook(isbn: string): void
   - borrowedBooks에 isbn 추가
   - 이미 있으면 추가하지 않음

4. removeBorrowedBook(isbn: string): boolean
   - borrowedBooks에서 isbn 제거
   - 성공하면 true, 없으면 false

5. getBorrowedCount(): number
   - 현재 대출 중인 책 개수 반환

조건:
- JSDoc 주석
- 에러 처리
- 타입 안전성

생성자 매개변수에 접근 제어자 사용해줘."
```

#### 방법 B: 추상 클래스 + 상속 구조

**프롬프트 예시 1: 추상 Member 클래스**
```
"추상 Member 클래스를 구현해줘.

속성 (protected):
- id: 문자열 (readonly)
- name: 문자열
- borrowedBooks: 문자열 배열
- registeredDate: Date

생성자:
- id, name을 매개변수로
- borrowedBooks는 빈 배열
- registeredDate는 현재 날짜

일반 메서드:
1. addBorrowedBook(isbn: string): void
2. removeBorrowedBook(isbn: string): boolean
3. getBorrowedCount(): number
4. getName(): string
5. getId(): string

추상 메서드:
1. abstract getMaxBorrowLimit(): number
2. abstract getMemberType(): string

메서드:
canBorrow(): boolean {
  return this.getBorrowedCount() < this.getMaxBorrowLimit();
}

조건:
- abstract 키워드 사용
- JSDoc 주석
- protected 속성 사용

생성자 매개변수에 접근 제어자 사용해줘."
```

**프롬프트 예시 2: RegularMember 클래스**
```
"RegularMember 클래스를 구현해줘.

요구사항:
- Member 추상 클래스를 상속
- 생성자는 id, name만 받음
- super()로 부모 생성자 호출

추상 메서드 구현:
1. getMaxBorrowLimit(): number
   - 3 반환

2. getMemberType(): string
   - "일반 회원" 반환

조건:
- extends 키워드 사용
- super() 호출
- JSDoc 주석

예시:
const member = new RegularMember("M001", "홍길동");
console.log(member.getMaxBorrowLimit()); // 3
console.log(member.getMemberType()); // "일반 회원"
"
```

**프롬프트 예시 3: VIPMember 클래스**
```
"VIPMember 클래스를 구현해줘.

요구사항:
- Member 추상 클래스를 상속
- 생성자는 id, name만 받음

추상 메서드 구현:
1. getMaxBorrowLimit(): number
   - 5 반환

2. getMemberType(): string
   - "우수 회원" 반환

추가 기능:
- 우수 회원만의 특별한 메서드나 속성이 있다면 추가

조건:
- RegularMember와 유사한 구조
- JSDoc 주석

예시:
const vip = new VIPMember("M002", "김철수");
console.log(vip.getMaxBorrowLimit()); // 5
"
```

#### 코드 분석

**[ ] 상속 이해하기**
```
받은 코드를 보면서 질문:

□ abstract 키워드는 왜 사용하나?
□ protected와 private의 차이는?
□ super()는 언제 호출해야 하나?
□ 추상 메서드는 왜 구현이 없나?
□ 자식 클래스에서 부모 메서드를 어떻게 사용하나?

이해가 안 되면 AI에게:
"추상 클래스와 상속의 장점을 예시로 설명해줘"
"protected 속성을 자식 클래스에서 접근하는 예시를 보여줘"
```

#### 테스트 (스스로 해보기)
```typescript
// 직접 작성해보세요
// 방법 A를 선택했다면:
const regularMember = new Member("M001", "홍길동", "regular");
// 방법 B를 선택했다면:
const regularMember = new RegularMember("M001", "홍길동");
const vipMember = new VIPMember("M002", "김철수");

// 테스트 시나리오 직접 작성:
// 1. 대출 한도 확인
// 2. 책 대출 추가
// 3. 대출 가능 여부 확인
// 4. 한도까지 채운 후 확인
```

---

### 📝 Step 4: Loan 클래스 구현

#### 날짜 처리 이해하기

Loan 클래스는 날짜 계산이 핵심입니다. 먼저 JavaScript의 Date를 이해해봅시다.

**[ ] Date 기초 학습**
```
AI에게 먼저 물어보기:
"JavaScript Date 객체로 다음을 하는 방법을 알려줘:
1. 현재 날짜 생성
2. 14일 후 날짜 계산
3. 두 날짜 사이의 일수 계산
4. 날짜 비교 (A가 B보다 나중인지)

간단한 예제 코드로 보여줘."
```

#### 스스로 생각해보기
```
Loan 클래스에서 필요한 기능:
1. 대출 시: dueDate = borrowDate + 14일
2. 연체 확인: 현재 날짜 > dueDate && returnDate === null
3. 연체 일수: 현재 날짜 - dueDate
4. 반납 시: returnDate = 현재 날짜

이것을 어떻게 구현할까요?
스스로 생각한 방법:
_________________________________________
_________________________________________
```

#### AI에게 요청하기

**프롬프트 예시:**
```
"Loan 클래스를 구현해줘.

속성:
- id: 문자열 (readonly)
- bookIsbn: 문자열 (readonly)
- memberId: 문자열 (readonly)
- borrowDate: Date (readonly)
- dueDate: Date (readonly)
- returnDate: Date | null

생성자:
- id, bookIsbn, memberId를 매개변수로
- borrowDate는 현재 날짜
- dueDate는 borrowDate + 14일
- returnDate는 null

메서드:
1. isOverdue(): boolean
   - 반납하지 않았고 (returnDate === null)
   - 현재 날짜가 dueDate를 넘었으면 true

2. getOverdueDays(): number
   - 연체 일수 계산
   - 연체 중이 아니면 0 반환
   - 연체 중이면 (현재 날짜 - dueDate)의 일수

3. returnBook(): void
   - returnDate를 현재 날짜로 설정

4. isReturned(): boolean
   - returnDate가 null이 아니면 true

5. getLoanInfo(): string
   - 대출 정보를 문자열로 반환
   - 예: "회원 M001이 978-123을 2024-01-10에 대출 (반납 예정: 2024-01-24)"

조건:
- Date 객체 사용
- 날짜 계산 정확히
- JSDoc 주석
- 타입 안전성

날짜 계산 헬퍼 함수가 필요하면 private 메서드로 추가해줘."
```

#### 날짜 계산 확인

**[ ] 받은 코드 검증하기**
```
다음을 직접 테스트:

1. 대출 생성
const loan = new Loan("L001", "978-123", "M001");
console.log(loan.dueDate); // 14일 후인가?

2. 연체 확인 (시뮬레이션)
// AI에게: "날짜를 강제로 설정하여 테스트하는 방법"

3. 날짜 계산
const days = loan.getOverdueDays();
// 계산이 정확한가?
```

---

### 📝 Step 5: LibraryManager 클래스 구현

이제 모든 것을 통합하는 중앙 관리 클래스를 만들어봅시다.

#### 기본 구조

**프롬프트 예시:**
```
"LibraryManager 클래스를 구현해줘.

속성:
- private books: Map<string, Book>
  (key: isbn, value: Book)
- private members: Map<string, Member>
  (key: memberId, value: Member)
- private loans: Map<string, Loan>
  (key: loanId, value: Loan)
- private nextLoanId: number

생성자:
- 모든 Map을 빈 상태로 초기화
- nextLoanId는 1로

책 관리 메서드:
1. addBook(book: Book): void
   - books에 추가
   - 이미 있으면 에러

2. removeBook(isbn: string): boolean
   - 대출 중이면 삭제 불가
   - 성공하면 true

3. findBook(isbn: string): Book | undefined
   - isbn으로 책 찾기

4. getAllBooks(): Book[]
   - 모든 책 배열로 반환

회원 관리 메서드:
1. registerMember(member: Member): void
   - members에 추가
   - 이미 있으면 에러

2. findMember(id: string): Member | undefined
   - id로 회원 찾기

3. getAllMembers(): Member[]
   - 모든 회원 배열로 반환

조건:
- Map 사용
- 에러 처리
- JSDoc 주석
- 타입 안전성

아직 대출 관련 메서드는 구현하지 말고 주석으로만 표시해줘."
```

#### 대출/반납 시스템

**프롬프트 예시: borrowBook 메서드**
```
"LibraryManager에 borrowBook 메서드를 추가해줘.

시그니처:
borrowBook(memberId: string, isbn: string): Loan | null

로직:
1. 회원 확인
   - 회원이 없으면 에러 메시지 출력, null 반환
   
2. 책 확인
   - 책이 없으면 에러 메시지 출력, null 반환
   
3. 대출 가능 여부 검증
   - 책이 대출 가능한가? (book.isAvailable)
   - 회원이 더 빌릴 수 있나? (member.canBorrow())
   - 하나라도 실패하면 에러 메시지, null 반환
   
4. 대출 처리
   - Loan 객체 생성 (id: "L" + nextLoanId++)
   - book.checkout() 호출
   - member.addBorrowedBook(isbn) 호출
   - loans에 추가
   - 성공 메시지 출력
   - Loan 반환

조건:
- 각 단계마다 명확한 에러 메시지
- 트랜잭션처럼 처리 (실패 시 원상복구)
- JSDoc 주석

예시:
const loan = manager.borrowBook("M001", "978-123");
if (loan) {
  console.log("대출 성공!");
}
"
```

**프롬프트 예시: returnBook 메서드**
```
"LibraryManager에 returnBook 메서드를 추가해줘.

시그니처:
returnBook(loanId: string): boolean

로직:
1. 대출 기록 확인
   - loanId로 Loan 찾기
   - 없으면 에러 메시지, false 반환
   
2. 이미 반납 확인
   - loan.isReturned()가 true면 에러 메시지, false 반환
   
3. 반납 처리
   - loan.returnBook() 호출
   - book.returnBook() 호출 (isbn으로 책 찾아서)
   - member.removeBorrowedBook(isbn) 호출 (memberId로 회원 찾아서)
   
4. 연체 확인 및 처리
   - loan.isOverdue()가 true면 연체 메시지 출력
   - 연체 일수와 연체료 계산 (1일당 100원)
   
5. 성공 메시지 출력, true 반환

조건:
- 에러 처리
- 연체료 계산 및 출력
- JSDoc 주석

예시:
const success = manager.returnBook("L001");
if (success) {
  console.log("반납 완료!");
}
"
```

#### 검색 및 조회 기능

**프롬프트 예시:**
```
"LibraryManager에 다음 메서드들을 추가해줘:

1. searchBooks(query: string): Book[]
   - title 또는 author에 query 포함된 책 찾기
   - 대소문자 구분 없이
   
2. getAvailableBooks(): Book[]
   - 대출 가능한 책만 반환
   
3. getBorrowedBooks(): Book[]
   - 대출 중인 책만 반환
   
4. getMemberLoans(memberId: string): Loan[]
   - 특정 회원의 모든 대출 기록
   - 반납한 것도 포함
   
5. getActiveLoans(): Loan[]
   - 현재 대출 중인 것만 (반납 안 한 것)
   
6. getOverdueLoans(): Loan[]
   - 연체 중인 대출만
   
조건:
- filter, map 등 배열 메서드 활용
- JSDoc 주석
- 타입 안전성
"
```

#### 통계 기능

**프롬프트 예시:**
```
"LibraryManager에 getStatistics 메서드를 추가해줘.

반환 타입:
interface LibraryStatistics {
  totalBooks: number;
  availableBooks: number;
  borrowedBooks: number;
  totalMembers: number;
  activeLoans: number;
  overdueLoans: number;
  totalLoans: number;
}

메서드:
getStatistics(): LibraryStatistics

로직:
- 각 항목을 계산하여 반환
- 기존 메서드들을 활용

조건:
- LibraryStatistics 인터페이스 먼저 정의
- JSDoc 주석

예시:
const stats = manager.getStatistics();
console.log(`전체 장서: ${stats.totalBooks}권`);
console.log(`대출 가능: ${stats.availableBooks}권`);
"
```


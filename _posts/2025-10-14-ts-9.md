---
title: "[TS] 함수 타입 시스템 - 2"
date: 2025-10-14 10:30:00 +0900
categories: [웹 개발, 타입스크립트]
tags: [웹개발, 타입스크립트, TS, ts함수]
pin: true
math: true
mermaid: true
---

> **학습 목표**
> - 함수의 매개변수와 반환 타입을 지정할 수 있다
> - 선택적 매개변수와 기본 매개변수를 사용할 수 있다
> - 함수 오버로딩을 이해하고 활용할 수 있다
> - 콜백 함수와 고차 함수에 타입을 지정할 수 있다

---

## ✏️ 직접 해보기

### 과제 1: 계산기 함수 만들기

다양한 타입의 매개변수를 받는 계산기 함수를 만들어보세요.

**요구사항:**
- 두 숫자를 받아 더하기, 빼기, 곱하기, 나누기 수행
- 연산 종류는 문자열로 받기 ("add", "subtract", "multiply", "divide")
- 잘못된 연산이나 0으로 나누기는 에러 처리
- 결과 출력 여부를 선택적 매개변수로 받기

\`\`\`typescript
// 여기를 완성하세요
function calculate(
  // ...
): number {
  // ...
}
\`\`\`

---

#### 정답 1: 계산기 함수 만들기

<details>
<summary>정답 보기</summary>

\`\`\`typescript
// 연산 타입 정의
type Operation = "add" | "subtract" | "multiply" | "divide";

// 계산기 함수
function calculate(
  a: number,
  b: number,
  operation: Operation,
  showResult: boolean = true
): number {
  let result: number;
  
  switch (operation) {
    case "add":
      result = a + b;
      break;
    case "subtract":
      result = a - b;
      break;
    case "multiply":
      result = a * b;
      break;
    case "divide":
      if (b === 0) {
        throw new Error("0으로 나눌 수 없습니다");
      }
      result = a / b;
      break;
    default:
      throw new Error(\`알 수 없는 연산: \${operation}\`);
  }
  
  if (showResult) {
    const symbols = {
      add: "+",
      subtract: "-",
      multiply: "×",
      divide: "÷"
    };
    console.log(\`\${a} \${symbols[operation]} \${b} = \${result}\`);
  }
  
  return result;
}

// 테스트
console.log("=== 계산기 테스트 ===");
calculate(10, 5, "add");           // 10 + 5 = 15
calculate(10, 5, "subtract");      // 10 - 5 = 5
calculate(10, 5, "multiply");      // 10 × 5 = 50
calculate(10, 5, "divide");        // 10 ÷ 5 = 2

// 결과 출력 안 함
const result = calculate(100, 20, "add", false);
console.log(\`저장된 결과: \${result}\`);  // 저장된 결과: 120

// 에러 처리
try {
  calculate(10, 0, "divide");
} catch (error) {
  console.log(\`에러: \${error.message}\`);
}

// 연속 계산
function calculateChain(...operations: [number, Operation, number][]): number {
  let result = operations[0][0];
  
  for (const [a, op, b] of operations) {
    result = calculate(result, b, op, false);
  }
  
  return result;
}

// (10 + 5) * 2 - 3 = 27
const chainResult = calculateChain(
  [10, "add", 5],
  [15, "multiply", 2],
  [30, "subtract", 3]
);
console.log(\`연속 계산 결과: \${chainResult}\`);
\`\`\`

</details>

---

### 과제 2: 배열 처리 유틸리티 함수

콜백 함수를 활용한 배열 처리 함수들을 만들어보세요.

**요구사항:**
- 배열의 각 요소를 출력하는 forEach 구현
- 조건에 맞는 요소만 필터링하는 filter 구현
- 배열의 모든 요소를 변환하는 map 구현
- 배열의 요소를 하나로 합치는 reduce 구현

\`\`\`typescript
// 여기를 완성하세요
\`\`\`

---

#### 정답 2: 배열 처리 유틸리티 함수

<details>
<summary>정답 보기</summary>

\`\`\`typescript
// forEach 구현
function forEach<T>(arr: T[], callback: (item: T, index: number) => void): void {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

// filter 구현
function filter<T>(arr: T[], predicate: (item: T) => boolean): T[] {
  const result: T[] = [];
  for (const item of arr) {
    if (predicate(item)) {
      result.push(item);
    }
  }
  return result;
}

// map 구현
function map<T, U>(arr: T[], transform: (item: T) => U): U[] {
  const result: U[] = [];
  for (const item of arr) {
    result.push(transform(item));
  }
  return result;
}

// reduce 구현
function reduce<T, U>(
  arr: T[],
  reducer: (accumulator: U, current: T) => U,
  initialValue: U
): U {
  let accumulator = initialValue;
  for (const item of arr) {
    accumulator = reducer(accumulator, item);
  }
  return accumulator;
}

// 테스트
console.log("=== forEach 테스트 ===");
const numbers = [1, 2, 3, 4, 5];
forEach(numbers, (num, index) => {
  console.log(\`[\${index}] \${num}\`);
});

console.log("\n=== filter 테스트 ===");
const evenNumbers = filter(numbers, (n) => n % 2 === 0);
console.log("짝수:", evenNumbers);  // [2, 4]

const largeNumbers = filter(numbers, (n) => n > 3);
console.log("3보다 큰 수:", largeNumbers);  // [4, 5]

console.log("\n=== map 테스트 ===");
const doubled = map(numbers, (n) => n * 2);
console.log("2배:", doubled);  // [2, 4, 6, 8, 10]

const squared = map(numbers, (n) => n * n);
console.log("제곱:", squared);  // [1, 4, 9, 16, 25]

const words = map(numbers, (n) => \`숫자 \${n}\`);
console.log("문자열 변환:", words);

console.log("\n=== reduce 테스트 ===");
const sum = reduce(numbers, (acc, n) => acc + n, 0);
console.log("합계:", sum);  // 15

const product = reduce(numbers, (acc, n) => acc * n, 1);
console.log("곱:", product);  // 120

const max = reduce(numbers, (acc, n) => (n > acc ? n : acc), numbers[0]);
console.log("최댓값:", max);  // 5

// 실전 예제: 학생 점수 처리
interface Student {
  name: string;
  score: number;
}

const students: Student[] = [
  { name: "홍길동", score: 85 },
  { name: "김철수", score: 92 },
  { name: "이영희", score: 78 },
  { name: "박민수", score: 95 },
  { name: "정수진", score: 88 }
];

console.log("\n=== 학생 점수 처리 ===");

// 90점 이상인 학생 필터링
const topStudents = filter(students, (s) => s.score >= 90);
console.log("우수 학생:");
forEach(topStudents, (s) => {
  console.log(\`  \${s.name}: \${s.score}점\`);
});

// 모든 학생 이름 추출
const names = map(students, (s) => s.name);
console.log("\n전체 학생:", names.join(", "));

// 평균 점수 계산
const totalScore = reduce(students, (sum, s) => sum + s.score, 0);
const average = totalScore / students.length;
console.log(\`\n평균 점수: \${average.toFixed(2)}점\`);
\`\`\`

</details>

---

### 과제 3: 함수 생성기 만들기

특정 동작을 하는 함수를 생성하는 고차 함수를 만들어보세요.

**요구사항:**
- 특정 값으로 시작하는 카운터 함수 생성기
- 특정 문자로 시작하는 ID 생성기
- 특정 범위 내의 난수를 생성하는 함수 생성기

\`\`\`typescript
// 여기를 완성하세요
\`\`\`

---

#### 정답 3: 함수 생성기 만들기

<details>
<summary>정답 보기</summary>

\`\`\`typescript
// 카운터 생성기
function createCounter(start: number = 0, step: number = 1): () => number {
  let count = start - step;  // 첫 호출에서 start가 되도록
  
  return (): number => {
    count += step;
    return count;
  };
}

// ID 생성기
function createIdGenerator(prefix: string = "ID"): () => string {
  let count = 0;
  
  return (): string => {
    count++;
    return \`\${prefix}-\${String(count).padStart(4, "0")}\`;
  };
}

// 난수 생성기
function createRandomGenerator(min: number, max: number): () => number {
  return (): number => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
}

// 테스트
console.log("=== 카운터 테스트 ===");
const counter1 = createCounter(1);
console.log(counter1());  // 1
console.log(counter1());  // 2
console.log(counter1());  // 3

const counter2 = createCounter(100, 10);
console.log(counter2());  // 100
console.log(counter2());  // 110
console.log(counter2());  // 120

console.log("\n=== ID 생성기 테스트 ===");
const userIdGen = createIdGenerator("USER");
console.log(userIdGen());  // USER-0001
console.log(userIdGen());  // USER-0002
console.log(userIdGen());  // USER-0003

const orderIdGen = createIdGenerator("ORDER");
console.log(orderIdGen());  // ORDER-0001
console.log(orderIdGen());  // ORDER-0002

console.log("\n=== 난수 생성기 테스트 ===");
const diceRoll = createRandomGenerator(1, 6);
console.log("주사위:");
for (let i = 0; i < 5; i++) {
  console.log(\`  \${i + 1}번째: \${diceRoll()}\`);
}

const randomScore = createRandomGenerator(0, 100);
console.log("\n랜덤 점수:");
for (let i = 0; i < 3; i++) {
  console.log(\`  \${i + 1}번째: \${randomScore()}점\`);
}

// 실전 예제: 주문 시스템
console.log("\n=== 주문 시스템 ===");

interface Order {
  id: string;
  productName: string;
  quantity: number;
  totalPrice: number;
}

function createOrderSystem(prefix: string = "ORD") {
  const idGenerator = createIdGenerator(prefix);
  const orders: Order[] = [];
  
  return {
    createOrder(productName: string, quantity: number, price: number): Order {
      const order: Order = {
        id: idGenerator(),
        productName,
        quantity,
        totalPrice: price * quantity
      };
      orders.push(order);
      return order;
    },
    
    getAllOrders(): Order[] {
      return [...orders];
    },
    
    getTotalRevenue(): number {
      return reduce(orders, (sum, order) => sum + order.totalPrice, 0);
    }
  };
}

const orderSystem = createOrderSystem("ORDER");

const order1 = orderSystem.createOrder("노트북", 2, 1000000);
const order2 = orderSystem.createOrder("마우스", 5, 30000);
const order3 = orderSystem.createOrder("키보드", 3, 80000);

console.log("주문 목록:");
forEach(orderSystem.getAllOrders(), (order) => {
  console.log(\`  \${order.id}: \${order.productName} (\${order.quantity}개) - \${order.totalPrice.toLocaleString()}원\`);
});

console.log(\`\n총 매출: \${orderSystem.getTotalRevenue().toLocaleString()}원\`);
\`\`\`

</details>

---

## ✅ 체크포인트

이번 챕터를 마치기 전에 다음 항목을 확인해보세요:

- [ ] 함수의 매개변수와 반환 타입을 지정할 수 있다
- [ ] 선택적 매개변수와 기본 매개변수의 차이를 안다
- [ ] 나머지 매개변수를 사용할 수 있다
- [ ] 함수 오버로딩을 이해하고 작성할 수 있다
- [ ] 함수 내부의 this 타입을 지정할 수 있다
- [ ] 콜백 함수의 타입을 정의할 수 있다
- [ ] 함수를 반환하는 함수를 작성할 수 있다
- [ ] 고차 함수를 활용할 수 있다

### 자가 진단 퀴즈

**1. 다음 중 올바른 함수 선언은?**

\`\`\`typescript
A. function add(a, b): number { return a + b; }
B. function add(a: number, b: number) { return a + b; }
C. function add(a: number, b: number): number { return a + b; }
D. function add(number a, number b): number { return a + b; }
\`\`\`

<details>
<summary>정답 보기</summary>

**정답: C**

- A: ❌ 매개변수 타입이 없음
- B: ✅ 동작은 하지만 반환 타입을 명시하는 것이 좋음
- C: ✅ 매개변수와 반환 타입 모두 명시 (권장)
- D: ❌ TypeScript 문법이 아님

</details>

---

**2. 선택적 매개변수에 대한 설명으로 올바른 것은?**

A. 선택적 매개변수는 필수 매개변수보다 앞에 와야 한다  
B. 선택적 매개변수는 `?`를 사용하여 표시한다  
C. 선택적 매개변수는 반드시 기본값을 가져야 한다  
D. 한 함수에 하나의 선택적 매개변수만 사용할 수 있다

<details>
<summary>정답 보기</summary>

**정답: B**

선택적 매개변수는 매개변수 이름 뒤에 `?`를 붙여 표시합니다. 선택적 매개변수는 필수 매개변수 뒤에 와야 하며, 기본값은 선택사항입니다.

\`\`\`typescript
function greet(name: string, greeting?: string): void {
  console.log(\`\${greeting || "안녕하세요"}, \${name}님!\`);
}
\`\`\`

</details>

---

**3. 다음 코드의 출력 결과는?**

\`\`\`typescript
function multiply(a: number, b: number = 2): number {
  return a * b;
}

console.log(multiply(5));
\`\`\`

A. 5  
B. 10  
C. 에러  
D. undefined

<details>
<summary>정답 보기</summary>

**정답: B (10)**

`b`의 기본값이 2이므로, `multiply(5)`는 `5 * 2 = 10`을 반환합니다.

</details>

---

**4. 함수 오버로딩에 대한 설명으로 올바른 것은?**

A. 같은 이름으로 여러 함수를 정의하는 것이다  
B. 오버로드 시그니처만 작성하면 된다  
C. 실제 구현부는 모든 오버로드 경우를 처리해야 한다  
D. TypeScript에서는 함수 오버로딩을 지원하지 않는다

<details>
<summary>정답 보기</summary>

**정답: C**

함수 오버로딩은 여러 오버로드 시그니처를 정의하고, 실제 구현부에서 모든 경우를 처리해야 합니다.

\`\`\`typescript
// 오버로드 시그니처
function combine(a: string, b: string): string;
function combine(a: number, b: number): number;

// 실제 구현 (모든 경우 처리)
function combine(a: string | number, b: string | number): string | number {
  // ...
}
\`\`\`

</details>

---

**5. 다음 중 고차 함수는?**

\`\`\`typescript
A. function add(a: number, b: number): number { return a + b; }
B. function forEach(arr: number[], fn: (n: number) => void): void { }
C. function log(message: string): void { console.log(message); }
D. function getAge(): number { return 25; }

<details>
<summary>정답 보기</summary>

**정답: B**

고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수입니다. `forEach`는 함수(`fn`)를 매개변수로 받으므로 고차 함수입니다.

</details>

---

## 💡 학습 팁

### 함수 타입 마스터하기

**1. 매개변수부터 시작하기**

복잡한 함수 타입을 작성하기 전에, 간단한 매개변수 타입부터 시작하세요.

\`\`\`typescript
// 1단계: 기본 매개변수
function greet(name: string) {
  console.log(\`안녕, \${name}\`);
}

// 2단계: 여러 매개변수
function add(a: number, b: number) {
  return a + b;
}

// 3단계: 반환 타입 추가
function multiply(a: number, b: number): number {
  return a * b;
}

// 4단계: 선택적 매개변수
function createUser(name: string, age?: number) {
  // ...
}

// 5단계: 콜백 함수
function process(callback: (result: number) => void) {
  callback(42);
}
\`\`\`

**2. 에러 메시지를 활용하기**

TypeScript의 에러 메시지는 함수 사용 방법을 알려줍니다.

\`\`\`typescript
function divide(a: number, b: number): number {
  return a / b;
}

divide("10", 5);
// Error: Argument of type 'string' is not assignable to parameter of type 'number'.
// → 첫 번째 매개변수는 number여야 함을 알려줌
\`\`\`

**3. 함수를 작게 나누기**

복잡한 함수는 작은 함수들로 나누어 작성하세요. 각 함수에 명확한 타입을 지정하면 전체 코드가 더 안전해집니다.

\`\`\`typescript
// ❌ 복잡한 함수
function processUserData(data: any) {
  // 데이터 검증, 변환, 저장을 모두 수행
}

// ✅ 작은 함수들로 분리
function validateUserData(data: unknown): boolean {
  // 검증만 수행
}

function transformUserData(data: RawData): User {
  // 변환만 수행
}

function saveUserData(user: User): void {
  // 저장만 수행
}
\`\`\`

**4. 실전 예제로 연습하기**

배운 내용을 자신의 프로젝트에 적용해보세요:
- 계산기 만들기
- 배열 유틸리티 함수 만들기
- 게임 캐릭터 시스템 만들기

### 일반적인 실수와 해결법

**실수 1: 반환 타입 누락**

\`\`\`typescript
// ❌ 나쁜 예
function calculate(a: number, b: number) {
  return a + b;
}

// ✅ 좋은 예
function calculate(a: number, b: number): number {
  return a + b;
}
\`\`\`

반환 타입을 명시하면 실수로 잘못된 값을 반환하는 것을 방지할 수 있습니다.

**실수 2: 선택적 매개변수 순서 오류**

\`\`\`typescript
// ❌ 나쁜 예
function createUser(age?: number, name: string) {
  // 에러! 선택적 매개변수는 마지막에
}

// ✅ 좋은 예
function createUser(name: string, age?: number) {
  // 올바른 순서
}
\`\`\`

**실수 3: 콜백 함수 타입 미지정**

\`\`\`typescript
// ❌ 나쁜 예
function forEach(arr: number[], callback) {
  // callback 타입이 any
}

// ✅ 좋은 예
function forEach(arr: number[], callback: (item: number) => void) {
  // 명확한 타입
}
\`\`\`

### AI 활용 팁

**효과적인 질문 방법:**

\`\`\`
1. "함수 오버로딩 예제를 보여줘"
   → 구체적인 개념 요청

2. "이 함수에 타입을 추가해줘: [코드]"
   → 코드와 함께 요청

3. "콜백 함수의 타입을 어떻게 지정하나요?"
   → 구체적인 문법 질문

4. "고차 함수를 사용하는 실전 예제를 알려줘"
   → 실전 활용법 질문
\`\`\`

**❌ 피해야 할 질문:**

\`\`\`
- "함수 타입 알려줘" (너무 광범위)
- "이 코드 고쳐줘" (문제가 무엇인지 불명확)
- "함수 만들어줘" (요구사항 없음)
\`\`\`

---

## 🎯 다음 챕터 미리보기

Chapter 9에서는 **인터페이스와 타입 별칭**을 배웁니다!
- 인터페이스로 객체 구조 정의하기
- 타입 별칭 사용하기
- 인터페이스 확장과 병합
- 인터페이스 vs 타입 별칭

**미리 준비하기:**
- Chapter 8의 모든 과제를 완성하세요
- 객체 타입 정의를 복습하세요
- 함수 타입 지정을 복습하세요

**미리 생각해보기:**

지금까지 객체 타입을 다음과 같이 정의했습니다:

\`\`\`typescript
let user: { name: string; age: number };
\`\`\`

만약 같은 구조의 객체를 여러 번 사용해야 한다면 어떻게 해야 할까요? 매번 타입을 반복해서 작성해야 할까요? 🤔

다음 챕터에서는 이런 문제를 해결하는 방법을 배워봅시다!

---

**축하합니다! Chapter 8을 완료했습니다! 🎉**

함수에 타입을 지정하는 방법을 모두 배웠습니다! 이제 여러분은:
- ✅ 함수의 매개변수와 반환 타입을 지정할 수 있다
- ✅ 선택적 매개변수와 기본 매개변수를 사용할 수 있다
- ✅ 함수 오버로딩을 활용할 수 있다
- ✅ 콜백 함수와 고차 함수를 작성할 수 있다

TypeScript 함수는 JavaScript 함수보다 훨씬 안전하고 명확합니다. 이제 복잡한 함수도 자신있게 작성할 수 있습니다! 💪

다음 챕터에서는 재사용 가능한 타입을 정의하는 방법을 배워봅시다!

**🚀 Chapter 9에서 만나요!**

---
title: "[TS] ë°ì½”ë ˆì´í„° - 2"
date: 2025-10-23 16:00:00 +0900
categories: [ì›¹ ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸]
tags: [ì›¹ê°œë°œ, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, TS, ë°ì½”ë ˆì´í„°, decorator]
pin: true
math: true
mermaid: true
---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

* ë°ì½”ë ˆì´í„°ì˜ ê°œë…ê³¼ ë™ì‘ ì›ë¦¬ë¥¼ ì´í•´í•œë‹¤
* TypeScriptì—ì„œ ë°ì½”ë ˆì´í„° ê¸°ëŠ¥ì„ í™œì„±í™”í•  ìˆ˜ ìˆë‹¤
* í´ë˜ìŠ¤ ë°ì½”ë ˆì´í„°ë¡œ í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•˜ê³  í™•ì¥í•  ìˆ˜ ìˆë‹¤
* ë©”ì„œë“œ ë°ì½”ë ˆì´í„°ë¡œ ë©”ì„œë“œ ë™ì‘ì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤
* í”„ë¡œí¼í‹° ë°ì½”ë ˆì´í„°ë¡œ ì†ì„±ì— ë©”íƒ€ë°ì´í„°ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤
* ë§¤ê°œë³€ìˆ˜ ë°ì½”ë ˆì´í„°ë¡œ íŒŒë¼ë¯¸í„° ì •ë³´ë¥¼ ì¶”ì¶œí•  ìˆ˜ ìˆë‹¤
* ë°ì½”ë ˆì´í„° íŒ©í† ë¦¬ë¡œ ì„¤ì • ê°€ëŠ¥í•œ ë°ì½”ë ˆì´í„°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤
* ì‹¤ì „ì—ì„œ ìœ íš¨ì„± ê²€ì‚¬, ë¡œê¹…, ì˜ì¡´ì„± ì£¼ì…ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤

---

## 16.4 í”„ë¡œí¼í‹° ë°ì½”ë ˆì´í„°

### ì†ì„± ë©”íƒ€ë°ì´í„°

í”„ë¡œí¼í‹° ë°ì½”ë ˆì´í„°ëŠ” **í´ë˜ìŠ¤ ì†ì„±ì— ë©”íƒ€ë°ì´í„°ë¥¼ ì¶”ê°€**í•©ë‹ˆë‹¤.

**ë¬¸ë²•:**
```typescript
function PropertyDecorator(
  target: any,                    // í´ë˜ìŠ¤ì˜ prototype (ì¸ìŠ¤í„´ìŠ¤ ì†ì„±) ë˜ëŠ” ìƒì„±ì (ì •ì  ì†ì„±)
  propertyKey: string | symbol    // ì†ì„± ì´ë¦„
) {
  // ì†ì„± ìì²´ëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŒ (descriptorê°€ ì—†ìŒ)
  // ëŒ€ì‹  ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥
}

class MyClass {
  @PropertyDecorator
  myProperty: string;
}
```

**ê¸°ë³¸ ì˜ˆì œ:**
```typescript
import 'reflect-metadata';

function Required(target: any, propertyKey: string) {
  // ë©”íƒ€ë°ì´í„° ì €ì¥
  Reflect.defineMetadata('required', true, target, propertyKey);
}

class User {
  @Required
  name: string;
  
  @Required
  email: string;
  
  age?: number;  // ì„ íƒì 
  
  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }
}

// ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜
function validate(obj: any): boolean {
  const properties = Object.getOwnPropertyNames(obj);
  
  for (const prop of properties) {
    const isRequired = Reflect.getMetadata('required', obj, prop);
    
    if (isRequired && !obj[prop]) {
      console.error(`Property ${prop} is required`);
      return false;
    }
  }
  
  return true;
}

const user1 = new User("í™ê¸¸ë™", "hong@example.com");
console.log(validate(user1));  // true

const user2 = new User("", "");
console.log(validate(user2));  // false
// ì¶œë ¥: Property name is required
```

**ì˜ˆì œ 1: í¬ë§·íŒ…**
```typescript
function Format(pattern: string) {
  return function(target: any, propertyKey: string) {
    Reflect.defineMetadata('format', pattern, target, propertyKey);
  };
}

class Product {
  @Format('currency')
  price: number;
  
  @Format('date')
  createdAt: Date;
  
  constructor(price: number) {
    this.price = price;
    this.createdAt = new Date();
  }
}

// í¬ë§·íŒ… í•¨ìˆ˜
function format(obj: any, propertyKey: string): string {
  const value = obj[propertyKey];
  const formatPattern = Reflect.getMetadata('format', obj, propertyKey);
  
  if (formatPattern === 'currency') {
    return `$${value.toFixed(2)}`;
  }
  
  if (formatPattern === 'date') {
    return value.toISOString().split('T')[0];
  }
  
  return String(value);
}

const product = new Product(1234.5);
console.log(format(product, 'price'));      // $1234.50
console.log(format(product, 'createdAt'));  // 2024-01-15
```

**ì˜ˆì œ 2: ìµœì†Œ/ìµœëŒ€ ê°’**
```typescript
function Min(min: number) {
  return function(target: any, propertyKey: string) {
    Reflect.defineMetadata('min', min, target, propertyKey);
  };
}

function Max(max: number) {
  return function(target: any, propertyKey: string) {
    Reflect.defineMetadata('max', max, target, propertyKey);
  };
}

class Product {
  @Min(0)
  @Max(1000000)
  price: number;
  
  @Min(0)
  stock: number;
  
  constructor(price: number, stock: number) {
    this.price = price;
    this.stock = stock;
  }
}

function validateRange(obj: any): boolean {
  const properties = Object.getOwnPropertyNames(obj);
  
  for (const prop of properties) {
    const value = obj[prop];
    const min = Reflect.getMetadata('min', obj, prop);
    const max = Reflect.getMetadata('max', obj, prop);
    
    if (min !== undefined && value < min) {
      console.error(`${prop} must be at least ${min}`);
      return false;
    }
    
    if (max !== undefined && value > max) {
      console.error(`${prop} must be at most ${max}`);
      return false;
    }
  }
  
  return true;
}

const product1 = new Product(500, 10);
console.log(validateRange(product1));  // true

const product2 = new Product(-100, 5);
console.log(validateRange(product2));  // false
// ì¶œë ¥: price must be at least 0

const product3 = new Product(2000000, 5);
console.log(validateRange(product3));  // false
// ì¶œë ¥: price must be at most 1000000
```

**ì˜ˆì œ 3: íƒ€ì… ê²€ì¦**
```typescript
function IsString(target: any, propertyKey: string) {
  Reflect.defineMetadata('type', 'string', target, propertyKey);
}

function IsNumber(target: any, propertyKey: string) {
  Reflect.defineMetadata('type', 'number', target, propertyKey);
}

function IsEmail(target: any, propertyKey: string) {
  Reflect.defineMetadata('validator', 'email', target, propertyKey);
}

class User {
  @IsString
  name: string;
  
  @IsNumber
  @Min(0)
  age: number;
  
  @IsString
  @IsEmail
  email: string;
  
  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
}

function validateType(obj: any): boolean {
  const properties = Object.getOwnPropertyNames(obj);
  
  for (const prop of properties) {
    const value = obj[prop];
    const expectedType = Reflect.getMetadata('type', obj, prop);
    const validator = Reflect.getMetadata('validator', obj, prop);
    
    // íƒ€ì… ê²€ì¦
    if (expectedType && typeof value !== expectedType) {
      console.error(`${prop} must be ${expectedType}`);
      return false;
    }
    
    // ì´ë©”ì¼ ê²€ì¦
    if (validator === 'email') {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        console.error(`${prop} must be a valid email`);
        return false;
      }
    }
  }
  
  return true;
}

const user1 = new User("í™ê¸¸ë™", 30, "hong@example.com");
console.log(validateType(user1));  // true

const user2 = new User("ê¹€ì² ìˆ˜", 25, "invalid-email");
console.log(validateType(user2));  // false
// ì¶œë ¥: email must be a valid email
```

---

## 16.5 ë§¤ê°œë³€ìˆ˜ ë°ì½”ë ˆì´í„°

ë§¤ê°œë³€ìˆ˜ ë°ì½”ë ˆì´í„°ëŠ” **ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ì— ë©”íƒ€ë°ì´í„°ë¥¼ ì¶”ê°€**í•©ë‹ˆë‹¤.

**ë¬¸ë²•:**
```typescript
function ParameterDecorator(
  target: any,                    // í´ë˜ìŠ¤ì˜ prototype
  propertyKey: string | symbol,  // ë©”ì„œë“œ ì´ë¦„
  parameterIndex: number          // ë§¤ê°œë³€ìˆ˜ì˜ ìœ„ì¹˜ (0ë¶€í„° ì‹œì‘)
) {
  // ë§¤ê°œë³€ìˆ˜ ì •ë³´ë¥¼ ë©”íƒ€ë°ì´í„°ë¡œ ì €ì¥
}

class MyClass {
  myMethod(@ParameterDecorator param: string) {}
}
```

**ê¸°ë³¸ ì˜ˆì œ:**
```typescript
import 'reflect-metadata';

function Required(target: any, propertyKey: string, parameterIndex: number) {
  const existingRequiredParameters: number[] =
    Reflect.getOwnMetadata('required', target, propertyKey) || [];
  
  existingRequiredParameters.push(parameterIndex);
  
  Reflect.defineMetadata(
    'required',
    existingRequiredParameters,
    target,
    propertyKey
  );
}

class UserService {
  createUser(
    @Required name: string,
    @Required email: string,
    age?: number
  ) {
    return { name, email, age };
  }
}

// ìœ íš¨ì„± ê²€ì‚¬
function validateParameters(
  target: any,
  propertyKey: string,
  args: any[]
): boolean {
  const requiredParameters: number[] =
    Reflect.getOwnMetadata('required', target, propertyKey) || [];
  
  for (const index of requiredParameters) {
    if (args[index] === undefined || args[index] === null || args[index] === '') {
      console.error(`Parameter at index ${index} is required`);
      return false;
    }
  }
  
  return true;
}

const service = new UserService();

// ìœ íš¨ì„± ê²€ì‚¬ ë˜í¼
function callWithValidation(
  obj: any,
  methodName: string,
  ...args: any[]
) {
  if (validateParameters(obj, methodName, args)) {
    return obj[methodName](...args);
  }
  throw new Error('Parameter validation failed');
}

callWithValidation(service, 'createUser', 'í™ê¸¸ë™', 'hong@example.com', 30);  // âœ… OK
callWithValidation(service, 'createUser', '', 'hong@example.com');  // âŒ ì—ëŸ¬
// ì¶œë ¥: Parameter at index 0 is required
```

### ì˜ˆì œ 1: ì˜ì¡´ì„± ì£¼ì…**
```typescript
function Inject(serviceIdentifier: string) {
  return function(target: any, propertyKey: string, parameterIndex: number) {
    const existingInjectedParams: { index: number; id: string }[] =
      Reflect.getOwnMetadata('inject', target, propertyKey) || [];
    
    existingInjectedParams.push({
      index: parameterIndex,
      id: serviceIdentifier
    });
    
    Reflect.defineMetadata('inject', existingInjectedParams, target, propertyKey);
  };
}

// ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆ
const services = new Map<string, any>();
services.set('userRepository', { findById: (id: number) => ({ id, name: 'User' }) });
services.set('logger', { log: (msg: string) => console.log(msg) });

class UserService {
  getUser(
    @Inject('userRepository') repo: any,
    @Inject('logger') logger: any,
    id: number
  ) {
    logger.log(`Getting user ${id}`);
    return repo.findById(id);
  }
}

// ì˜ì¡´ì„± ì£¼ì… ì‹¤í–‰
function callWithInjection(obj: any, methodName: string, ...args: any[]) {
  const injectedParams: { index: number; id: string }[] =
    Reflect.getOwnMetadata('inject', obj, methodName) || [];
  
  const finalArgs = [...args];
  
  // ì£¼ì…í•  íŒŒë¼ë¯¸í„° ì±„ìš°ê¸°
  for (const param of injectedParams) {
    finalArgs[param.index] = services.get(param.id);
  }
  
  return obj[methodName](...finalArgs);
}

const userService = new UserService();
const user = callWithInjection(userService, 'getUser', 1);  // repoì™€ loggerëŠ” ìë™ ì£¼ì…
console.log(user);  // { id: 1, name: 'User' }
```

### ì˜ˆì œ 2: íƒ€ì… ê²€ì¦
```typescript
function ValidateType(expectedType: string) {
  return function(target: any, propertyKey: string, parameterIndex: number) {
    const existingTypes: { index: number; type: string }[] =
      Reflect.getOwnMetadata('paramTypes', target, propertyKey) || [];
    
    existingTypes.push({
      index: parameterIndex,
      type: expectedType
    });
    
    Reflect.defineMetadata('paramTypes', existingTypes, target, propertyKey);
  };
}

class Calculator {
  add(
    @ValidateType('number') a: number,
    @ValidateType('number') b: number
  ): number {
    return a + b;
  }
}

function validateAndCall(obj: any, methodName: string, ...args: any[]) {
  const paramTypes: { index: number; type: string }[] =
    Reflect.getOwnMetadata('paramTypes', obj, methodName) || [];
  
  for (const param of paramTypes) {
    if (typeof args[param.index] !== param.type) {
      throw new Error(
        `Parameter at index ${param.index} must be ${param.type}, got ${typeof args[param.index]}`
      );
    }
  }
  
  return obj[methodName](...args);
}

const calc = new Calculator();
console.log(validateAndCall(calc, 'add', 5, 3));  // âœ… 8
console.log(validateAndCall(calc, 'add', '5', 3));  // âŒ ì—ëŸ¬!
```

### ì˜ˆì œ 3: ë¡œê¹… íŠ¹ì • íŒŒë¼ë¯¸í„°
```typescript
function LogParam(target: any, propertyKey: string, parameterIndex: number) {
  const existingLogParams: number[] =
    Reflect.getOwnMetadata('logParams', target, propertyKey) || [];
  
  existingLogParams.push(parameterIndex);
  
  Reflect.defineMetadata('logParams', existingLogParams, target, propertyKey);
}

function AutoLog(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function(...args: any[]) {
    const logParams: number[] =
      Reflect.getOwnMetadata('logParams', target, propertyKey) || [];
    
    if (logParams.length > 0) {
      console.log(`${propertyKey} called with logged params:`);
      for (const index of logParams) {
        console.log(`  Param ${index}:`, args[index]);
      }
    }
    
    return originalMethod.apply(this, args);
  };
  
  return descriptor;
}

class PaymentService {
  @AutoLog
  processPayment(
    @LogParam userId: number,
    amount: number,
    @LogParam method: string
  ) {
    console.log(`Processing payment of ${amount} for user ${userId}`);
    return { success: true };
  }
}

const payment = new PaymentService();
payment.processPayment(123, 50000, 'credit-card');
// ì¶œë ¥:
// processPayment called with logged params:
//   Param 0: 123
//   Param 2: credit-card
// Processing payment of 50000 for user 123
```

## 16.6 ë°ì½”ë ˆì´í„° íŒ©í† ë¦¬

### ì„¤ì • ê°€ëŠ¥í•œ ë°ì½”ë ˆì´í„°

ë°ì½”ë ˆì´í„° íŒ©í† ë¦¬ëŠ” ì„¤ì •ì„ ë°›ì•„ì„œ ë°ì½”ë ˆì´í„°ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.

**ë¬¸ë²•:**
```typescript
// ë°ì½”ë ˆì´í„° íŒ©í† ë¦¬
function DecoratorFactory(config: any) {
  // ì„¤ì •ì„ ë°›ìŒ
  
  // ì‹¤ì œ ë°ì½”ë ˆì´í„°ë¥¼ ë°˜í™˜
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // configë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì‘
  };
}

class MyClass {
  @DecoratorFactory({ option: 'value' })
  myMethod() {}
}
```

**ê¸°ë³¸ ì˜ˆì œ:**
```typescript
// ì„¤ì • ê°€ëŠ¥í•œ ë¡œê¹… ë°ì½”ë ˆì´í„°
function Log(prefix: string) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      console.log(`[${prefix}] ${propertyKey} called with:`, args);
      const result = originalMethod.apply(this, args);
      console.log(`[${prefix}] ${propertyKey} returned:`, result);
      return result;
    };
    
    return descriptor;
  };
}

class UserService {
  @Log('USER')
  getUser(id: number) {
    return { id, name: 'User' };
  }
}

class ProductService {
  @Log('PRODUCT')
  getProduct(id: number) {
    return { id, name: 'Product' };
  }
}

const userService = new UserService();
userService.getUser(1);
// ì¶œë ¥:
// [USER] getUser called with: [1]
// [USER] getUser returned: { id: 1, name: 'User' }

const productService = new ProductService();
productService.getProduct(1);
// ì¶œë ¥:
// [PRODUCT] getProduct called with: [1]
// [PRODUCT] getProduct returned: { id: 1, name: 'Product' }
```

### ì˜ˆì œ 1: ì¬ì‹œë„ ì„¤ì •
```typescript
interface RetryConfig {
  times: number;
  delay: number;
  exponentialBackoff?: boolean;
}

function Retry(config: RetryConfig) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args: any[]) {
      let lastError: any;
      
      for (let i = 0; i < config.times; i++) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          lastError = error;
          
          if (i < config.times - 1) {
            const delay = config.exponentialBackoff
              ? config.delay * Math.pow(2, i)
              : config.delay;
            
            console.log(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      throw lastError;
    };
    
    return descriptor;
  };
}

class ApiService {
  @Retry({ times: 3, delay: 1000, exponentialBackoff: true })
  async fetchData(url: string) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('Fetch failed');
    }
    return response.json();
  }
}

// ì²« ì‹œë„: ì¦‰ì‹œ
// ë‘ ë²ˆì§¸ ì‹œë„: 1ì´ˆ í›„
// ì„¸ ë²ˆì§¸ ì‹œë„: 2ì´ˆ í›„
// ë„¤ ë²ˆì§¸ ì‹œë„: 4ì´ˆ í›„
```

### ì˜ˆì œ 2: ìºì‹± ì „ëµ
```typescript
interface CacheConfig {
  ttl: number;  // Time To Live (ë°€ë¦¬ì´ˆ)
  key?: (args: any[]) => string;  // ì»¤ìŠ¤í…€ í‚¤ ìƒì„±
}

function Cache(config: CacheConfig) {
  const cache = new Map<string, { value: any; expiry: number }>();
  
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      const cacheKey = config.key
        ? config.key(args)
        : JSON.stringify(args);
      
      const cached = cache.get(cacheKey);
      const now = Date.now();
      
      if (cached && cached.expiry > now) {
        console.log(`Cache hit for ${propertyKey}`);
        return cached.value;
      }
      
      console.log(`Cache miss for ${propertyKey}`);
      const result = originalMethod.apply(this, args);
      
      cache.set(cacheKey, {
        value: result,
        expiry: now + config.ttl
      });
      
      return result;
    };
    
    return descriptor;
  };
}

class UserService {
  @Cache({
    ttl: 5000,  // 5ì´ˆ
    key: (args) => `user:${args[0]}`
  })
  getUser(id: number) {
    console.log('Fetching user from database...');
    return { id, name: 'User', fetchedAt: Date.now() };
  }
}

const service = new UserService();
console.log(service.getUser(1));  // Cache miss
console.log(service.getUser(1));  // Cache hit (5ì´ˆ ë‚´)
setTimeout(() => {
  console.log(service.getUser(1));  // Cache miss (5ì´ˆ í›„)
}, 6000);
```

### ì˜ˆì œ 3: ê¶Œí•œ ê²€ì‚¬
```typescript
function RequireRole(...roles: string[]) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(this: any, ...args: any[]) {
      // í˜„ì¬ ì‚¬ìš©ì ì—­í•  ê°€ì ¸ì˜¤ê¸° (this.currentUserë¥¼ ê°€ì •)
      const userRole = this.currentUser?.role;
      
      if (!userRole || !roles.includes(userRole)) {
        throw new Error(
          `Access denied. Required roles: ${roles.join(', ')}`
        );
      }
      
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

class AdminService {
  currentUser: { id: number; role: string } | null = null;
  
  @RequireRole('admin')
  deleteUser(id: number) {
    console.log(`Deleting user ${id}`);
    return { success: true };
  }
  
  @RequireRole('admin', 'moderator')
  banUser(id: number) {
    console.log(`Banning user ${id}`);
    return { success: true };
  }
}

const adminService = new AdminService();

// ê´€ë¦¬ìë¡œ ë¡œê·¸ì¸
adminService.currentUser = { id: 1, role: 'admin' };
adminService.deleteUser(100);  // âœ… OK
adminService.banUser(200);     // âœ… OK

// ì¼ë°˜ ì‚¬ìš©ìë¡œ ë¡œê·¸ì¸
adminService.currentUser = { id: 2, role: 'user' };
adminService.deleteUser(100);  // âŒ ì—ëŸ¬: Access denied
ì˜ˆì œ 4: ì„±ëŠ¥ ì„ê³„ê°’
typescriptinterface PerformanceConfig {
  threshold: number;  // ë°€ë¦¬ì´ˆ
  onSlow?: (time: number, methodName: string) => void;
}

function Monitor(config: PerformanceConfig) {
  return function(
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args: any[]) {
      const start = performance.now();
      const result = originalMethod.apply(this, args);
      const end = performance.now();
      const duration = end - start;
      
      if (duration > config.threshold) {
        const message = `${propertyKey} took ${duration.toFixed(2)}ms (threshold: ${config.threshold}ms)`;
        
        if (config.onSlow) {
          config.onSlow(duration, propertyKey);
        } else {
          console.warn(`âš ï¸ SLOW: ${message}`);
        }
      }
      
      return result;
    };
    
    return descriptor;
  };
}

class DataService {
  @Monitor({
    threshold: 100,
    onSlow: (time, method) => {
      console.error(`ALERT: ${method} exceeded threshold by ${time - 100}ms`);
      // ì•Œë¦¼ ì „ì†¡, ë¡œê·¸ ê¸°ë¡ ë“±
    }
  })
  processData(size: number): number[] {
    const data: number[] = [];
    for (let i = 0; i < size; i++) {
      data.push(Math.random());
    }
    return data;
  }
}

const service = new DataService();
service.processData(10);       // ë¹ ë¦„, ê²½ê³  ì—†ìŒ
```
service.processData(10000000); // ëŠë¦¼, ê²½ê³  ë°œìƒ
```
